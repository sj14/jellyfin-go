/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.9.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
	"time"
)


type ItemsAPI interface {

	/*
	GetItemUserData Get Item User Data.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiGetItemUserDataRequest
	*/
	GetItemUserData(ctx context.Context, itemId string) ApiGetItemUserDataRequest

	// GetItemUserDataExecute executes the request
	//  @return UserItemDataDto
	GetItemUserDataExecute(r ApiGetItemUserDataRequest) (*UserItemDataDto, *http.Response, error)

	/*
	GetItems Gets items based on a query.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetItemsRequest
	*/
	GetItems(ctx context.Context) ApiGetItemsRequest

	// GetItemsExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetItemsExecute(r ApiGetItemsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetResumeItems Gets items based on a query.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetResumeItemsRequest
	*/
	GetResumeItems(ctx context.Context) ApiGetResumeItemsRequest

	// GetResumeItemsExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetResumeItemsExecute(r ApiGetResumeItemsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	UpdateItemUserData Update Item User Data.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiUpdateItemUserDataRequest
	*/
	UpdateItemUserData(ctx context.Context, itemId string) ApiUpdateItemUserDataRequest

	// UpdateItemUserDataExecute executes the request
	//  @return UserItemDataDto
	UpdateItemUserDataExecute(r ApiUpdateItemUserDataRequest) (*UserItemDataDto, *http.Response, error)
}

// ItemsAPIService ItemsAPI service
type ItemsAPIService service

type ApiGetItemUserDataRequest struct {
	ctx context.Context
	ApiService ItemsAPI
	itemId string
	userId *string
}

// The user id.
func (r ApiGetItemUserDataRequest) UserId(userId string) ApiGetItemUserDataRequest {
	r.userId = &userId
	return r
}

func (r ApiGetItemUserDataRequest) Execute() (*UserItemDataDto, *http.Response, error) {
	return r.ApiService.GetItemUserDataExecute(r)
}

/*
GetItemUserData Get Item User Data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiGetItemUserDataRequest
*/
func (a *ItemsAPIService) GetItemUserData(ctx context.Context, itemId string) ApiGetItemUserDataRequest {
	return ApiGetItemUserDataRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return UserItemDataDto
func (a *ItemsAPIService) GetItemUserDataExecute(r ApiGetItemUserDataRequest) (*UserItemDataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserItemDataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsAPIService.GetItemUserData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserItems/{itemId}/UserData"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemsRequest struct {
	ctx context.Context
	ApiService ItemsAPI
	userId *string
	maxOfficialRating *string
	hasThemeSong *bool
	hasThemeVideo *bool
	hasSubtitles *bool
	hasSpecialFeature *bool
	hasTrailer *bool
	adjacentTo *string
	parentIndexNumber *int32
	hasParentalRating *bool
	isHd *bool
	is4K *bool
	locationTypes *[]LocationType
	excludeLocationTypes *[]LocationType
	isMissing *bool
	isUnaired *bool
	minCommunityRating *float64
	minCriticRating *float64
	minPremiereDate *time.Time
	minDateLastSaved *time.Time
	minDateLastSavedForUser *time.Time
	maxPremiereDate *time.Time
	hasOverview *bool
	hasImdbId *bool
	hasTmdbId *bool
	hasTvdbId *bool
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	excludeItemIds *[]string
	startIndex *int32
	limit *int32
	recursive *bool
	searchTerm *string
	sortOrder *[]SortOrder
	parentId *string
	fields *[]ItemFields
	excludeItemTypes *[]BaseItemKind
	includeItemTypes *[]BaseItemKind
	filters *[]ItemFilter
	isFavorite *bool
	mediaTypes *[]MediaType
	imageTypes *[]ImageType
	sortBy *[]ItemSortBy
	isPlayed *bool
	genres *[]string
	officialRatings *[]string
	tags *[]string
	years *[]int32
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *[]ImageType
	person *string
	personIds *[]string
	personTypes *[]string
	studios *[]string
	artists *[]string
	excludeArtistIds *[]string
	artistIds *[]string
	albumArtistIds *[]string
	contributingArtistIds *[]string
	albums *[]string
	albumIds *[]string
	ids *[]string
	videoTypes *[]VideoType
	minOfficialRating *string
	isLocked *bool
	isPlaceHolder *bool
	hasOfficialRating *bool
	collapseBoxSetItems *bool
	minWidth *int32
	minHeight *int32
	maxWidth *int32
	maxHeight *int32
	is3D *bool
	seriesStatus *[]SeriesStatus
	nameStartsWithOrGreater *string
	nameStartsWith *string
	nameLessThan *string
	studioIds *[]string
	genreIds *[]string
	enableTotalRecordCount *bool
	enableImages *bool
}

// The user id supplied as query parameter; this is required when not using an API key.
func (r ApiGetItemsRequest) UserId(userId string) ApiGetItemsRequest {
	r.userId = &userId
	return r
}

// Optional filter by maximum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetItemsRequest) MaxOfficialRating(maxOfficialRating string) ApiGetItemsRequest {
	r.maxOfficialRating = &maxOfficialRating
	return r
}

// Optional filter by items with theme songs.
func (r ApiGetItemsRequest) HasThemeSong(hasThemeSong bool) ApiGetItemsRequest {
	r.hasThemeSong = &hasThemeSong
	return r
}

// Optional filter by items with theme videos.
func (r ApiGetItemsRequest) HasThemeVideo(hasThemeVideo bool) ApiGetItemsRequest {
	r.hasThemeVideo = &hasThemeVideo
	return r
}

// Optional filter by items with subtitles.
func (r ApiGetItemsRequest) HasSubtitles(hasSubtitles bool) ApiGetItemsRequest {
	r.hasSubtitles = &hasSubtitles
	return r
}

// Optional filter by items with special features.
func (r ApiGetItemsRequest) HasSpecialFeature(hasSpecialFeature bool) ApiGetItemsRequest {
	r.hasSpecialFeature = &hasSpecialFeature
	return r
}

// Optional filter by items with trailers.
func (r ApiGetItemsRequest) HasTrailer(hasTrailer bool) ApiGetItemsRequest {
	r.hasTrailer = &hasTrailer
	return r
}

// Optional. Return items that are siblings of a supplied item.
func (r ApiGetItemsRequest) AdjacentTo(adjacentTo string) ApiGetItemsRequest {
	r.adjacentTo = &adjacentTo
	return r
}

// Optional filter by parent index number.
func (r ApiGetItemsRequest) ParentIndexNumber(parentIndexNumber int32) ApiGetItemsRequest {
	r.parentIndexNumber = &parentIndexNumber
	return r
}

// Optional filter by items that have or do not have a parental rating.
func (r ApiGetItemsRequest) HasParentalRating(hasParentalRating bool) ApiGetItemsRequest {
	r.hasParentalRating = &hasParentalRating
	return r
}

// Optional filter by items that are HD or not.
func (r ApiGetItemsRequest) IsHd(isHd bool) ApiGetItemsRequest {
	r.isHd = &isHd
	return r
}

// Optional filter by items that are 4K or not.
func (r ApiGetItemsRequest) Is4K(is4K bool) ApiGetItemsRequest {
	r.is4K = &is4K
	return r
}

// Optional. If specified, results will be filtered based on LocationType. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) LocationTypes(locationTypes []LocationType) ApiGetItemsRequest {
	r.locationTypes = &locationTypes
	return r
}

// Optional. If specified, results will be filtered based on the LocationType. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) ExcludeLocationTypes(excludeLocationTypes []LocationType) ApiGetItemsRequest {
	r.excludeLocationTypes = &excludeLocationTypes
	return r
}

// Optional filter by items that are missing episodes or not.
func (r ApiGetItemsRequest) IsMissing(isMissing bool) ApiGetItemsRequest {
	r.isMissing = &isMissing
	return r
}

// Optional filter by items that are unaired episodes or not.
func (r ApiGetItemsRequest) IsUnaired(isUnaired bool) ApiGetItemsRequest {
	r.isUnaired = &isUnaired
	return r
}

// Optional filter by minimum community rating.
func (r ApiGetItemsRequest) MinCommunityRating(minCommunityRating float64) ApiGetItemsRequest {
	r.minCommunityRating = &minCommunityRating
	return r
}

// Optional filter by minimum critic rating.
func (r ApiGetItemsRequest) MinCriticRating(minCriticRating float64) ApiGetItemsRequest {
	r.minCriticRating = &minCriticRating
	return r
}

// Optional. The minimum premiere date. Format &#x3D; ISO.
func (r ApiGetItemsRequest) MinPremiereDate(minPremiereDate time.Time) ApiGetItemsRequest {
	r.minPremiereDate = &minPremiereDate
	return r
}

// Optional. The minimum last saved date. Format &#x3D; ISO.
func (r ApiGetItemsRequest) MinDateLastSaved(minDateLastSaved time.Time) ApiGetItemsRequest {
	r.minDateLastSaved = &minDateLastSaved
	return r
}

// Optional. The minimum last saved date for the current user. Format &#x3D; ISO.
func (r ApiGetItemsRequest) MinDateLastSavedForUser(minDateLastSavedForUser time.Time) ApiGetItemsRequest {
	r.minDateLastSavedForUser = &minDateLastSavedForUser
	return r
}

// Optional. The maximum premiere date. Format &#x3D; ISO.
func (r ApiGetItemsRequest) MaxPremiereDate(maxPremiereDate time.Time) ApiGetItemsRequest {
	r.maxPremiereDate = &maxPremiereDate
	return r
}

// Optional filter by items that have an overview or not.
func (r ApiGetItemsRequest) HasOverview(hasOverview bool) ApiGetItemsRequest {
	r.hasOverview = &hasOverview
	return r
}

// Optional filter by items that have an IMDb id or not.
func (r ApiGetItemsRequest) HasImdbId(hasImdbId bool) ApiGetItemsRequest {
	r.hasImdbId = &hasImdbId
	return r
}

// Optional filter by items that have a TMDb id or not.
func (r ApiGetItemsRequest) HasTmdbId(hasTmdbId bool) ApiGetItemsRequest {
	r.hasTmdbId = &hasTmdbId
	return r
}

// Optional filter by items that have a TVDb id or not.
func (r ApiGetItemsRequest) HasTvdbId(hasTvdbId bool) ApiGetItemsRequest {
	r.hasTvdbId = &hasTvdbId
	return r
}

// Optional filter for live tv movies.
func (r ApiGetItemsRequest) IsMovie(isMovie bool) ApiGetItemsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional filter for live tv series.
func (r ApiGetItemsRequest) IsSeries(isSeries bool) ApiGetItemsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional filter for live tv news.
func (r ApiGetItemsRequest) IsNews(isNews bool) ApiGetItemsRequest {
	r.isNews = &isNews
	return r
}

// Optional filter for live tv kids.
func (r ApiGetItemsRequest) IsKids(isKids bool) ApiGetItemsRequest {
	r.isKids = &isKids
	return r
}

// Optional filter for live tv sports.
func (r ApiGetItemsRequest) IsSports(isSports bool) ApiGetItemsRequest {
	r.isSports = &isSports
	return r
}

// Optional. If specified, results will be filtered by excluding item ids. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) ExcludeItemIds(excludeItemIds []string) ApiGetItemsRequest {
	r.excludeItemIds = &excludeItemIds
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetItemsRequest) StartIndex(startIndex int32) ApiGetItemsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return.
func (r ApiGetItemsRequest) Limit(limit int32) ApiGetItemsRequest {
	r.limit = &limit
	return r
}

// When searching within folders, this determines whether or not the search will be recursive. true/false.
func (r ApiGetItemsRequest) Recursive(recursive bool) ApiGetItemsRequest {
	r.recursive = &recursive
	return r
}

// Optional. Filter based on a search term.
func (r ApiGetItemsRequest) SearchTerm(searchTerm string) ApiGetItemsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Sort Order - Ascending, Descending.
func (r ApiGetItemsRequest) SortOrder(sortOrder []SortOrder) ApiGetItemsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root.
func (r ApiGetItemsRequest) ParentId(parentId string) ApiGetItemsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
func (r ApiGetItemsRequest) Fields(fields []ItemFields) ApiGetItemsRequest {
	r.fields = &fields
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) ExcludeItemTypes(excludeItemTypes []BaseItemKind) ApiGetItemsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) IncludeItemTypes(includeItemTypes []BaseItemKind) ApiGetItemsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. Specify additional filters to apply. This allows multiple, comma delimited. Options: IsFolder, IsNotFolder, IsUnplayed, IsPlayed, IsFavorite, IsResumable, Likes, Dislikes.
func (r ApiGetItemsRequest) Filters(filters []ItemFilter) ApiGetItemsRequest {
	r.filters = &filters
	return r
}

// Optional filter by items that are marked as favorite, or not.
func (r ApiGetItemsRequest) IsFavorite(isFavorite bool) ApiGetItemsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetItemsRequest) MediaTypes(mediaTypes []MediaType) ApiGetItemsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. If specified, results will be filtered based on those containing image types. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) ImageTypes(imageTypes []ImageType) ApiGetItemsRequest {
	r.imageTypes = &imageTypes
	return r
}

// Optional. Specify one or more sort orders, comma delimited. Options: Album, AlbumArtist, Artist, Budget, CommunityRating, CriticRating, DateCreated, DatePlayed, PlayCount, PremiereDate, ProductionYear, SortName, Random, Revenue, Runtime.
func (r ApiGetItemsRequest) SortBy(sortBy []ItemSortBy) ApiGetItemsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional filter by items that are played, or not.
func (r ApiGetItemsRequest) IsPlayed(isPlayed bool) ApiGetItemsRequest {
	r.isPlayed = &isPlayed
	return r
}

// Optional. If specified, results will be filtered based on genre. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) Genres(genres []string) ApiGetItemsRequest {
	r.genres = &genres
	return r
}

// Optional. If specified, results will be filtered based on OfficialRating. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) OfficialRatings(officialRatings []string) ApiGetItemsRequest {
	r.officialRatings = &officialRatings
	return r
}

// Optional. If specified, results will be filtered based on tag. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) Tags(tags []string) ApiGetItemsRequest {
	r.tags = &tags
	return r
}

// Optional. If specified, results will be filtered based on production year. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) Years(years []int32) ApiGetItemsRequest {
	r.years = &years
	return r
}

// Optional, include user data.
func (r ApiGetItemsRequest) EnableUserData(enableUserData bool) ApiGetItemsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional, the max number of images to return, per image type.
func (r ApiGetItemsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetItemsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetItemsRequest) EnableImageTypes(enableImageTypes []ImageType) ApiGetItemsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person.
func (r ApiGetItemsRequest) Person(person string) ApiGetItemsRequest {
	r.person = &person
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified person id.
func (r ApiGetItemsRequest) PersonIds(personIds []string) ApiGetItemsRequest {
	r.personIds = &personIds
	return r
}

// Optional. If specified, along with Person, results will be filtered to include only those containing the specified person and PersonType. Allows multiple, comma-delimited.
func (r ApiGetItemsRequest) PersonTypes(personTypes []string) ApiGetItemsRequest {
	r.personTypes = &personTypes
	return r
}

// Optional. If specified, results will be filtered based on studio. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) Studios(studios []string) ApiGetItemsRequest {
	r.studios = &studios
	return r
}

// Optional. If specified, results will be filtered based on artists. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) Artists(artists []string) ApiGetItemsRequest {
	r.artists = &artists
	return r
}

// Optional. If specified, results will be filtered based on artist id. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) ExcludeArtistIds(excludeArtistIds []string) ApiGetItemsRequest {
	r.excludeArtistIds = &excludeArtistIds
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified artist id.
func (r ApiGetItemsRequest) ArtistIds(artistIds []string) ApiGetItemsRequest {
	r.artistIds = &artistIds
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified album artist id.
func (r ApiGetItemsRequest) AlbumArtistIds(albumArtistIds []string) ApiGetItemsRequest {
	r.albumArtistIds = &albumArtistIds
	return r
}

// Optional. If specified, results will be filtered to include only those containing the specified contributing artist id.
func (r ApiGetItemsRequest) ContributingArtistIds(contributingArtistIds []string) ApiGetItemsRequest {
	r.contributingArtistIds = &contributingArtistIds
	return r
}

// Optional. If specified, results will be filtered based on album. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) Albums(albums []string) ApiGetItemsRequest {
	r.albums = &albums
	return r
}

// Optional. If specified, results will be filtered based on album id. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) AlbumIds(albumIds []string) ApiGetItemsRequest {
	r.albumIds = &albumIds
	return r
}

// Optional. If specific items are needed, specify a list of item id&#39;s to retrieve. This allows multiple, comma delimited.
func (r ApiGetItemsRequest) Ids(ids []string) ApiGetItemsRequest {
	r.ids = &ids
	return r
}

// Optional filter by VideoType (videofile, dvd, bluray, iso). Allows multiple, comma delimited.
func (r ApiGetItemsRequest) VideoTypes(videoTypes []VideoType) ApiGetItemsRequest {
	r.videoTypes = &videoTypes
	return r
}

// Optional filter by minimum official rating (PG, PG-13, TV-MA, etc).
func (r ApiGetItemsRequest) MinOfficialRating(minOfficialRating string) ApiGetItemsRequest {
	r.minOfficialRating = &minOfficialRating
	return r
}

// Optional filter by items that are locked.
func (r ApiGetItemsRequest) IsLocked(isLocked bool) ApiGetItemsRequest {
	r.isLocked = &isLocked
	return r
}

// Optional filter by items that are placeholders.
func (r ApiGetItemsRequest) IsPlaceHolder(isPlaceHolder bool) ApiGetItemsRequest {
	r.isPlaceHolder = &isPlaceHolder
	return r
}

// Optional filter by items that have official ratings.
func (r ApiGetItemsRequest) HasOfficialRating(hasOfficialRating bool) ApiGetItemsRequest {
	r.hasOfficialRating = &hasOfficialRating
	return r
}

// Whether or not to hide items behind their boxsets.
func (r ApiGetItemsRequest) CollapseBoxSetItems(collapseBoxSetItems bool) ApiGetItemsRequest {
	r.collapseBoxSetItems = &collapseBoxSetItems
	return r
}

// Optional. Filter by the minimum width of the item.
func (r ApiGetItemsRequest) MinWidth(minWidth int32) ApiGetItemsRequest {
	r.minWidth = &minWidth
	return r
}

// Optional. Filter by the minimum height of the item.
func (r ApiGetItemsRequest) MinHeight(minHeight int32) ApiGetItemsRequest {
	r.minHeight = &minHeight
	return r
}

// Optional. Filter by the maximum width of the item.
func (r ApiGetItemsRequest) MaxWidth(maxWidth int32) ApiGetItemsRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. Filter by the maximum height of the item.
func (r ApiGetItemsRequest) MaxHeight(maxHeight int32) ApiGetItemsRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional filter by items that are 3D, or not.
func (r ApiGetItemsRequest) Is3D(is3D bool) ApiGetItemsRequest {
	r.is3D = &is3D
	return r
}

// Optional filter by Series Status. Allows multiple, comma delimited.
func (r ApiGetItemsRequest) SeriesStatus(seriesStatus []SeriesStatus) ApiGetItemsRequest {
	r.seriesStatus = &seriesStatus
	return r
}

// Optional filter by items whose name is sorted equally or greater than a given input string.
func (r ApiGetItemsRequest) NameStartsWithOrGreater(nameStartsWithOrGreater string) ApiGetItemsRequest {
	r.nameStartsWithOrGreater = &nameStartsWithOrGreater
	return r
}

// Optional filter by items whose name is sorted equally than a given input string.
func (r ApiGetItemsRequest) NameStartsWith(nameStartsWith string) ApiGetItemsRequest {
	r.nameStartsWith = &nameStartsWith
	return r
}

// Optional filter by items whose name is equally or lesser than a given input string.
func (r ApiGetItemsRequest) NameLessThan(nameLessThan string) ApiGetItemsRequest {
	r.nameLessThan = &nameLessThan
	return r
}

// Optional. If specified, results will be filtered based on studio id. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) StudioIds(studioIds []string) ApiGetItemsRequest {
	r.studioIds = &studioIds
	return r
}

// Optional. If specified, results will be filtered based on genre id. This allows multiple, pipe delimited.
func (r ApiGetItemsRequest) GenreIds(genreIds []string) ApiGetItemsRequest {
	r.genreIds = &genreIds
	return r
}

// Optional. Enable the total record count.
func (r ApiGetItemsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) ApiGetItemsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

// Optional, include image information in output.
func (r ApiGetItemsRequest) EnableImages(enableImages bool) ApiGetItemsRequest {
	r.enableImages = &enableImages
	return r
}

func (r ApiGetItemsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetItemsExecute(r)
}

/*
GetItems Gets items based on a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetItemsRequest
*/
func (a *ItemsAPIService) GetItems(ctx context.Context) ApiGetItemsRequest {
	return ApiGetItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *ItemsAPIService) GetItemsExecute(r ApiGetItemsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsAPIService.GetItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.maxOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxOfficialRating", r.maxOfficialRating, "")
	}
	if r.hasThemeSong != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasThemeSong", r.hasThemeSong, "")
	}
	if r.hasThemeVideo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasThemeVideo", r.hasThemeVideo, "")
	}
	if r.hasSubtitles != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasSubtitles", r.hasSubtitles, "")
	}
	if r.hasSpecialFeature != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasSpecialFeature", r.hasSpecialFeature, "")
	}
	if r.hasTrailer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasTrailer", r.hasTrailer, "")
	}
	if r.adjacentTo != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "adjacentTo", r.adjacentTo, "")
	}
	if r.parentIndexNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentIndexNumber", r.parentIndexNumber, "")
	}
	if r.hasParentalRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasParentalRating", r.hasParentalRating, "")
	}
	if r.isHd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isHd", r.isHd, "")
	}
	if r.is4K != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is4K", r.is4K, "")
	}
	if r.locationTypes != nil {
		t := *r.locationTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "locationTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "locationTypes", t, "multi")
		}
	}
	if r.excludeLocationTypes != nil {
		t := *r.excludeLocationTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeLocationTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeLocationTypes", t, "multi")
		}
	}
	if r.isMissing != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMissing", r.isMissing, "")
	}
	if r.isUnaired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isUnaired", r.isUnaired, "")
	}
	if r.minCommunityRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minCommunityRating", r.minCommunityRating, "")
	}
	if r.minCriticRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minCriticRating", r.minCriticRating, "")
	}
	if r.minPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minPremiereDate", r.minPremiereDate, "")
	}
	if r.minDateLastSaved != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minDateLastSaved", r.minDateLastSaved, "")
	}
	if r.minDateLastSavedForUser != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minDateLastSavedForUser", r.minDateLastSavedForUser, "")
	}
	if r.maxPremiereDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxPremiereDate", r.maxPremiereDate, "")
	}
	if r.hasOverview != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOverview", r.hasOverview, "")
	}
	if r.hasImdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasImdbId", r.hasImdbId, "")
	}
	if r.hasTmdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasTmdbId", r.hasTmdbId, "")
	}
	if r.hasTvdbId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasTvdbId", r.hasTvdbId, "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "")
	}
	if r.excludeItemIds != nil {
		t := *r.excludeItemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeItemIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeItemIds", t, "multi")
		}
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.recursive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "recursive", r.recursive, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTerm", r.searchTerm, "")
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "multi")
		}
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.excludeItemTypes != nil {
		t := *r.excludeItemTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeItemTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeItemTypes", t, "multi")
		}
	}
	if r.includeItemTypes != nil {
		t := *r.includeItemTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeItemTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeItemTypes", t, "multi")
		}
	}
	if r.filters != nil {
		t := *r.filters
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "filters", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "filters", t, "multi")
		}
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isFavorite", r.isFavorite, "")
	}
	if r.mediaTypes != nil {
		t := *r.mediaTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mediaTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mediaTypes", t, "multi")
		}
	}
	if r.imageTypes != nil {
		t := *r.imageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypes", t, "multi")
		}
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "multi")
		}
	}
	if r.isPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPlayed", r.isPlayed, "")
	}
	if r.genres != nil {
		t := *r.genres
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genres", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genres", t, "multi")
		}
	}
	if r.officialRatings != nil {
		t := *r.officialRatings
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "officialRatings", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "officialRatings", t, "multi")
		}
	}
	if r.tags != nil {
		t := *r.tags
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "tags", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "tags", t, "multi")
		}
	}
	if r.years != nil {
		t := *r.years
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "years", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "years", t, "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "multi")
		}
	}
	if r.person != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "person", r.person, "")
	}
	if r.personIds != nil {
		t := *r.personIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "personIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "personIds", t, "multi")
		}
	}
	if r.personTypes != nil {
		t := *r.personTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "personTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "personTypes", t, "multi")
		}
	}
	if r.studios != nil {
		t := *r.studios
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "studios", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "studios", t, "multi")
		}
	}
	if r.artists != nil {
		t := *r.artists
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "artists", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "artists", t, "multi")
		}
	}
	if r.excludeArtistIds != nil {
		t := *r.excludeArtistIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeArtistIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeArtistIds", t, "multi")
		}
	}
	if r.artistIds != nil {
		t := *r.artistIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "artistIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "artistIds", t, "multi")
		}
	}
	if r.albumArtistIds != nil {
		t := *r.albumArtistIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "albumArtistIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "albumArtistIds", t, "multi")
		}
	}
	if r.contributingArtistIds != nil {
		t := *r.contributingArtistIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "contributingArtistIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "contributingArtistIds", t, "multi")
		}
	}
	if r.albums != nil {
		t := *r.albums
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "albums", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "albums", t, "multi")
		}
	}
	if r.albumIds != nil {
		t := *r.albumIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "albumIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "albumIds", t, "multi")
		}
	}
	if r.ids != nil {
		t := *r.ids
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "ids", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "ids", t, "multi")
		}
	}
	if r.videoTypes != nil {
		t := *r.videoTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "videoTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "videoTypes", t, "multi")
		}
	}
	if r.minOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minOfficialRating", r.minOfficialRating, "")
	}
	if r.isLocked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLocked", r.isLocked, "")
	}
	if r.isPlaceHolder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isPlaceHolder", r.isPlaceHolder, "")
	}
	if r.hasOfficialRating != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasOfficialRating", r.hasOfficialRating, "")
	}
	if r.collapseBoxSetItems != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "collapseBoxSetItems", r.collapseBoxSetItems, "")
	}
	if r.minWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minWidth", r.minWidth, "")
	}
	if r.minHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minHeight", r.minHeight, "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "")
	}
	if r.is3D != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is3D", r.is3D, "")
	}
	if r.seriesStatus != nil {
		t := *r.seriesStatus
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "seriesStatus", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "seriesStatus", t, "multi")
		}
	}
	if r.nameStartsWithOrGreater != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWithOrGreater", r.nameStartsWithOrGreater, "")
	}
	if r.nameStartsWith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameStartsWith", r.nameStartsWith, "")
	}
	if r.nameLessThan != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "nameLessThan", r.nameLessThan, "")
	}
	if r.studioIds != nil {
		t := *r.studioIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "studioIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "studioIds", t, "multi")
		}
	}
	if r.genreIds != nil {
		t := *r.genreIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", t, "multi")
		}
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "")
	} else {
		var defaultValue bool = true
		r.enableImages = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetResumeItemsRequest struct {
	ctx context.Context
	ApiService ItemsAPI
	userId *string
	startIndex *int32
	limit *int32
	searchTerm *string
	parentId *string
	fields *[]ItemFields
	mediaTypes *[]MediaType
	enableUserData *bool
	imageTypeLimit *int32
	enableImageTypes *[]ImageType
	excludeItemTypes *[]BaseItemKind
	includeItemTypes *[]BaseItemKind
	enableTotalRecordCount *bool
	enableImages *bool
	excludeActiveSessions *bool
}

// The user id.
func (r ApiGetResumeItemsRequest) UserId(userId string) ApiGetResumeItemsRequest {
	r.userId = &userId
	return r
}

// The start index.
func (r ApiGetResumeItemsRequest) StartIndex(startIndex int32) ApiGetResumeItemsRequest {
	r.startIndex = &startIndex
	return r
}

// The item limit.
func (r ApiGetResumeItemsRequest) Limit(limit int32) ApiGetResumeItemsRequest {
	r.limit = &limit
	return r
}

// The search term.
func (r ApiGetResumeItemsRequest) SearchTerm(searchTerm string) ApiGetResumeItemsRequest {
	r.searchTerm = &searchTerm
	return r
}

// Specify this to localize the search to a specific item or folder. Omit to use the root.
func (r ApiGetResumeItemsRequest) ParentId(parentId string) ApiGetResumeItemsRequest {
	r.parentId = &parentId
	return r
}

// Optional. Specify additional fields of information to return in the output. This allows multiple, comma delimited. Options: Budget, Chapters, DateCreated, Genres, HomePageUrl, IndexOptions, MediaStreams, Overview, ParentId, Path, People, ProviderIds, PrimaryImageAspectRatio, Revenue, SortName, Studios, Taglines.
func (r ApiGetResumeItemsRequest) Fields(fields []ItemFields) ApiGetResumeItemsRequest {
	r.fields = &fields
	return r
}

// Optional. Filter by MediaType. Allows multiple, comma delimited.
func (r ApiGetResumeItemsRequest) MediaTypes(mediaTypes []MediaType) ApiGetResumeItemsRequest {
	r.mediaTypes = &mediaTypes
	return r
}

// Optional. Include user data.
func (r ApiGetResumeItemsRequest) EnableUserData(enableUserData bool) ApiGetResumeItemsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. The max number of images to return, per image type.
func (r ApiGetResumeItemsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetResumeItemsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetResumeItemsRequest) EnableImageTypes(enableImageTypes []ImageType) ApiGetResumeItemsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. If specified, results will be filtered based on item type. This allows multiple, comma delimited.
func (r ApiGetResumeItemsRequest) ExcludeItemTypes(excludeItemTypes []BaseItemKind) ApiGetResumeItemsRequest {
	r.excludeItemTypes = &excludeItemTypes
	return r
}

// Optional. If specified, results will be filtered based on the item type. This allows multiple, comma delimited.
func (r ApiGetResumeItemsRequest) IncludeItemTypes(includeItemTypes []BaseItemKind) ApiGetResumeItemsRequest {
	r.includeItemTypes = &includeItemTypes
	return r
}

// Optional. Enable the total record count.
func (r ApiGetResumeItemsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) ApiGetResumeItemsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

// Optional. Include image information in output.
func (r ApiGetResumeItemsRequest) EnableImages(enableImages bool) ApiGetResumeItemsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. Whether to exclude the currently active sessions.
func (r ApiGetResumeItemsRequest) ExcludeActiveSessions(excludeActiveSessions bool) ApiGetResumeItemsRequest {
	r.excludeActiveSessions = &excludeActiveSessions
	return r
}

func (r ApiGetResumeItemsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetResumeItemsExecute(r)
}

/*
GetResumeItems Gets items based on a query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetResumeItemsRequest
*/
func (a *ItemsAPIService) GetResumeItems(ctx context.Context) ApiGetResumeItemsRequest {
	return ApiGetResumeItemsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *ItemsAPIService) GetResumeItemsExecute(r ApiGetResumeItemsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsAPIService.GetResumeItems")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserItems/Resume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	}
	if r.searchTerm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "searchTerm", r.searchTerm, "")
	}
	if r.parentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "parentId", r.parentId, "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "multi")
		}
	}
	if r.mediaTypes != nil {
		t := *r.mediaTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "mediaTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "mediaTypes", t, "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "multi")
		}
	}
	if r.excludeItemTypes != nil {
		t := *r.excludeItemTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "excludeItemTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "excludeItemTypes", t, "multi")
		}
	}
	if r.includeItemTypes != nil {
		t := *r.includeItemTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "includeItemTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "includeItemTypes", t, "multi")
		}
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "")
	} else {
		var defaultValue bool = true
		r.enableImages = &defaultValue
	}
	if r.excludeActiveSessions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "excludeActiveSessions", r.excludeActiveSessions, "")
	} else {
		var defaultValue bool = false
		r.excludeActiveSessions = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateItemUserDataRequest struct {
	ctx context.Context
	ApiService ItemsAPI
	itemId string
	updateUserItemDataDto *UpdateUserItemDataDto
	userId *string
}

// New user data object.
func (r ApiUpdateItemUserDataRequest) UpdateUserItemDataDto(updateUserItemDataDto UpdateUserItemDataDto) ApiUpdateItemUserDataRequest {
	r.updateUserItemDataDto = &updateUserItemDataDto
	return r
}

// The user id.
func (r ApiUpdateItemUserDataRequest) UserId(userId string) ApiUpdateItemUserDataRequest {
	r.userId = &userId
	return r
}

func (r ApiUpdateItemUserDataRequest) Execute() (*UserItemDataDto, *http.Response, error) {
	return r.ApiService.UpdateItemUserDataExecute(r)
}

/*
UpdateItemUserData Update Item User Data.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiUpdateItemUserDataRequest
*/
func (a *ItemsAPIService) UpdateItemUserData(ctx context.Context, itemId string) ApiUpdateItemUserDataRequest {
	return ApiUpdateItemUserDataRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return UserItemDataDto
func (a *ItemsAPIService) UpdateItemUserDataExecute(r ApiUpdateItemUserDataRequest) (*UserItemDataDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserItemDataDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemsAPIService.UpdateItemUserData")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserItems/{itemId}/UserData"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.updateUserItemDataDto == nil {
		return localVarReturnValue, nil, reportError("updateUserItemDataDto is required and must be specified")
	}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.updateUserItemDataDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type DynamicHlsAPI interface {

	/*
	GetHlsAudioSegment Gets a video stream using HTTP live streaming.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@param playlistId The playlist id.
	@param segmentId The segment id.
	@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
	@return ApiGetHlsAudioSegmentRequest
	*/
	GetHlsAudioSegment(ctx context.Context, itemId string, playlistId string, segmentId int32, container string) ApiGetHlsAudioSegmentRequest

	// GetHlsAudioSegmentExecute executes the request
	//  @return *os.File
	GetHlsAudioSegmentExecute(r ApiGetHlsAudioSegmentRequest) (*os.File, *http.Response, error)

	/*
	GetHlsVideoSegment Gets a video stream using HTTP live streaming.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@param playlistId The playlist id.
	@param segmentId The segment id.
	@param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
	@return ApiGetHlsVideoSegmentRequest
	*/
	GetHlsVideoSegment(ctx context.Context, itemId string, playlistId string, segmentId int32, container string) ApiGetHlsVideoSegmentRequest

	// GetHlsVideoSegmentExecute executes the request
	//  @return *os.File
	GetHlsVideoSegmentExecute(r ApiGetHlsVideoSegmentRequest) (*os.File, *http.Response, error)

	/*
	GetLiveHlsStream Gets a hls live stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiGetLiveHlsStreamRequest
	*/
	GetLiveHlsStream(ctx context.Context, itemId string) ApiGetLiveHlsStreamRequest

	// GetLiveHlsStreamExecute executes the request
	//  @return *os.File
	GetLiveHlsStreamExecute(r ApiGetLiveHlsStreamRequest) (*os.File, *http.Response, error)

	/*
	GetMasterHlsAudioPlaylist Gets an audio hls playlist stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiGetMasterHlsAudioPlaylistRequest
	*/
	GetMasterHlsAudioPlaylist(ctx context.Context, itemId string) ApiGetMasterHlsAudioPlaylistRequest

	// GetMasterHlsAudioPlaylistExecute executes the request
	//  @return *os.File
	GetMasterHlsAudioPlaylistExecute(r ApiGetMasterHlsAudioPlaylistRequest) (*os.File, *http.Response, error)

	/*
	GetMasterHlsVideoPlaylist Gets a video hls playlist stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiGetMasterHlsVideoPlaylistRequest
	*/
	GetMasterHlsVideoPlaylist(ctx context.Context, itemId string) ApiGetMasterHlsVideoPlaylistRequest

	// GetMasterHlsVideoPlaylistExecute executes the request
	//  @return *os.File
	GetMasterHlsVideoPlaylistExecute(r ApiGetMasterHlsVideoPlaylistRequest) (*os.File, *http.Response, error)

	/*
	GetVariantHlsAudioPlaylist Gets an audio stream using HTTP live streaming.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiGetVariantHlsAudioPlaylistRequest
	*/
	GetVariantHlsAudioPlaylist(ctx context.Context, itemId string) ApiGetVariantHlsAudioPlaylistRequest

	// GetVariantHlsAudioPlaylistExecute executes the request
	//  @return *os.File
	GetVariantHlsAudioPlaylistExecute(r ApiGetVariantHlsAudioPlaylistRequest) (*os.File, *http.Response, error)

	/*
	GetVariantHlsVideoPlaylist Gets a video stream using HTTP live streaming.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiGetVariantHlsVideoPlaylistRequest
	*/
	GetVariantHlsVideoPlaylist(ctx context.Context, itemId string) ApiGetVariantHlsVideoPlaylistRequest

	// GetVariantHlsVideoPlaylistExecute executes the request
	//  @return *os.File
	GetVariantHlsVideoPlaylistExecute(r ApiGetVariantHlsVideoPlaylistRequest) (*os.File, *http.Response, error)

	/*
	HeadMasterHlsAudioPlaylist Gets an audio hls playlist stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiHeadMasterHlsAudioPlaylistRequest
	*/
	HeadMasterHlsAudioPlaylist(ctx context.Context, itemId string) ApiHeadMasterHlsAudioPlaylistRequest

	// HeadMasterHlsAudioPlaylistExecute executes the request
	//  @return *os.File
	HeadMasterHlsAudioPlaylistExecute(r ApiHeadMasterHlsAudioPlaylistRequest) (*os.File, *http.Response, error)

	/*
	HeadMasterHlsVideoPlaylist Gets a video hls playlist stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId The item id.
	@return ApiHeadMasterHlsVideoPlaylistRequest
	*/
	HeadMasterHlsVideoPlaylist(ctx context.Context, itemId string) ApiHeadMasterHlsVideoPlaylistRequest

	// HeadMasterHlsVideoPlaylistExecute executes the request
	//  @return *os.File
	HeadMasterHlsVideoPlaylistExecute(r ApiHeadMasterHlsVideoPlaylistRequest) (*os.File, *http.Response, error)
}

// DynamicHlsAPIService DynamicHlsAPI service
type DynamicHlsAPIService service

type ApiGetHlsAudioSegmentRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	playlistId string
	segmentId int32
	container string
	runtimeTicks *int64
	actualSegmentLengthTicks *int64
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
}

// The position of the requested segment in ticks.
func (r ApiGetHlsAudioSegmentRequest) RuntimeTicks(runtimeTicks int64) ApiGetHlsAudioSegmentRequest {
	r.runtimeTicks = &runtimeTicks
	return r
}

// The length of the requested segment in ticks.
func (r ApiGetHlsAudioSegmentRequest) ActualSegmentLengthTicks(actualSegmentLengthTicks int64) ApiGetHlsAudioSegmentRequest {
	r.actualSegmentLengthTicks = &actualSegmentLengthTicks
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiGetHlsAudioSegmentRequest) Static(static bool) ApiGetHlsAudioSegmentRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiGetHlsAudioSegmentRequest) Params(params string) ApiGetHlsAudioSegmentRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiGetHlsAudioSegmentRequest) Tag(tag string) ApiGetHlsAudioSegmentRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiGetHlsAudioSegmentRequest) DeviceProfileId(deviceProfileId string) ApiGetHlsAudioSegmentRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiGetHlsAudioSegmentRequest) PlaySessionId(playSessionId string) ApiGetHlsAudioSegmentRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiGetHlsAudioSegmentRequest) SegmentContainer(segmentContainer string) ApiGetHlsAudioSegmentRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiGetHlsAudioSegmentRequest) SegmentLength(segmentLength int32) ApiGetHlsAudioSegmentRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiGetHlsAudioSegmentRequest) MinSegments(minSegments int32) ApiGetHlsAudioSegmentRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r ApiGetHlsAudioSegmentRequest) MediaSourceId(mediaSourceId string) ApiGetHlsAudioSegmentRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiGetHlsAudioSegmentRequest) DeviceId(deviceId string) ApiGetHlsAudioSegmentRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiGetHlsAudioSegmentRequest) AudioCodec(audioCodec string) ApiGetHlsAudioSegmentRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiGetHlsAudioSegmentRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiGetHlsAudioSegmentRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiGetHlsAudioSegmentRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiGetHlsAudioSegmentRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiGetHlsAudioSegmentRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiGetHlsAudioSegmentRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiGetHlsAudioSegmentRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiGetHlsAudioSegmentRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiGetHlsAudioSegmentRequest) AudioSampleRate(audioSampleRate int32) ApiGetHlsAudioSegmentRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiGetHlsAudioSegmentRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiGetHlsAudioSegmentRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r ApiGetHlsAudioSegmentRequest) MaxStreamingBitrate(maxStreamingBitrate int32) ApiGetHlsAudioSegmentRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiGetHlsAudioSegmentRequest) AudioBitRate(audioBitRate int32) ApiGetHlsAudioSegmentRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiGetHlsAudioSegmentRequest) AudioChannels(audioChannels int32) ApiGetHlsAudioSegmentRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiGetHlsAudioSegmentRequest) MaxAudioChannels(maxAudioChannels int32) ApiGetHlsAudioSegmentRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiGetHlsAudioSegmentRequest) Profile(profile string) ApiGetHlsAudioSegmentRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiGetHlsAudioSegmentRequest) Level(level string) ApiGetHlsAudioSegmentRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetHlsAudioSegmentRequest) Framerate(framerate float32) ApiGetHlsAudioSegmentRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetHlsAudioSegmentRequest) MaxFramerate(maxFramerate float32) ApiGetHlsAudioSegmentRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiGetHlsAudioSegmentRequest) CopyTimestamps(copyTimestamps bool) ApiGetHlsAudioSegmentRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiGetHlsAudioSegmentRequest) StartTimeTicks(startTimeTicks int64) ApiGetHlsAudioSegmentRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiGetHlsAudioSegmentRequest) Width(width int32) ApiGetHlsAudioSegmentRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiGetHlsAudioSegmentRequest) Height(height int32) ApiGetHlsAudioSegmentRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiGetHlsAudioSegmentRequest) VideoBitRate(videoBitRate int32) ApiGetHlsAudioSegmentRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiGetHlsAudioSegmentRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiGetHlsAudioSegmentRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiGetHlsAudioSegmentRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiGetHlsAudioSegmentRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiGetHlsAudioSegmentRequest) MaxRefFrames(maxRefFrames int32) ApiGetHlsAudioSegmentRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiGetHlsAudioSegmentRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiGetHlsAudioSegmentRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiGetHlsAudioSegmentRequest) RequireAvc(requireAvc bool) ApiGetHlsAudioSegmentRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiGetHlsAudioSegmentRequest) DeInterlace(deInterlace bool) ApiGetHlsAudioSegmentRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiGetHlsAudioSegmentRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiGetHlsAudioSegmentRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiGetHlsAudioSegmentRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiGetHlsAudioSegmentRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiGetHlsAudioSegmentRequest) CpuCoreLimit(cpuCoreLimit int32) ApiGetHlsAudioSegmentRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiGetHlsAudioSegmentRequest) LiveStreamId(liveStreamId string) ApiGetHlsAudioSegmentRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiGetHlsAudioSegmentRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiGetHlsAudioSegmentRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiGetHlsAudioSegmentRequest) VideoCodec(videoCodec string) ApiGetHlsAudioSegmentRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiGetHlsAudioSegmentRequest) SubtitleCodec(subtitleCodec string) ApiGetHlsAudioSegmentRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiGetHlsAudioSegmentRequest) TranscodeReasons(transcodeReasons string) ApiGetHlsAudioSegmentRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiGetHlsAudioSegmentRequest) AudioStreamIndex(audioStreamIndex int32) ApiGetHlsAudioSegmentRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiGetHlsAudioSegmentRequest) VideoStreamIndex(videoStreamIndex int32) ApiGetHlsAudioSegmentRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiGetHlsAudioSegmentRequest) Context(context EncodingContext) ApiGetHlsAudioSegmentRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiGetHlsAudioSegmentRequest) StreamOptions(streamOptions map[string]string) ApiGetHlsAudioSegmentRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r ApiGetHlsAudioSegmentRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiGetHlsAudioSegmentRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r ApiGetHlsAudioSegmentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetHlsAudioSegmentExecute(r)
}

/*
GetHlsAudioSegment Gets a video stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @param playlistId The playlist id.
 @param segmentId The segment id.
 @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
 @return ApiGetHlsAudioSegmentRequest
*/
func (a *DynamicHlsAPIService) GetHlsAudioSegment(ctx context.Context, itemId string, playlistId string, segmentId int32, container string) ApiGetHlsAudioSegmentRequest {
	return ApiGetHlsAudioSegmentRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		playlistId: playlistId,
		segmentId: segmentId,
		container: container,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetHlsAudioSegmentExecute(r ApiGetHlsAudioSegmentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetHlsAudioSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/hls1/{playlistId}/{segmentId}.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playlistId"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentId"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.runtimeTicks == nil {
		return localVarReturnValue, nil, reportError("runtimeTicks is required and must be specified")
	}
	if r.actualSegmentLengthTicks == nil {
		return localVarReturnValue, nil, reportError("actualSegmentLengthTicks is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "runtimeTicks", r.runtimeTicks, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "actualSegmentLengthTicks", r.actualSegmentLengthTicks, "form", "")
	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"audio/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetHlsVideoSegmentRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	playlistId string
	segmentId int32
	container string
	runtimeTicks *int64
	actualSegmentLengthTicks *int64
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The position of the requested segment in ticks.
func (r ApiGetHlsVideoSegmentRequest) RuntimeTicks(runtimeTicks int64) ApiGetHlsVideoSegmentRequest {
	r.runtimeTicks = &runtimeTicks
	return r
}

// The length of the requested segment in ticks.
func (r ApiGetHlsVideoSegmentRequest) ActualSegmentLengthTicks(actualSegmentLengthTicks int64) ApiGetHlsVideoSegmentRequest {
	r.actualSegmentLengthTicks = &actualSegmentLengthTicks
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiGetHlsVideoSegmentRequest) Static(static bool) ApiGetHlsVideoSegmentRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiGetHlsVideoSegmentRequest) Params(params string) ApiGetHlsVideoSegmentRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiGetHlsVideoSegmentRequest) Tag(tag string) ApiGetHlsVideoSegmentRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiGetHlsVideoSegmentRequest) DeviceProfileId(deviceProfileId string) ApiGetHlsVideoSegmentRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiGetHlsVideoSegmentRequest) PlaySessionId(playSessionId string) ApiGetHlsVideoSegmentRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiGetHlsVideoSegmentRequest) SegmentContainer(segmentContainer string) ApiGetHlsVideoSegmentRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The desired segment length.
func (r ApiGetHlsVideoSegmentRequest) SegmentLength(segmentLength int32) ApiGetHlsVideoSegmentRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiGetHlsVideoSegmentRequest) MinSegments(minSegments int32) ApiGetHlsVideoSegmentRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r ApiGetHlsVideoSegmentRequest) MediaSourceId(mediaSourceId string) ApiGetHlsVideoSegmentRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiGetHlsVideoSegmentRequest) DeviceId(deviceId string) ApiGetHlsVideoSegmentRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiGetHlsVideoSegmentRequest) AudioCodec(audioCodec string) ApiGetHlsVideoSegmentRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiGetHlsVideoSegmentRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiGetHlsVideoSegmentRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiGetHlsVideoSegmentRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiGetHlsVideoSegmentRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiGetHlsVideoSegmentRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiGetHlsVideoSegmentRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiGetHlsVideoSegmentRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiGetHlsVideoSegmentRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiGetHlsVideoSegmentRequest) AudioSampleRate(audioSampleRate int32) ApiGetHlsVideoSegmentRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiGetHlsVideoSegmentRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiGetHlsVideoSegmentRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiGetHlsVideoSegmentRequest) AudioBitRate(audioBitRate int32) ApiGetHlsVideoSegmentRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiGetHlsVideoSegmentRequest) AudioChannels(audioChannels int32) ApiGetHlsVideoSegmentRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiGetHlsVideoSegmentRequest) MaxAudioChannels(maxAudioChannels int32) ApiGetHlsVideoSegmentRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiGetHlsVideoSegmentRequest) Profile(profile string) ApiGetHlsVideoSegmentRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiGetHlsVideoSegmentRequest) Level(level string) ApiGetHlsVideoSegmentRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetHlsVideoSegmentRequest) Framerate(framerate float32) ApiGetHlsVideoSegmentRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetHlsVideoSegmentRequest) MaxFramerate(maxFramerate float32) ApiGetHlsVideoSegmentRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiGetHlsVideoSegmentRequest) CopyTimestamps(copyTimestamps bool) ApiGetHlsVideoSegmentRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiGetHlsVideoSegmentRequest) StartTimeTicks(startTimeTicks int64) ApiGetHlsVideoSegmentRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiGetHlsVideoSegmentRequest) Width(width int32) ApiGetHlsVideoSegmentRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiGetHlsVideoSegmentRequest) Height(height int32) ApiGetHlsVideoSegmentRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r ApiGetHlsVideoSegmentRequest) MaxWidth(maxWidth int32) ApiGetHlsVideoSegmentRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r ApiGetHlsVideoSegmentRequest) MaxHeight(maxHeight int32) ApiGetHlsVideoSegmentRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiGetHlsVideoSegmentRequest) VideoBitRate(videoBitRate int32) ApiGetHlsVideoSegmentRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiGetHlsVideoSegmentRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiGetHlsVideoSegmentRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiGetHlsVideoSegmentRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiGetHlsVideoSegmentRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiGetHlsVideoSegmentRequest) MaxRefFrames(maxRefFrames int32) ApiGetHlsVideoSegmentRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiGetHlsVideoSegmentRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiGetHlsVideoSegmentRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiGetHlsVideoSegmentRequest) RequireAvc(requireAvc bool) ApiGetHlsVideoSegmentRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiGetHlsVideoSegmentRequest) DeInterlace(deInterlace bool) ApiGetHlsVideoSegmentRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiGetHlsVideoSegmentRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiGetHlsVideoSegmentRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiGetHlsVideoSegmentRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiGetHlsVideoSegmentRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiGetHlsVideoSegmentRequest) CpuCoreLimit(cpuCoreLimit int32) ApiGetHlsVideoSegmentRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiGetHlsVideoSegmentRequest) LiveStreamId(liveStreamId string) ApiGetHlsVideoSegmentRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiGetHlsVideoSegmentRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiGetHlsVideoSegmentRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiGetHlsVideoSegmentRequest) VideoCodec(videoCodec string) ApiGetHlsVideoSegmentRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiGetHlsVideoSegmentRequest) SubtitleCodec(subtitleCodec string) ApiGetHlsVideoSegmentRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiGetHlsVideoSegmentRequest) TranscodeReasons(transcodeReasons string) ApiGetHlsVideoSegmentRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiGetHlsVideoSegmentRequest) AudioStreamIndex(audioStreamIndex int32) ApiGetHlsVideoSegmentRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiGetHlsVideoSegmentRequest) VideoStreamIndex(videoStreamIndex int32) ApiGetHlsVideoSegmentRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiGetHlsVideoSegmentRequest) Context(context EncodingContext) ApiGetHlsVideoSegmentRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiGetHlsVideoSegmentRequest) StreamOptions(streamOptions map[string]string) ApiGetHlsVideoSegmentRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r ApiGetHlsVideoSegmentRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiGetHlsVideoSegmentRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r ApiGetHlsVideoSegmentRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) ApiGetHlsVideoSegmentRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r ApiGetHlsVideoSegmentRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetHlsVideoSegmentExecute(r)
}

/*
GetHlsVideoSegment Gets a video stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @param playlistId The playlist id.
 @param segmentId The segment id.
 @param container The video container. Possible values are: ts, webm, asf, wmv, ogv, mp4, m4v, mkv, mpeg, mpg, avi, 3gp, wmv, wtv, m2ts, mov, iso, flv.
 @return ApiGetHlsVideoSegmentRequest
*/
func (a *DynamicHlsAPIService) GetHlsVideoSegment(ctx context.Context, itemId string, playlistId string, segmentId int32, container string) ApiGetHlsVideoSegmentRequest {
	return ApiGetHlsVideoSegmentRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		playlistId: playlistId,
		segmentId: segmentId,
		container: container,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetHlsVideoSegmentExecute(r ApiGetHlsVideoSegmentRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetHlsVideoSegment")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/hls1/{playlistId}/{segmentId}.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"playlistId"+"}", url.PathEscape(parameterValueToString(r.playlistId, "playlistId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"segmentId"+"}", url.PathEscape(parameterValueToString(r.segmentId, "segmentId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.runtimeTicks == nil {
		return localVarReturnValue, nil, reportError("runtimeTicks is required and must be specified")
	}
	if r.actualSegmentLengthTicks == nil {
		return localVarReturnValue, nil, reportError("actualSegmentLengthTicks is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "runtimeTicks", r.runtimeTicks, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "actualSegmentLengthTicks", r.actualSegmentLengthTicks, "form", "")
	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"video/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveHlsStreamRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	container *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	maxWidth *int32
	maxHeight *int32
	enableSubtitlesInManifest *bool
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The audio container.
func (r ApiGetLiveHlsStreamRequest) Container(container string) ApiGetLiveHlsStreamRequest {
	r.container = &container
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiGetLiveHlsStreamRequest) Static(static bool) ApiGetLiveHlsStreamRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiGetLiveHlsStreamRequest) Params(params string) ApiGetLiveHlsStreamRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiGetLiveHlsStreamRequest) Tag(tag string) ApiGetLiveHlsStreamRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiGetLiveHlsStreamRequest) DeviceProfileId(deviceProfileId string) ApiGetLiveHlsStreamRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiGetLiveHlsStreamRequest) PlaySessionId(playSessionId string) ApiGetLiveHlsStreamRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiGetLiveHlsStreamRequest) SegmentContainer(segmentContainer string) ApiGetLiveHlsStreamRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiGetLiveHlsStreamRequest) SegmentLength(segmentLength int32) ApiGetLiveHlsStreamRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiGetLiveHlsStreamRequest) MinSegments(minSegments int32) ApiGetLiveHlsStreamRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r ApiGetLiveHlsStreamRequest) MediaSourceId(mediaSourceId string) ApiGetLiveHlsStreamRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiGetLiveHlsStreamRequest) DeviceId(deviceId string) ApiGetLiveHlsStreamRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiGetLiveHlsStreamRequest) AudioCodec(audioCodec string) ApiGetLiveHlsStreamRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiGetLiveHlsStreamRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiGetLiveHlsStreamRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiGetLiveHlsStreamRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiGetLiveHlsStreamRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiGetLiveHlsStreamRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiGetLiveHlsStreamRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiGetLiveHlsStreamRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiGetLiveHlsStreamRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiGetLiveHlsStreamRequest) AudioSampleRate(audioSampleRate int32) ApiGetLiveHlsStreamRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiGetLiveHlsStreamRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiGetLiveHlsStreamRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiGetLiveHlsStreamRequest) AudioBitRate(audioBitRate int32) ApiGetLiveHlsStreamRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiGetLiveHlsStreamRequest) AudioChannels(audioChannels int32) ApiGetLiveHlsStreamRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiGetLiveHlsStreamRequest) MaxAudioChannels(maxAudioChannels int32) ApiGetLiveHlsStreamRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiGetLiveHlsStreamRequest) Profile(profile string) ApiGetLiveHlsStreamRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiGetLiveHlsStreamRequest) Level(level string) ApiGetLiveHlsStreamRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetLiveHlsStreamRequest) Framerate(framerate float32) ApiGetLiveHlsStreamRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetLiveHlsStreamRequest) MaxFramerate(maxFramerate float32) ApiGetLiveHlsStreamRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiGetLiveHlsStreamRequest) CopyTimestamps(copyTimestamps bool) ApiGetLiveHlsStreamRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiGetLiveHlsStreamRequest) StartTimeTicks(startTimeTicks int64) ApiGetLiveHlsStreamRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiGetLiveHlsStreamRequest) Width(width int32) ApiGetLiveHlsStreamRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiGetLiveHlsStreamRequest) Height(height int32) ApiGetLiveHlsStreamRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiGetLiveHlsStreamRequest) VideoBitRate(videoBitRate int32) ApiGetLiveHlsStreamRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiGetLiveHlsStreamRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiGetLiveHlsStreamRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiGetLiveHlsStreamRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiGetLiveHlsStreamRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiGetLiveHlsStreamRequest) MaxRefFrames(maxRefFrames int32) ApiGetLiveHlsStreamRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiGetLiveHlsStreamRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiGetLiveHlsStreamRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiGetLiveHlsStreamRequest) RequireAvc(requireAvc bool) ApiGetLiveHlsStreamRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiGetLiveHlsStreamRequest) DeInterlace(deInterlace bool) ApiGetLiveHlsStreamRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiGetLiveHlsStreamRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiGetLiveHlsStreamRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiGetLiveHlsStreamRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiGetLiveHlsStreamRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiGetLiveHlsStreamRequest) CpuCoreLimit(cpuCoreLimit int32) ApiGetLiveHlsStreamRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiGetLiveHlsStreamRequest) LiveStreamId(liveStreamId string) ApiGetLiveHlsStreamRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiGetLiveHlsStreamRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiGetLiveHlsStreamRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiGetLiveHlsStreamRequest) VideoCodec(videoCodec string) ApiGetLiveHlsStreamRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiGetLiveHlsStreamRequest) SubtitleCodec(subtitleCodec string) ApiGetLiveHlsStreamRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiGetLiveHlsStreamRequest) TranscodeReasons(transcodeReasons string) ApiGetLiveHlsStreamRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiGetLiveHlsStreamRequest) AudioStreamIndex(audioStreamIndex int32) ApiGetLiveHlsStreamRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiGetLiveHlsStreamRequest) VideoStreamIndex(videoStreamIndex int32) ApiGetLiveHlsStreamRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiGetLiveHlsStreamRequest) Context(context EncodingContext) ApiGetLiveHlsStreamRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiGetLiveHlsStreamRequest) StreamOptions(streamOptions map[string]string) ApiGetLiveHlsStreamRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. The max width.
func (r ApiGetLiveHlsStreamRequest) MaxWidth(maxWidth int32) ApiGetLiveHlsStreamRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The max height.
func (r ApiGetLiveHlsStreamRequest) MaxHeight(maxHeight int32) ApiGetLiveHlsStreamRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Whether to enable subtitles in the manifest.
func (r ApiGetLiveHlsStreamRequest) EnableSubtitlesInManifest(enableSubtitlesInManifest bool) ApiGetLiveHlsStreamRequest {
	r.enableSubtitlesInManifest = &enableSubtitlesInManifest
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r ApiGetLiveHlsStreamRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiGetLiveHlsStreamRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r ApiGetLiveHlsStreamRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) ApiGetLiveHlsStreamRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r ApiGetLiveHlsStreamRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetLiveHlsStreamExecute(r)
}

/*
GetLiveHlsStream Gets a hls live stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiGetLiveHlsStreamRequest
*/
func (a *DynamicHlsAPIService) GetLiveHlsStream(ctx context.Context, itemId string) ApiGetLiveHlsStreamRequest {
	return ApiGetLiveHlsStreamRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetLiveHlsStreamExecute(r ApiGetLiveHlsStreamRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetLiveHlsStream")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/live.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.container != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "container", r.container, "form", "")
	}
	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.enableSubtitlesInManifest != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableSubtitlesInManifest", r.enableSubtitlesInManifest, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMasterHlsAudioPlaylistRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableAudioVbrEncoding *bool
}

// The media version id, if playing an alternate version.
func (r ApiGetMasterHlsAudioPlaylistRequest) MediaSourceId(mediaSourceId string) ApiGetMasterHlsAudioPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiGetMasterHlsAudioPlaylistRequest) Static(static bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiGetMasterHlsAudioPlaylistRequest) Params(params string) ApiGetMasterHlsAudioPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiGetMasterHlsAudioPlaylistRequest) Tag(tag string) ApiGetMasterHlsAudioPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiGetMasterHlsAudioPlaylistRequest) DeviceProfileId(deviceProfileId string) ApiGetMasterHlsAudioPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiGetMasterHlsAudioPlaylistRequest) PlaySessionId(playSessionId string) ApiGetMasterHlsAudioPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiGetMasterHlsAudioPlaylistRequest) SegmentContainer(segmentContainer string) ApiGetMasterHlsAudioPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiGetMasterHlsAudioPlaylistRequest) SegmentLength(segmentLength int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiGetMasterHlsAudioPlaylistRequest) MinSegments(minSegments int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiGetMasterHlsAudioPlaylistRequest) DeviceId(deviceId string) ApiGetMasterHlsAudioPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiGetMasterHlsAudioPlaylistRequest) AudioCodec(audioCodec string) ApiGetMasterHlsAudioPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiGetMasterHlsAudioPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiGetMasterHlsAudioPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiGetMasterHlsAudioPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiGetMasterHlsAudioPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiGetMasterHlsAudioPlaylistRequest) AudioSampleRate(audioSampleRate int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiGetMasterHlsAudioPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r ApiGetMasterHlsAudioPlaylistRequest) MaxStreamingBitrate(maxStreamingBitrate int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiGetMasterHlsAudioPlaylistRequest) AudioBitRate(audioBitRate int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiGetMasterHlsAudioPlaylistRequest) AudioChannels(audioChannels int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiGetMasterHlsAudioPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiGetMasterHlsAudioPlaylistRequest) Profile(profile string) ApiGetMasterHlsAudioPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiGetMasterHlsAudioPlaylistRequest) Level(level string) ApiGetMasterHlsAudioPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetMasterHlsAudioPlaylistRequest) Framerate(framerate float32) ApiGetMasterHlsAudioPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetMasterHlsAudioPlaylistRequest) MaxFramerate(maxFramerate float32) ApiGetMasterHlsAudioPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiGetMasterHlsAudioPlaylistRequest) CopyTimestamps(copyTimestamps bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiGetMasterHlsAudioPlaylistRequest) StartTimeTicks(startTimeTicks int64) ApiGetMasterHlsAudioPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiGetMasterHlsAudioPlaylistRequest) Width(width int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiGetMasterHlsAudioPlaylistRequest) Height(height int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiGetMasterHlsAudioPlaylistRequest) VideoBitRate(videoBitRate int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiGetMasterHlsAudioPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiGetMasterHlsAudioPlaylistRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiGetMasterHlsAudioPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiGetMasterHlsAudioPlaylistRequest) MaxRefFrames(maxRefFrames int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiGetMasterHlsAudioPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiGetMasterHlsAudioPlaylistRequest) RequireAvc(requireAvc bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiGetMasterHlsAudioPlaylistRequest) DeInterlace(deInterlace bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiGetMasterHlsAudioPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiGetMasterHlsAudioPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiGetMasterHlsAudioPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiGetMasterHlsAudioPlaylistRequest) LiveStreamId(liveStreamId string) ApiGetMasterHlsAudioPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiGetMasterHlsAudioPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiGetMasterHlsAudioPlaylistRequest) VideoCodec(videoCodec string) ApiGetMasterHlsAudioPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiGetMasterHlsAudioPlaylistRequest) SubtitleCodec(subtitleCodec string) ApiGetMasterHlsAudioPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiGetMasterHlsAudioPlaylistRequest) TranscodeReasons(transcodeReasons string) ApiGetMasterHlsAudioPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiGetMasterHlsAudioPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiGetMasterHlsAudioPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) ApiGetMasterHlsAudioPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiGetMasterHlsAudioPlaylistRequest) Context(context EncodingContext) ApiGetMasterHlsAudioPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiGetMasterHlsAudioPlaylistRequest) StreamOptions(streamOptions map[string]string) ApiGetMasterHlsAudioPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r ApiGetMasterHlsAudioPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r ApiGetMasterHlsAudioPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiGetMasterHlsAudioPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r ApiGetMasterHlsAudioPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMasterHlsAudioPlaylistExecute(r)
}

/*
GetMasterHlsAudioPlaylist Gets an audio hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiGetMasterHlsAudioPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetMasterHlsAudioPlaylist(ctx context.Context, itemId string) ApiGetMasterHlsAudioPlaylistRequest {
	return ApiGetMasterHlsAudioPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetMasterHlsAudioPlaylistExecute(r ApiGetMasterHlsAudioPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetMasterHlsAudioPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMasterHlsVideoPlaylistRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableTrickplay *bool
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The media version id, if playing an alternate version.
func (r ApiGetMasterHlsVideoPlaylistRequest) MediaSourceId(mediaSourceId string) ApiGetMasterHlsVideoPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiGetMasterHlsVideoPlaylistRequest) Static(static bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiGetMasterHlsVideoPlaylistRequest) Params(params string) ApiGetMasterHlsVideoPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiGetMasterHlsVideoPlaylistRequest) Tag(tag string) ApiGetMasterHlsVideoPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiGetMasterHlsVideoPlaylistRequest) DeviceProfileId(deviceProfileId string) ApiGetMasterHlsVideoPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiGetMasterHlsVideoPlaylistRequest) PlaySessionId(playSessionId string) ApiGetMasterHlsVideoPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiGetMasterHlsVideoPlaylistRequest) SegmentContainer(segmentContainer string) ApiGetMasterHlsVideoPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiGetMasterHlsVideoPlaylistRequest) SegmentLength(segmentLength int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiGetMasterHlsVideoPlaylistRequest) MinSegments(minSegments int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiGetMasterHlsVideoPlaylistRequest) DeviceId(deviceId string) ApiGetMasterHlsVideoPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiGetMasterHlsVideoPlaylistRequest) AudioCodec(audioCodec string) ApiGetMasterHlsVideoPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiGetMasterHlsVideoPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiGetMasterHlsVideoPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiGetMasterHlsVideoPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiGetMasterHlsVideoPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiGetMasterHlsVideoPlaylistRequest) AudioSampleRate(audioSampleRate int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiGetMasterHlsVideoPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiGetMasterHlsVideoPlaylistRequest) AudioBitRate(audioBitRate int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiGetMasterHlsVideoPlaylistRequest) AudioChannels(audioChannels int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiGetMasterHlsVideoPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiGetMasterHlsVideoPlaylistRequest) Profile(profile string) ApiGetMasterHlsVideoPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiGetMasterHlsVideoPlaylistRequest) Level(level string) ApiGetMasterHlsVideoPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetMasterHlsVideoPlaylistRequest) Framerate(framerate float32) ApiGetMasterHlsVideoPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetMasterHlsVideoPlaylistRequest) MaxFramerate(maxFramerate float32) ApiGetMasterHlsVideoPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiGetMasterHlsVideoPlaylistRequest) CopyTimestamps(copyTimestamps bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiGetMasterHlsVideoPlaylistRequest) StartTimeTicks(startTimeTicks int64) ApiGetMasterHlsVideoPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiGetMasterHlsVideoPlaylistRequest) Width(width int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiGetMasterHlsVideoPlaylistRequest) Height(height int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r ApiGetMasterHlsVideoPlaylistRequest) MaxWidth(maxWidth int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r ApiGetMasterHlsVideoPlaylistRequest) MaxHeight(maxHeight int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiGetMasterHlsVideoPlaylistRequest) VideoBitRate(videoBitRate int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiGetMasterHlsVideoPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiGetMasterHlsVideoPlaylistRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiGetMasterHlsVideoPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiGetMasterHlsVideoPlaylistRequest) MaxRefFrames(maxRefFrames int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiGetMasterHlsVideoPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiGetMasterHlsVideoPlaylistRequest) RequireAvc(requireAvc bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiGetMasterHlsVideoPlaylistRequest) DeInterlace(deInterlace bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiGetMasterHlsVideoPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiGetMasterHlsVideoPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiGetMasterHlsVideoPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiGetMasterHlsVideoPlaylistRequest) LiveStreamId(liveStreamId string) ApiGetMasterHlsVideoPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiGetMasterHlsVideoPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiGetMasterHlsVideoPlaylistRequest) VideoCodec(videoCodec string) ApiGetMasterHlsVideoPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiGetMasterHlsVideoPlaylistRequest) SubtitleCodec(subtitleCodec string) ApiGetMasterHlsVideoPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiGetMasterHlsVideoPlaylistRequest) TranscodeReasons(transcodeReasons string) ApiGetMasterHlsVideoPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiGetMasterHlsVideoPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiGetMasterHlsVideoPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) ApiGetMasterHlsVideoPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiGetMasterHlsVideoPlaylistRequest) Context(context EncodingContext) ApiGetMasterHlsVideoPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiGetMasterHlsVideoPlaylistRequest) StreamOptions(streamOptions map[string]string) ApiGetMasterHlsVideoPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r ApiGetMasterHlsVideoPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Enable trickplay image playlists being added to master playlist.
func (r ApiGetMasterHlsVideoPlaylistRequest) EnableTrickplay(enableTrickplay bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.enableTrickplay = &enableTrickplay
	return r
}

// Whether to enable Audio Encoding.
func (r ApiGetMasterHlsVideoPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r ApiGetMasterHlsVideoPlaylistRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) ApiGetMasterHlsVideoPlaylistRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r ApiGetMasterHlsVideoPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMasterHlsVideoPlaylistExecute(r)
}

/*
GetMasterHlsVideoPlaylist Gets a video hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiGetMasterHlsVideoPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetMasterHlsVideoPlaylist(ctx context.Context, itemId string) ApiGetMasterHlsVideoPlaylistRequest {
	return ApiGetMasterHlsVideoPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetMasterHlsVideoPlaylistExecute(r ApiGetMasterHlsVideoPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetMasterHlsVideoPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableTrickplay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTrickplay", r.enableTrickplay, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTrickplay = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVariantHlsAudioPlaylistRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiGetVariantHlsAudioPlaylistRequest) Static(static bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiGetVariantHlsAudioPlaylistRequest) Params(params string) ApiGetVariantHlsAudioPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiGetVariantHlsAudioPlaylistRequest) Tag(tag string) ApiGetVariantHlsAudioPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiGetVariantHlsAudioPlaylistRequest) DeviceProfileId(deviceProfileId string) ApiGetVariantHlsAudioPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiGetVariantHlsAudioPlaylistRequest) PlaySessionId(playSessionId string) ApiGetVariantHlsAudioPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiGetVariantHlsAudioPlaylistRequest) SegmentContainer(segmentContainer string) ApiGetVariantHlsAudioPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiGetVariantHlsAudioPlaylistRequest) SegmentLength(segmentLength int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiGetVariantHlsAudioPlaylistRequest) MinSegments(minSegments int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r ApiGetVariantHlsAudioPlaylistRequest) MediaSourceId(mediaSourceId string) ApiGetVariantHlsAudioPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiGetVariantHlsAudioPlaylistRequest) DeviceId(deviceId string) ApiGetVariantHlsAudioPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiGetVariantHlsAudioPlaylistRequest) AudioCodec(audioCodec string) ApiGetVariantHlsAudioPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiGetVariantHlsAudioPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiGetVariantHlsAudioPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiGetVariantHlsAudioPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiGetVariantHlsAudioPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiGetVariantHlsAudioPlaylistRequest) AudioSampleRate(audioSampleRate int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiGetVariantHlsAudioPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r ApiGetVariantHlsAudioPlaylistRequest) MaxStreamingBitrate(maxStreamingBitrate int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiGetVariantHlsAudioPlaylistRequest) AudioBitRate(audioBitRate int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiGetVariantHlsAudioPlaylistRequest) AudioChannels(audioChannels int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiGetVariantHlsAudioPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiGetVariantHlsAudioPlaylistRequest) Profile(profile string) ApiGetVariantHlsAudioPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiGetVariantHlsAudioPlaylistRequest) Level(level string) ApiGetVariantHlsAudioPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetVariantHlsAudioPlaylistRequest) Framerate(framerate float32) ApiGetVariantHlsAudioPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetVariantHlsAudioPlaylistRequest) MaxFramerate(maxFramerate float32) ApiGetVariantHlsAudioPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiGetVariantHlsAudioPlaylistRequest) CopyTimestamps(copyTimestamps bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiGetVariantHlsAudioPlaylistRequest) StartTimeTicks(startTimeTicks int64) ApiGetVariantHlsAudioPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiGetVariantHlsAudioPlaylistRequest) Width(width int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiGetVariantHlsAudioPlaylistRequest) Height(height int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiGetVariantHlsAudioPlaylistRequest) VideoBitRate(videoBitRate int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiGetVariantHlsAudioPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiGetVariantHlsAudioPlaylistRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiGetVariantHlsAudioPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiGetVariantHlsAudioPlaylistRequest) MaxRefFrames(maxRefFrames int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiGetVariantHlsAudioPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiGetVariantHlsAudioPlaylistRequest) RequireAvc(requireAvc bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiGetVariantHlsAudioPlaylistRequest) DeInterlace(deInterlace bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiGetVariantHlsAudioPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiGetVariantHlsAudioPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiGetVariantHlsAudioPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiGetVariantHlsAudioPlaylistRequest) LiveStreamId(liveStreamId string) ApiGetVariantHlsAudioPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiGetVariantHlsAudioPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiGetVariantHlsAudioPlaylistRequest) VideoCodec(videoCodec string) ApiGetVariantHlsAudioPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiGetVariantHlsAudioPlaylistRequest) SubtitleCodec(subtitleCodec string) ApiGetVariantHlsAudioPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiGetVariantHlsAudioPlaylistRequest) TranscodeReasons(transcodeReasons string) ApiGetVariantHlsAudioPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiGetVariantHlsAudioPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiGetVariantHlsAudioPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) ApiGetVariantHlsAudioPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiGetVariantHlsAudioPlaylistRequest) Context(context EncodingContext) ApiGetVariantHlsAudioPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiGetVariantHlsAudioPlaylistRequest) StreamOptions(streamOptions map[string]string) ApiGetVariantHlsAudioPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r ApiGetVariantHlsAudioPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiGetVariantHlsAudioPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r ApiGetVariantHlsAudioPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetVariantHlsAudioPlaylistExecute(r)
}

/*
GetVariantHlsAudioPlaylist Gets an audio stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiGetVariantHlsAudioPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetVariantHlsAudioPlaylist(ctx context.Context, itemId string) ApiGetVariantHlsAudioPlaylistRequest {
	return ApiGetVariantHlsAudioPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetVariantHlsAudioPlaylistExecute(r ApiGetVariantHlsAudioPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetVariantHlsAudioPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/main.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetVariantHlsVideoPlaylistRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	mediaSourceId *string
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiGetVariantHlsVideoPlaylistRequest) Static(static bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiGetVariantHlsVideoPlaylistRequest) Params(params string) ApiGetVariantHlsVideoPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiGetVariantHlsVideoPlaylistRequest) Tag(tag string) ApiGetVariantHlsVideoPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiGetVariantHlsVideoPlaylistRequest) DeviceProfileId(deviceProfileId string) ApiGetVariantHlsVideoPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiGetVariantHlsVideoPlaylistRequest) PlaySessionId(playSessionId string) ApiGetVariantHlsVideoPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiGetVariantHlsVideoPlaylistRequest) SegmentContainer(segmentContainer string) ApiGetVariantHlsVideoPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiGetVariantHlsVideoPlaylistRequest) SegmentLength(segmentLength int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiGetVariantHlsVideoPlaylistRequest) MinSegments(minSegments int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The media version id, if playing an alternate version.
func (r ApiGetVariantHlsVideoPlaylistRequest) MediaSourceId(mediaSourceId string) ApiGetVariantHlsVideoPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiGetVariantHlsVideoPlaylistRequest) DeviceId(deviceId string) ApiGetVariantHlsVideoPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiGetVariantHlsVideoPlaylistRequest) AudioCodec(audioCodec string) ApiGetVariantHlsVideoPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiGetVariantHlsVideoPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiGetVariantHlsVideoPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiGetVariantHlsVideoPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiGetVariantHlsVideoPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiGetVariantHlsVideoPlaylistRequest) AudioSampleRate(audioSampleRate int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiGetVariantHlsVideoPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiGetVariantHlsVideoPlaylistRequest) AudioBitRate(audioBitRate int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiGetVariantHlsVideoPlaylistRequest) AudioChannels(audioChannels int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiGetVariantHlsVideoPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiGetVariantHlsVideoPlaylistRequest) Profile(profile string) ApiGetVariantHlsVideoPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiGetVariantHlsVideoPlaylistRequest) Level(level string) ApiGetVariantHlsVideoPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetVariantHlsVideoPlaylistRequest) Framerate(framerate float32) ApiGetVariantHlsVideoPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiGetVariantHlsVideoPlaylistRequest) MaxFramerate(maxFramerate float32) ApiGetVariantHlsVideoPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiGetVariantHlsVideoPlaylistRequest) CopyTimestamps(copyTimestamps bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiGetVariantHlsVideoPlaylistRequest) StartTimeTicks(startTimeTicks int64) ApiGetVariantHlsVideoPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiGetVariantHlsVideoPlaylistRequest) Width(width int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiGetVariantHlsVideoPlaylistRequest) Height(height int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r ApiGetVariantHlsVideoPlaylistRequest) MaxWidth(maxWidth int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r ApiGetVariantHlsVideoPlaylistRequest) MaxHeight(maxHeight int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiGetVariantHlsVideoPlaylistRequest) VideoBitRate(videoBitRate int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiGetVariantHlsVideoPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiGetVariantHlsVideoPlaylistRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiGetVariantHlsVideoPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiGetVariantHlsVideoPlaylistRequest) MaxRefFrames(maxRefFrames int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiGetVariantHlsVideoPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiGetVariantHlsVideoPlaylistRequest) RequireAvc(requireAvc bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiGetVariantHlsVideoPlaylistRequest) DeInterlace(deInterlace bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiGetVariantHlsVideoPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiGetVariantHlsVideoPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiGetVariantHlsVideoPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiGetVariantHlsVideoPlaylistRequest) LiveStreamId(liveStreamId string) ApiGetVariantHlsVideoPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiGetVariantHlsVideoPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiGetVariantHlsVideoPlaylistRequest) VideoCodec(videoCodec string) ApiGetVariantHlsVideoPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiGetVariantHlsVideoPlaylistRequest) SubtitleCodec(subtitleCodec string) ApiGetVariantHlsVideoPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiGetVariantHlsVideoPlaylistRequest) TranscodeReasons(transcodeReasons string) ApiGetVariantHlsVideoPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiGetVariantHlsVideoPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiGetVariantHlsVideoPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) ApiGetVariantHlsVideoPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiGetVariantHlsVideoPlaylistRequest) Context(context EncodingContext) ApiGetVariantHlsVideoPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiGetVariantHlsVideoPlaylistRequest) StreamOptions(streamOptions map[string]string) ApiGetVariantHlsVideoPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r ApiGetVariantHlsVideoPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r ApiGetVariantHlsVideoPlaylistRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) ApiGetVariantHlsVideoPlaylistRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r ApiGetVariantHlsVideoPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetVariantHlsVideoPlaylistExecute(r)
}

/*
GetVariantHlsVideoPlaylist Gets a video stream using HTTP live streaming.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiGetVariantHlsVideoPlaylistRequest
*/
func (a *DynamicHlsAPIService) GetVariantHlsVideoPlaylist(ctx context.Context, itemId string) ApiGetVariantHlsVideoPlaylistRequest {
	return ApiGetVariantHlsVideoPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) GetVariantHlsVideoPlaylistExecute(r ApiGetVariantHlsVideoPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.GetVariantHlsVideoPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/main.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadMasterHlsAudioPlaylistRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	maxStreamingBitrate *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableAudioVbrEncoding *bool
}

// The media version id, if playing an alternate version.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MediaSourceId(mediaSourceId string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Static(static bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Params(params string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Tag(tag string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiHeadMasterHlsAudioPlaylistRequest) DeviceProfileId(deviceProfileId string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiHeadMasterHlsAudioPlaylistRequest) PlaySessionId(playSessionId string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiHeadMasterHlsAudioPlaylistRequest) SegmentContainer(segmentContainer string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiHeadMasterHlsAudioPlaylistRequest) SegmentLength(segmentLength int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MinSegments(minSegments int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiHeadMasterHlsAudioPlaylistRequest) DeviceId(deviceId string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiHeadMasterHlsAudioPlaylistRequest) AudioCodec(audioCodec string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiHeadMasterHlsAudioPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiHeadMasterHlsAudioPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiHeadMasterHlsAudioPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiHeadMasterHlsAudioPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiHeadMasterHlsAudioPlaylistRequest) AudioSampleRate(audioSampleRate int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. The maximum streaming bitrate.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MaxStreamingBitrate(maxStreamingBitrate int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.maxStreamingBitrate = &maxStreamingBitrate
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiHeadMasterHlsAudioPlaylistRequest) AudioBitRate(audioBitRate int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiHeadMasterHlsAudioPlaylistRequest) AudioChannels(audioChannels int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Profile(profile string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Level(level string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Framerate(framerate float32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MaxFramerate(maxFramerate float32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiHeadMasterHlsAudioPlaylistRequest) CopyTimestamps(copyTimestamps bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiHeadMasterHlsAudioPlaylistRequest) StartTimeTicks(startTimeTicks int64) ApiHeadMasterHlsAudioPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Width(width int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Height(height int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.height = &height
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiHeadMasterHlsAudioPlaylistRequest) VideoBitRate(videoBitRate int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiHeadMasterHlsAudioPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiHeadMasterHlsAudioPlaylistRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiHeadMasterHlsAudioPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MaxRefFrames(maxRefFrames int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiHeadMasterHlsAudioPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiHeadMasterHlsAudioPlaylistRequest) RequireAvc(requireAvc bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiHeadMasterHlsAudioPlaylistRequest) DeInterlace(deInterlace bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiHeadMasterHlsAudioPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiHeadMasterHlsAudioPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiHeadMasterHlsAudioPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiHeadMasterHlsAudioPlaylistRequest) LiveStreamId(liveStreamId string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiHeadMasterHlsAudioPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiHeadMasterHlsAudioPlaylistRequest) VideoCodec(videoCodec string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiHeadMasterHlsAudioPlaylistRequest) SubtitleCodec(subtitleCodec string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiHeadMasterHlsAudioPlaylistRequest) TranscodeReasons(transcodeReasons string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiHeadMasterHlsAudioPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiHeadMasterHlsAudioPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) ApiHeadMasterHlsAudioPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiHeadMasterHlsAudioPlaylistRequest) Context(context EncodingContext) ApiHeadMasterHlsAudioPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiHeadMasterHlsAudioPlaylistRequest) StreamOptions(streamOptions map[string]string) ApiHeadMasterHlsAudioPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r ApiHeadMasterHlsAudioPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Optional. Whether to enable Audio Encoding.
func (r ApiHeadMasterHlsAudioPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiHeadMasterHlsAudioPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

func (r ApiHeadMasterHlsAudioPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMasterHlsAudioPlaylistExecute(r)
}

/*
HeadMasterHlsAudioPlaylist Gets an audio hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiHeadMasterHlsAudioPlaylistRequest
*/
func (a *DynamicHlsAPIService) HeadMasterHlsAudioPlaylist(ctx context.Context, itemId string) ApiHeadMasterHlsAudioPlaylistRequest {
	return ApiHeadMasterHlsAudioPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) HeadMasterHlsAudioPlaylistExecute(r ApiHeadMasterHlsAudioPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.HeadMasterHlsAudioPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Audio/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.maxStreamingBitrate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStreamingBitrate", r.maxStreamingBitrate, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadMasterHlsVideoPlaylistRequest struct {
	ctx context.Context
	ApiService DynamicHlsAPI
	itemId string
	mediaSourceId *string
	static *bool
	params *string
	tag *string
	deviceProfileId *string
	playSessionId *string
	segmentContainer *string
	segmentLength *int32
	minSegments *int32
	deviceId *string
	audioCodec *string
	enableAutoStreamCopy *bool
	allowVideoStreamCopy *bool
	allowAudioStreamCopy *bool
	breakOnNonKeyFrames *bool
	audioSampleRate *int32
	maxAudioBitDepth *int32
	audioBitRate *int32
	audioChannels *int32
	maxAudioChannels *int32
	profile *string
	level *string
	framerate *float32
	maxFramerate *float32
	copyTimestamps *bool
	startTimeTicks *int64
	width *int32
	height *int32
	maxWidth *int32
	maxHeight *int32
	videoBitRate *int32
	subtitleStreamIndex *int32
	subtitleMethod *SubtitleDeliveryMethod
	maxRefFrames *int32
	maxVideoBitDepth *int32
	requireAvc *bool
	deInterlace *bool
	requireNonAnamorphic *bool
	transcodingMaxAudioChannels *int32
	cpuCoreLimit *int32
	liveStreamId *string
	enableMpegtsM2TsMode *bool
	videoCodec *string
	subtitleCodec *string
	transcodeReasons *string
	audioStreamIndex *int32
	videoStreamIndex *int32
	context *EncodingContext
	streamOptions *map[string]string
	enableAdaptiveBitrateStreaming *bool
	enableTrickplay *bool
	enableAudioVbrEncoding *bool
	alwaysBurnInSubtitleWhenTranscoding *bool
}

// The media version id, if playing an alternate version.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MediaSourceId(mediaSourceId string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. If true, the original file will be streamed statically without any encoding. Use either no url extension or the original file extension. true/false.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Static(static bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.static = &static
	return r
}

// The streaming parameters.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Params(params string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.params = &params
	return r
}

// The tag.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Tag(tag string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.tag = &tag
	return r
}

// Optional. The dlna device profile id to utilize.
// Deprecated
func (r ApiHeadMasterHlsVideoPlaylistRequest) DeviceProfileId(deviceProfileId string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.deviceProfileId = &deviceProfileId
	return r
}

// The play session id.
func (r ApiHeadMasterHlsVideoPlaylistRequest) PlaySessionId(playSessionId string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.playSessionId = &playSessionId
	return r
}

// The segment container.
func (r ApiHeadMasterHlsVideoPlaylistRequest) SegmentContainer(segmentContainer string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.segmentContainer = &segmentContainer
	return r
}

// The segment length.
func (r ApiHeadMasterHlsVideoPlaylistRequest) SegmentLength(segmentLength int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.segmentLength = &segmentLength
	return r
}

// The minimum number of segments.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MinSegments(minSegments int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.minSegments = &minSegments
	return r
}

// The device id of the client requesting. Used to stop encoding processes when needed.
func (r ApiHeadMasterHlsVideoPlaylistRequest) DeviceId(deviceId string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Specify an audio codec to encode to, e.g. mp3.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AudioCodec(audioCodec string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.audioCodec = &audioCodec
	return r
}

// Whether or not to allow automatic stream copy if requested values match the original source. Defaults to true.
func (r ApiHeadMasterHlsVideoPlaylistRequest) EnableAutoStreamCopy(enableAutoStreamCopy bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.enableAutoStreamCopy = &enableAutoStreamCopy
	return r
}

// Whether or not to allow copying of the video stream url.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AllowVideoStreamCopy(allowVideoStreamCopy bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.allowVideoStreamCopy = &allowVideoStreamCopy
	return r
}

// Whether or not to allow copying of the audio stream url.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AllowAudioStreamCopy(allowAudioStreamCopy bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.allowAudioStreamCopy = &allowAudioStreamCopy
	return r
}

// Optional. Whether to break on non key frames.
func (r ApiHeadMasterHlsVideoPlaylistRequest) BreakOnNonKeyFrames(breakOnNonKeyFrames bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.breakOnNonKeyFrames = &breakOnNonKeyFrames
	return r
}

// Optional. Specify a specific audio sample rate, e.g. 44100.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AudioSampleRate(audioSampleRate int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.audioSampleRate = &audioSampleRate
	return r
}

// Optional. The maximum audio bit depth.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MaxAudioBitDepth(maxAudioBitDepth int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.maxAudioBitDepth = &maxAudioBitDepth
	return r
}

// Optional. Specify an audio bitrate to encode to, e.g. 128000. If omitted this will be left to encoder defaults.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AudioBitRate(audioBitRate int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.audioBitRate = &audioBitRate
	return r
}

// Optional. Specify a specific number of audio channels to encode to, e.g. 2.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AudioChannels(audioChannels int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.audioChannels = &audioChannels
	return r
}

// Optional. Specify a maximum number of audio channels to encode to, e.g. 2.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MaxAudioChannels(maxAudioChannels int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.maxAudioChannels = &maxAudioChannels
	return r
}

// Optional. Specify a specific an encoder profile (varies by encoder), e.g. main, baseline, high.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Profile(profile string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.profile = &profile
	return r
}

// Optional. Specify a level for the encoder profile (varies by encoder), e.g. 3, 3.1.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Level(level string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.level = &level
	return r
}

// Optional. A specific video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Framerate(framerate float32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.framerate = &framerate
	return r
}

// Optional. A specific maximum video framerate to encode to, e.g. 23.976. Generally this should be omitted unless the device has specific requirements.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MaxFramerate(maxFramerate float32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.maxFramerate = &maxFramerate
	return r
}

// Whether or not to copy timestamps when transcoding with an offset. Defaults to false.
func (r ApiHeadMasterHlsVideoPlaylistRequest) CopyTimestamps(copyTimestamps bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.copyTimestamps = &copyTimestamps
	return r
}

// Optional. Specify a starting offset, in ticks. 1 tick &#x3D; 10000 ms.
func (r ApiHeadMasterHlsVideoPlaylistRequest) StartTimeTicks(startTimeTicks int64) ApiHeadMasterHlsVideoPlaylistRequest {
	r.startTimeTicks = &startTimeTicks
	return r
}

// Optional. The fixed horizontal resolution of the encoded video.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Width(width int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.width = &width
	return r
}

// Optional. The fixed vertical resolution of the encoded video.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Height(height int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.height = &height
	return r
}

// Optional. The maximum horizontal resolution of the encoded video.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MaxWidth(maxWidth int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.maxWidth = &maxWidth
	return r
}

// Optional. The maximum vertical resolution of the encoded video.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MaxHeight(maxHeight int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Specify a video bitrate to encode to, e.g. 500000. If omitted this will be left to encoder defaults.
func (r ApiHeadMasterHlsVideoPlaylistRequest) VideoBitRate(videoBitRate int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.videoBitRate = &videoBitRate
	return r
}

// Optional. The index of the subtitle stream to use. If omitted no subtitles will be used.
func (r ApiHeadMasterHlsVideoPlaylistRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. Specify the subtitle delivery method.
func (r ApiHeadMasterHlsVideoPlaylistRequest) SubtitleMethod(subtitleMethod SubtitleDeliveryMethod) ApiHeadMasterHlsVideoPlaylistRequest {
	r.subtitleMethod = &subtitleMethod
	return r
}

// Optional.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MaxRefFrames(maxRefFrames int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.maxRefFrames = &maxRefFrames
	return r
}

// Optional. The maximum video bit depth.
func (r ApiHeadMasterHlsVideoPlaylistRequest) MaxVideoBitDepth(maxVideoBitDepth int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.maxVideoBitDepth = &maxVideoBitDepth
	return r
}

// Optional. Whether to require avc.
func (r ApiHeadMasterHlsVideoPlaylistRequest) RequireAvc(requireAvc bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.requireAvc = &requireAvc
	return r
}

// Optional. Whether to deinterlace the video.
func (r ApiHeadMasterHlsVideoPlaylistRequest) DeInterlace(deInterlace bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.deInterlace = &deInterlace
	return r
}

// Optional. Whether to require a non anamorphic stream.
func (r ApiHeadMasterHlsVideoPlaylistRequest) RequireNonAnamorphic(requireNonAnamorphic bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.requireNonAnamorphic = &requireNonAnamorphic
	return r
}

// Optional. The maximum number of audio channels to transcode.
func (r ApiHeadMasterHlsVideoPlaylistRequest) TranscodingMaxAudioChannels(transcodingMaxAudioChannels int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.transcodingMaxAudioChannels = &transcodingMaxAudioChannels
	return r
}

// Optional. The limit of how many cpu cores to use.
func (r ApiHeadMasterHlsVideoPlaylistRequest) CpuCoreLimit(cpuCoreLimit int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.cpuCoreLimit = &cpuCoreLimit
	return r
}

// The live stream id.
func (r ApiHeadMasterHlsVideoPlaylistRequest) LiveStreamId(liveStreamId string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.liveStreamId = &liveStreamId
	return r
}

// Optional. Whether to enable the MpegtsM2Ts mode.
func (r ApiHeadMasterHlsVideoPlaylistRequest) EnableMpegtsM2TsMode(enableMpegtsM2TsMode bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.enableMpegtsM2TsMode = &enableMpegtsM2TsMode
	return r
}

// Optional. Specify a video codec to encode to, e.g. h264.
func (r ApiHeadMasterHlsVideoPlaylistRequest) VideoCodec(videoCodec string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.videoCodec = &videoCodec
	return r
}

// Optional. Specify a subtitle codec to encode to.
func (r ApiHeadMasterHlsVideoPlaylistRequest) SubtitleCodec(subtitleCodec string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.subtitleCodec = &subtitleCodec
	return r
}

// Optional. The transcoding reason.
func (r ApiHeadMasterHlsVideoPlaylistRequest) TranscodeReasons(transcodeReasons string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.transcodeReasons = &transcodeReasons
	return r
}

// Optional. The index of the audio stream to use. If omitted the first audio stream will be used.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AudioStreamIndex(audioStreamIndex int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the video stream to use. If omitted the first video stream will be used.
func (r ApiHeadMasterHlsVideoPlaylistRequest) VideoStreamIndex(videoStreamIndex int32) ApiHeadMasterHlsVideoPlaylistRequest {
	r.videoStreamIndex = &videoStreamIndex
	return r
}

// Optional. The MediaBrowser.Model.Dlna.EncodingContext.
func (r ApiHeadMasterHlsVideoPlaylistRequest) Context(context EncodingContext) ApiHeadMasterHlsVideoPlaylistRequest {
	r.context = &context
	return r
}

// Optional. The streaming options.
func (r ApiHeadMasterHlsVideoPlaylistRequest) StreamOptions(streamOptions map[string]string) ApiHeadMasterHlsVideoPlaylistRequest {
	r.streamOptions = &streamOptions
	return r
}

// Enable adaptive bitrate streaming.
func (r ApiHeadMasterHlsVideoPlaylistRequest) EnableAdaptiveBitrateStreaming(enableAdaptiveBitrateStreaming bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.enableAdaptiveBitrateStreaming = &enableAdaptiveBitrateStreaming
	return r
}

// Enable trickplay image playlists being added to master playlist.
func (r ApiHeadMasterHlsVideoPlaylistRequest) EnableTrickplay(enableTrickplay bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.enableTrickplay = &enableTrickplay
	return r
}

// Whether to enable Audio Encoding.
func (r ApiHeadMasterHlsVideoPlaylistRequest) EnableAudioVbrEncoding(enableAudioVbrEncoding bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.enableAudioVbrEncoding = &enableAudioVbrEncoding
	return r
}

// Whether to always burn in subtitles when transcoding.
func (r ApiHeadMasterHlsVideoPlaylistRequest) AlwaysBurnInSubtitleWhenTranscoding(alwaysBurnInSubtitleWhenTranscoding bool) ApiHeadMasterHlsVideoPlaylistRequest {
	r.alwaysBurnInSubtitleWhenTranscoding = &alwaysBurnInSubtitleWhenTranscoding
	return r
}

func (r ApiHeadMasterHlsVideoPlaylistRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMasterHlsVideoPlaylistExecute(r)
}

/*
HeadMasterHlsVideoPlaylist Gets a video hls playlist stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId The item id.
 @return ApiHeadMasterHlsVideoPlaylistRequest
*/
func (a *DynamicHlsAPIService) HeadMasterHlsVideoPlaylist(ctx context.Context, itemId string) ApiHeadMasterHlsVideoPlaylistRequest {
	return ApiHeadMasterHlsVideoPlaylistRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *DynamicHlsAPIService) HeadMasterHlsVideoPlaylistExecute(r ApiHeadMasterHlsVideoPlaylistRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DynamicHlsAPIService.HeadMasterHlsVideoPlaylist")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Videos/{itemId}/master.m3u8"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.mediaSourceId == nil {
		return localVarReturnValue, nil, reportError("mediaSourceId is required and must be specified")
	}

	if r.static != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "static", r.static, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.deviceProfileId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceProfileId", r.deviceProfileId, "form", "")
	}
	if r.playSessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "playSessionId", r.playSessionId, "form", "")
	}
	if r.segmentContainer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentContainer", r.segmentContainer, "form", "")
	}
	if r.segmentLength != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "segmentLength", r.segmentLength, "form", "")
	}
	if r.minSegments != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minSegments", r.minSegments, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "form", "")
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "form", "")
	}
	if r.audioCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioCodec", r.audioCodec, "form", "")
	}
	if r.enableAutoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAutoStreamCopy", r.enableAutoStreamCopy, "form", "")
	}
	if r.allowVideoStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowVideoStreamCopy", r.allowVideoStreamCopy, "form", "")
	}
	if r.allowAudioStreamCopy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allowAudioStreamCopy", r.allowAudioStreamCopy, "form", "")
	}
	if r.breakOnNonKeyFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakOnNonKeyFrames", r.breakOnNonKeyFrames, "form", "")
	}
	if r.audioSampleRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioSampleRate", r.audioSampleRate, "form", "")
	}
	if r.maxAudioBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioBitDepth", r.maxAudioBitDepth, "form", "")
	}
	if r.audioBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioBitRate", r.audioBitRate, "form", "")
	}
	if r.audioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioChannels", r.audioChannels, "form", "")
	}
	if r.maxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxAudioChannels", r.maxAudioChannels, "form", "")
	}
	if r.profile != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "profile", r.profile, "form", "")
	}
	if r.level != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "level", r.level, "form", "")
	}
	if r.framerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "framerate", r.framerate, "form", "")
	}
	if r.maxFramerate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxFramerate", r.maxFramerate, "form", "")
	}
	if r.copyTimestamps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "copyTimestamps", r.copyTimestamps, "form", "")
	}
	if r.startTimeTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startTimeTicks", r.startTimeTicks, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.videoBitRate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoBitRate", r.videoBitRate, "form", "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "form", "")
	}
	if r.subtitleMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleMethod", r.subtitleMethod, "form", "")
	}
	if r.maxRefFrames != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxRefFrames", r.maxRefFrames, "form", "")
	}
	if r.maxVideoBitDepth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxVideoBitDepth", r.maxVideoBitDepth, "form", "")
	}
	if r.requireAvc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireAvc", r.requireAvc, "form", "")
	}
	if r.deInterlace != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deInterlace", r.deInterlace, "form", "")
	}
	if r.requireNonAnamorphic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "requireNonAnamorphic", r.requireNonAnamorphic, "form", "")
	}
	if r.transcodingMaxAudioChannels != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodingMaxAudioChannels", r.transcodingMaxAudioChannels, "form", "")
	}
	if r.cpuCoreLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cpuCoreLimit", r.cpuCoreLimit, "form", "")
	}
	if r.liveStreamId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "liveStreamId", r.liveStreamId, "form", "")
	}
	if r.enableMpegtsM2TsMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableMpegtsM2TsMode", r.enableMpegtsM2TsMode, "form", "")
	}
	if r.videoCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoCodec", r.videoCodec, "form", "")
	}
	if r.subtitleCodec != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleCodec", r.subtitleCodec, "form", "")
	}
	if r.transcodeReasons != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transcodeReasons", r.transcodeReasons, "form", "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "form", "")
	}
	if r.videoStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "videoStreamIndex", r.videoStreamIndex, "form", "")
	}
	if r.context != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "context", r.context, "form", "")
	}
	if r.streamOptions != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "streamOptions", r.streamOptions, "form", "")
	}
	if r.enableAdaptiveBitrateStreaming != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAdaptiveBitrateStreaming", r.enableAdaptiveBitrateStreaming, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAdaptiveBitrateStreaming = &defaultValue
	}
	if r.enableTrickplay != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTrickplay", r.enableTrickplay, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTrickplay = &defaultValue
	}
	if r.enableAudioVbrEncoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableAudioVbrEncoding", r.enableAudioVbrEncoding, "form", "")
	} else {
		var defaultValue bool = true
		r.enableAudioVbrEncoding = &defaultValue
	}
	if r.alwaysBurnInSubtitleWhenTranscoding != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "alwaysBurnInSubtitleWhenTranscoding", r.alwaysBurnInSubtitleWhenTranscoding, "form", "")
	} else {
		var defaultValue bool = false
		r.alwaysBurnInSubtitleWhenTranscoding = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/x-mpegURL"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

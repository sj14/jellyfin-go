/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.9.8
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


type SessionAPI interface {

	/*
	AddUserToSession Adds an additional user to a session.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@param userId The user id.
	@return ApiAddUserToSessionRequest
	*/
	AddUserToSession(ctx context.Context, sessionId string, userId string) ApiAddUserToSessionRequest

	// AddUserToSessionExecute executes the request
	AddUserToSessionExecute(r ApiAddUserToSessionRequest) (*http.Response, error)

	/*
	DisplayContent Instructs a session to browse to an item or view.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session Id.
	@return ApiDisplayContentRequest
	*/
	DisplayContent(ctx context.Context, sessionId string) ApiDisplayContentRequest

	// DisplayContentExecute executes the request
	DisplayContentExecute(r ApiDisplayContentRequest) (*http.Response, error)

	/*
	GetAuthProviders Get all auth providers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAuthProvidersRequest
	*/
	GetAuthProviders(ctx context.Context) ApiGetAuthProvidersRequest

	// GetAuthProvidersExecute executes the request
	//  @return []NameIdPair
	GetAuthProvidersExecute(r ApiGetAuthProvidersRequest) ([]NameIdPair, *http.Response, error)

	/*
	GetPasswordResetProviders Get all password reset providers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPasswordResetProvidersRequest
	*/
	GetPasswordResetProviders(ctx context.Context) ApiGetPasswordResetProvidersRequest

	// GetPasswordResetProvidersExecute executes the request
	//  @return []NameIdPair
	GetPasswordResetProvidersExecute(r ApiGetPasswordResetProvidersRequest) ([]NameIdPair, *http.Response, error)

	/*
	GetSessions Gets a list of sessions.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSessionsRequest
	*/
	GetSessions(ctx context.Context) ApiGetSessionsRequest

	// GetSessionsExecute executes the request
	//  @return []SessionInfo
	GetSessionsExecute(r ApiGetSessionsRequest) ([]SessionInfo, *http.Response, error)

	/*
	Play Instructs a session to play an item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@return ApiPlayRequest
	*/
	Play(ctx context.Context, sessionId string) ApiPlayRequest

	// PlayExecute executes the request
	PlayExecute(r ApiPlayRequest) (*http.Response, error)

	/*
	PostCapabilities Updates capabilities for a device.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostCapabilitiesRequest
	*/
	PostCapabilities(ctx context.Context) ApiPostCapabilitiesRequest

	// PostCapabilitiesExecute executes the request
	PostCapabilitiesExecute(r ApiPostCapabilitiesRequest) (*http.Response, error)

	/*
	PostFullCapabilities Updates capabilities for a device.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostFullCapabilitiesRequest
	*/
	PostFullCapabilities(ctx context.Context) ApiPostFullCapabilitiesRequest

	// PostFullCapabilitiesExecute executes the request
	PostFullCapabilitiesExecute(r ApiPostFullCapabilitiesRequest) (*http.Response, error)

	/*
	RemoveUserFromSession Removes an additional user from a session.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@param userId The user id.
	@return ApiRemoveUserFromSessionRequest
	*/
	RemoveUserFromSession(ctx context.Context, sessionId string, userId string) ApiRemoveUserFromSessionRequest

	// RemoveUserFromSessionExecute executes the request
	RemoveUserFromSessionExecute(r ApiRemoveUserFromSessionRequest) (*http.Response, error)

	/*
	ReportSessionEnded Reports that a session has ended.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReportSessionEndedRequest
	*/
	ReportSessionEnded(ctx context.Context) ApiReportSessionEndedRequest

	// ReportSessionEndedExecute executes the request
	ReportSessionEndedExecute(r ApiReportSessionEndedRequest) (*http.Response, error)

	/*
	ReportViewing Reports that a session is viewing an item.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiReportViewingRequest
	*/
	ReportViewing(ctx context.Context) ApiReportViewingRequest

	// ReportViewingExecute executes the request
	ReportViewingExecute(r ApiReportViewingRequest) (*http.Response, error)

	/*
	SendFullGeneralCommand Issues a full general command to a client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@return ApiSendFullGeneralCommandRequest
	*/
	SendFullGeneralCommand(ctx context.Context, sessionId string) ApiSendFullGeneralCommandRequest

	// SendFullGeneralCommandExecute executes the request
	SendFullGeneralCommandExecute(r ApiSendFullGeneralCommandRequest) (*http.Response, error)

	/*
	SendGeneralCommand Issues a general command to a client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@param command The command to send.
	@return ApiSendGeneralCommandRequest
	*/
	SendGeneralCommand(ctx context.Context, sessionId string, command GeneralCommandType) ApiSendGeneralCommandRequest

	// SendGeneralCommandExecute executes the request
	SendGeneralCommandExecute(r ApiSendGeneralCommandRequest) (*http.Response, error)

	/*
	SendMessageCommand Issues a command to a client to display a message to the user.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@return ApiSendMessageCommandRequest
	*/
	SendMessageCommand(ctx context.Context, sessionId string) ApiSendMessageCommandRequest

	// SendMessageCommandExecute executes the request
	SendMessageCommandExecute(r ApiSendMessageCommandRequest) (*http.Response, error)

	/*
	SendPlaystateCommand Issues a playstate command to a client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@param command The MediaBrowser.Model.Session.PlaystateCommand.
	@return ApiSendPlaystateCommandRequest
	*/
	SendPlaystateCommand(ctx context.Context, sessionId string, command PlaystateCommand) ApiSendPlaystateCommandRequest

	// SendPlaystateCommandExecute executes the request
	SendPlaystateCommandExecute(r ApiSendPlaystateCommandRequest) (*http.Response, error)

	/*
	SendSystemCommand Issues a system command to a client.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param sessionId The session id.
	@param command The command to send.
	@return ApiSendSystemCommandRequest
	*/
	SendSystemCommand(ctx context.Context, sessionId string, command GeneralCommandType) ApiSendSystemCommandRequest

	// SendSystemCommandExecute executes the request
	SendSystemCommandExecute(r ApiSendSystemCommandRequest) (*http.Response, error)
}

// SessionAPIService SessionAPI service
type SessionAPIService service

type ApiAddUserToSessionRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	userId string
}

func (r ApiAddUserToSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddUserToSessionExecute(r)
}

/*
AddUserToSession Adds an additional user to a session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param userId The user id.
 @return ApiAddUserToSessionRequest
*/
func (a *SessionAPIService) AddUserToSession(ctx context.Context, sessionId string, userId string) ApiAddUserToSessionRequest {
	return ApiAddUserToSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionAPIService) AddUserToSessionExecute(r ApiAddUserToSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.AddUserToSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/User/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDisplayContentRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	itemType *BaseItemKind
	itemId *string
	itemName *string
}

// The type of item to browse to.
func (r ApiDisplayContentRequest) ItemType(itemType BaseItemKind) ApiDisplayContentRequest {
	r.itemType = &itemType
	return r
}

// The Id of the item.
func (r ApiDisplayContentRequest) ItemId(itemId string) ApiDisplayContentRequest {
	r.itemId = &itemId
	return r
}

// The name of the item.
func (r ApiDisplayContentRequest) ItemName(itemName string) ApiDisplayContentRequest {
	r.itemName = &itemName
	return r
}

func (r ApiDisplayContentRequest) Execute() (*http.Response, error) {
	return r.ApiService.DisplayContentExecute(r)
}

/*
DisplayContent Instructs a session to browse to an item or view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session Id.
 @return ApiDisplayContentRequest
*/
func (a *SessionAPIService) DisplayContent(ctx context.Context, sessionId string) ApiDisplayContentRequest {
	return ApiDisplayContentRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) DisplayContentExecute(r ApiDisplayContentRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.DisplayContent")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Viewing"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemType == nil {
		return nil, reportError("itemType is required and must be specified")
	}
	if r.itemId == nil {
		return nil, reportError("itemId is required and must be specified")
	}
	if r.itemName == nil {
		return nil, reportError("itemName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "itemType", r.itemType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "itemId", r.itemId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "itemName", r.itemName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAuthProvidersRequest struct {
	ctx context.Context
	ApiService SessionAPI
}

func (r ApiGetAuthProvidersRequest) Execute() ([]NameIdPair, *http.Response, error) {
	return r.ApiService.GetAuthProvidersExecute(r)
}

/*
GetAuthProviders Get all auth providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAuthProvidersRequest
*/
func (a *SessionAPIService) GetAuthProviders(ctx context.Context) ApiGetAuthProvidersRequest {
	return ApiGetAuthProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameIdPair
func (a *SessionAPIService) GetAuthProvidersExecute(r ApiGetAuthProvidersRequest) ([]NameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.GetAuthProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/Providers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPasswordResetProvidersRequest struct {
	ctx context.Context
	ApiService SessionAPI
}

func (r ApiGetPasswordResetProvidersRequest) Execute() ([]NameIdPair, *http.Response, error) {
	return r.ApiService.GetPasswordResetProvidersExecute(r)
}

/*
GetPasswordResetProviders Get all password reset providers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPasswordResetProvidersRequest
*/
func (a *SessionAPIService) GetPasswordResetProviders(ctx context.Context) ApiGetPasswordResetProvidersRequest {
	return ApiGetPasswordResetProvidersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameIdPair
func (a *SessionAPIService) GetPasswordResetProvidersExecute(r ApiGetPasswordResetProvidersRequest) ([]NameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.GetPasswordResetProviders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Auth/PasswordResetProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSessionsRequest struct {
	ctx context.Context
	ApiService SessionAPI
	controllableByUserId *string
	deviceId *string
	activeWithinSeconds *int32
}

// Filter by sessions that a given user is allowed to remote control.
func (r ApiGetSessionsRequest) ControllableByUserId(controllableByUserId string) ApiGetSessionsRequest {
	r.controllableByUserId = &controllableByUserId
	return r
}

// Filter by device Id.
func (r ApiGetSessionsRequest) DeviceId(deviceId string) ApiGetSessionsRequest {
	r.deviceId = &deviceId
	return r
}

// Optional. Filter by sessions that were active in the last n seconds.
func (r ApiGetSessionsRequest) ActiveWithinSeconds(activeWithinSeconds int32) ApiGetSessionsRequest {
	r.activeWithinSeconds = &activeWithinSeconds
	return r
}

func (r ApiGetSessionsRequest) Execute() ([]SessionInfo, *http.Response, error) {
	return r.ApiService.GetSessionsExecute(r)
}

/*
GetSessions Gets a list of sessions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSessionsRequest
*/
func (a *SessionAPIService) GetSessions(ctx context.Context) ApiGetSessionsRequest {
	return ApiGetSessionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []SessionInfo
func (a *SessionAPIService) GetSessionsExecute(r ApiGetSessionsRequest) ([]SessionInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SessionInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.GetSessions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.controllableByUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "controllableByUserId", r.controllableByUserId, "")
	}
	if r.deviceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deviceId", r.deviceId, "")
	}
	if r.activeWithinSeconds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "activeWithinSeconds", r.activeWithinSeconds, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPlayRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	playCommand *PlayCommand
	itemIds *[]string
	startPositionTicks *int64
	mediaSourceId *string
	audioStreamIndex *int32
	subtitleStreamIndex *int32
	startIndex *int32
}

// The type of play command to issue (PlayNow, PlayNext, PlayLast). Clients who have not yet implemented play next and play last may play now.
func (r ApiPlayRequest) PlayCommand(playCommand PlayCommand) ApiPlayRequest {
	r.playCommand = &playCommand
	return r
}

// The ids of the items to play, comma delimited.
func (r ApiPlayRequest) ItemIds(itemIds []string) ApiPlayRequest {
	r.itemIds = &itemIds
	return r
}

// The starting position of the first item.
func (r ApiPlayRequest) StartPositionTicks(startPositionTicks int64) ApiPlayRequest {
	r.startPositionTicks = &startPositionTicks
	return r
}

// Optional. The media source id.
func (r ApiPlayRequest) MediaSourceId(mediaSourceId string) ApiPlayRequest {
	r.mediaSourceId = &mediaSourceId
	return r
}

// Optional. The index of the audio stream to play.
func (r ApiPlayRequest) AudioStreamIndex(audioStreamIndex int32) ApiPlayRequest {
	r.audioStreamIndex = &audioStreamIndex
	return r
}

// Optional. The index of the subtitle stream to play.
func (r ApiPlayRequest) SubtitleStreamIndex(subtitleStreamIndex int32) ApiPlayRequest {
	r.subtitleStreamIndex = &subtitleStreamIndex
	return r
}

// Optional. The start index.
func (r ApiPlayRequest) StartIndex(startIndex int32) ApiPlayRequest {
	r.startIndex = &startIndex
	return r
}

func (r ApiPlayRequest) Execute() (*http.Response, error) {
	return r.ApiService.PlayExecute(r)
}

/*
Play Instructs a session to play an item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @return ApiPlayRequest
*/
func (a *SessionAPIService) Play(ctx context.Context, sessionId string) ApiPlayRequest {
	return ApiPlayRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) PlayExecute(r ApiPlayRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.Play")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Playing"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.playCommand == nil {
		return nil, reportError("playCommand is required and must be specified")
	}
	if r.itemIds == nil {
		return nil, reportError("itemIds is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "playCommand", r.playCommand, "")
	{
		t := *r.itemIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "itemIds", t, "multi")
		}
	}
	if r.startPositionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startPositionTicks", r.startPositionTicks, "")
	}
	if r.mediaSourceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mediaSourceId", r.mediaSourceId, "")
	}
	if r.audioStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "audioStreamIndex", r.audioStreamIndex, "")
	}
	if r.subtitleStreamIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "subtitleStreamIndex", r.subtitleStreamIndex, "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostCapabilitiesRequest struct {
	ctx context.Context
	ApiService SessionAPI
	id *string
	playableMediaTypes *[]MediaType
	supportedCommands *[]GeneralCommandType
	supportsMediaControl *bool
	supportsPersistentIdentifier *bool
}

// The session id.
func (r ApiPostCapabilitiesRequest) Id(id string) ApiPostCapabilitiesRequest {
	r.id = &id
	return r
}

// A list of playable media types, comma delimited. Audio, Video, Book, Photo.
func (r ApiPostCapabilitiesRequest) PlayableMediaTypes(playableMediaTypes []MediaType) ApiPostCapabilitiesRequest {
	r.playableMediaTypes = &playableMediaTypes
	return r
}

// A list of supported remote control commands, comma delimited.
func (r ApiPostCapabilitiesRequest) SupportedCommands(supportedCommands []GeneralCommandType) ApiPostCapabilitiesRequest {
	r.supportedCommands = &supportedCommands
	return r
}

// Determines whether media can be played remotely..
func (r ApiPostCapabilitiesRequest) SupportsMediaControl(supportsMediaControl bool) ApiPostCapabilitiesRequest {
	r.supportsMediaControl = &supportsMediaControl
	return r
}

// Determines whether the device supports a unique identifier.
func (r ApiPostCapabilitiesRequest) SupportsPersistentIdentifier(supportsPersistentIdentifier bool) ApiPostCapabilitiesRequest {
	r.supportsPersistentIdentifier = &supportsPersistentIdentifier
	return r
}

func (r ApiPostCapabilitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostCapabilitiesExecute(r)
}

/*
PostCapabilities Updates capabilities for a device.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostCapabilitiesRequest
*/
func (a *SessionAPIService) PostCapabilities(ctx context.Context) ApiPostCapabilitiesRequest {
	return ApiPostCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) PostCapabilitiesExecute(r ApiPostCapabilitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.PostCapabilities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	if r.playableMediaTypes != nil {
		t := *r.playableMediaTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "playableMediaTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "playableMediaTypes", t, "multi")
		}
	}
	if r.supportedCommands != nil {
		t := *r.supportedCommands
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "supportedCommands", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "supportedCommands", t, "multi")
		}
	}
	if r.supportsMediaControl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supportsMediaControl", r.supportsMediaControl, "")
	} else {
		var defaultValue bool = false
		r.supportsMediaControl = &defaultValue
	}
	if r.supportsPersistentIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "supportsPersistentIdentifier", r.supportsPersistentIdentifier, "")
	} else {
		var defaultValue bool = true
		r.supportsPersistentIdentifier = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPostFullCapabilitiesRequest struct {
	ctx context.Context
	ApiService SessionAPI
	clientCapabilitiesDto *ClientCapabilitiesDto
	id *string
}

// The MediaBrowser.Model.Session.ClientCapabilities.
func (r ApiPostFullCapabilitiesRequest) ClientCapabilitiesDto(clientCapabilitiesDto ClientCapabilitiesDto) ApiPostFullCapabilitiesRequest {
	r.clientCapabilitiesDto = &clientCapabilitiesDto
	return r
}

// The session id.
func (r ApiPostFullCapabilitiesRequest) Id(id string) ApiPostFullCapabilitiesRequest {
	r.id = &id
	return r
}

func (r ApiPostFullCapabilitiesRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostFullCapabilitiesExecute(r)
}

/*
PostFullCapabilities Updates capabilities for a device.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostFullCapabilitiesRequest
*/
func (a *SessionAPIService) PostFullCapabilities(ctx context.Context) ApiPostFullCapabilitiesRequest {
	return ApiPostFullCapabilitiesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) PostFullCapabilitiesExecute(r ApiPostFullCapabilitiesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.PostFullCapabilities")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Capabilities/Full"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.clientCapabilitiesDto == nil {
		return nil, reportError("clientCapabilitiesDto is required and must be specified")
	}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.clientCapabilitiesDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiRemoveUserFromSessionRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	userId string
}

func (r ApiRemoveUserFromSessionRequest) Execute() (*http.Response, error) {
	return r.ApiService.RemoveUserFromSessionExecute(r)
}

/*
RemoveUserFromSession Removes an additional user from a session.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param userId The user id.
 @return ApiRemoveUserFromSessionRequest
*/
func (a *SessionAPIService) RemoveUserFromSession(ctx context.Context, sessionId string, userId string) ApiRemoveUserFromSessionRequest {
	return ApiRemoveUserFromSessionRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		userId: userId,
	}
}

// Execute executes the request
func (a *SessionAPIService) RemoveUserFromSessionExecute(r ApiRemoveUserFromSessionRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.RemoveUserFromSession")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/User/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReportSessionEndedRequest struct {
	ctx context.Context
	ApiService SessionAPI
}

func (r ApiReportSessionEndedRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReportSessionEndedExecute(r)
}

/*
ReportSessionEnded Reports that a session has ended.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportSessionEndedRequest
*/
func (a *SessionAPIService) ReportSessionEnded(ctx context.Context) ApiReportSessionEndedRequest {
	return ApiReportSessionEndedRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) ReportSessionEndedExecute(r ApiReportSessionEndedRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.ReportSessionEnded")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Logout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiReportViewingRequest struct {
	ctx context.Context
	ApiService SessionAPI
	itemId *string
	sessionId *string
}

// The item id.
func (r ApiReportViewingRequest) ItemId(itemId string) ApiReportViewingRequest {
	r.itemId = &itemId
	return r
}

// The session id.
func (r ApiReportViewingRequest) SessionId(sessionId string) ApiReportViewingRequest {
	r.sessionId = &sessionId
	return r
}

func (r ApiReportViewingRequest) Execute() (*http.Response, error) {
	return r.ApiService.ReportViewingExecute(r)
}

/*
ReportViewing Reports that a session is viewing an item.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiReportViewingRequest
*/
func (a *SessionAPIService) ReportViewing(ctx context.Context) ApiReportViewingRequest {
	return ApiReportViewingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SessionAPIService) ReportViewingExecute(r ApiReportViewingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.ReportViewing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/Viewing"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.itemId == nil {
		return nil, reportError("itemId is required and must be specified")
	}

	if r.sessionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sessionId", r.sessionId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "itemId", r.itemId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendFullGeneralCommandRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	generalCommand *GeneralCommand
}

// The MediaBrowser.Model.Session.GeneralCommand.
func (r ApiSendFullGeneralCommandRequest) GeneralCommand(generalCommand GeneralCommand) ApiSendFullGeneralCommandRequest {
	r.generalCommand = &generalCommand
	return r
}

func (r ApiSendFullGeneralCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendFullGeneralCommandExecute(r)
}

/*
SendFullGeneralCommand Issues a full general command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @return ApiSendFullGeneralCommandRequest
*/
func (a *SessionAPIService) SendFullGeneralCommand(ctx context.Context, sessionId string) ApiSendFullGeneralCommandRequest {
	return ApiSendFullGeneralCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendFullGeneralCommandExecute(r ApiSendFullGeneralCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendFullGeneralCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Command"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.generalCommand == nil {
		return nil, reportError("generalCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.generalCommand
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendGeneralCommandRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	command GeneralCommandType
}

func (r ApiSendGeneralCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendGeneralCommandExecute(r)
}

/*
SendGeneralCommand Issues a general command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param command The command to send.
 @return ApiSendGeneralCommandRequest
*/
func (a *SessionAPIService) SendGeneralCommand(ctx context.Context, sessionId string, command GeneralCommandType) ApiSendGeneralCommandRequest {
	return ApiSendGeneralCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		command: command,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendGeneralCommandExecute(r ApiSendGeneralCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendGeneralCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Command/{command}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendMessageCommandRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	messageCommand *MessageCommand
}

// The MediaBrowser.Model.Session.MessageCommand object containing Header, Message Text, and TimeoutMs.
func (r ApiSendMessageCommandRequest) MessageCommand(messageCommand MessageCommand) ApiSendMessageCommandRequest {
	r.messageCommand = &messageCommand
	return r
}

func (r ApiSendMessageCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendMessageCommandExecute(r)
}

/*
SendMessageCommand Issues a command to a client to display a message to the user.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @return ApiSendMessageCommandRequest
*/
func (a *SessionAPIService) SendMessageCommand(ctx context.Context, sessionId string) ApiSendMessageCommandRequest {
	return ApiSendMessageCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendMessageCommandExecute(r ApiSendMessageCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendMessageCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Message"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.messageCommand == nil {
		return nil, reportError("messageCommand is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.messageCommand
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendPlaystateCommandRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	command PlaystateCommand
	seekPositionTicks *int64
	controllingUserId *string
}

// The optional position ticks.
func (r ApiSendPlaystateCommandRequest) SeekPositionTicks(seekPositionTicks int64) ApiSendPlaystateCommandRequest {
	r.seekPositionTicks = &seekPositionTicks
	return r
}

// The optional controlling user id.
func (r ApiSendPlaystateCommandRequest) ControllingUserId(controllingUserId string) ApiSendPlaystateCommandRequest {
	r.controllingUserId = &controllingUserId
	return r
}

func (r ApiSendPlaystateCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendPlaystateCommandExecute(r)
}

/*
SendPlaystateCommand Issues a playstate command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param command The MediaBrowser.Model.Session.PlaystateCommand.
 @return ApiSendPlaystateCommandRequest
*/
func (a *SessionAPIService) SendPlaystateCommand(ctx context.Context, sessionId string, command PlaystateCommand) ApiSendPlaystateCommandRequest {
	return ApiSendPlaystateCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		command: command,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendPlaystateCommandExecute(r ApiSendPlaystateCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendPlaystateCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/Playing/{command}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.seekPositionTicks != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seekPositionTicks", r.seekPositionTicks, "")
	}
	if r.controllingUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "controllingUserId", r.controllingUserId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSendSystemCommandRequest struct {
	ctx context.Context
	ApiService SessionAPI
	sessionId string
	command GeneralCommandType
}

func (r ApiSendSystemCommandRequest) Execute() (*http.Response, error) {
	return r.ApiService.SendSystemCommandExecute(r)
}

/*
SendSystemCommand Issues a system command to a client.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param sessionId The session id.
 @param command The command to send.
 @return ApiSendSystemCommandRequest
*/
func (a *SessionAPIService) SendSystemCommand(ctx context.Context, sessionId string, command GeneralCommandType) ApiSendSystemCommandRequest {
	return ApiSendSystemCommandRequest{
		ApiService: a,
		ctx: ctx,
		sessionId: sessionId,
		command: command,
	}
}

// Execute executes the request
func (a *SessionAPIService) SendSystemCommandExecute(r ApiSendSystemCommandRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SessionAPIService.SendSystemCommand")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Sessions/{sessionId}/System/{command}"
	localVarPath = strings.Replace(localVarPath, "{"+"sessionId"+"}", url.PathEscape(parameterValueToString(r.sessionId, "sessionId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"command"+"}", url.PathEscape(parameterValueToString(r.command, "command")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

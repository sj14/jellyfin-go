/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type ImageAPI interface {

	/*
	DeleteCustomSplashscreen Delete a custom splashscreen.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteCustomSplashscreenRequest
	*/
	DeleteCustomSplashscreen(ctx context.Context) ApiDeleteCustomSplashscreenRequest

	// DeleteCustomSplashscreenExecute executes the request
	DeleteCustomSplashscreenExecute(r ApiDeleteCustomSplashscreenRequest) (*http.Response, error)

	/*
	DeleteItemImage Delete an item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@return ApiDeleteItemImageRequest
	*/
	DeleteItemImage(ctx context.Context, itemId string, imageType ImageType) ApiDeleteItemImageRequest

	// DeleteItemImageExecute executes the request
	DeleteItemImageExecute(r ApiDeleteItemImageRequest) (*http.Response, error)

	/*
	DeleteItemImageByIndex Delete an item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@param imageIndex The image index.
	@return ApiDeleteItemImageByIndexRequest
	*/
	DeleteItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiDeleteItemImageByIndexRequest

	// DeleteItemImageByIndexExecute executes the request
	DeleteItemImageByIndexExecute(r ApiDeleteItemImageByIndexRequest) (*http.Response, error)

	/*
	DeleteUserImage Delete the user's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteUserImageRequest
	*/
	DeleteUserImage(ctx context.Context) ApiDeleteUserImageRequest

	// DeleteUserImageExecute executes the request
	DeleteUserImageExecute(r ApiDeleteUserImageRequest) (*http.Response, error)

	/*
	GetArtistImage Get artist image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Artist name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiGetArtistImageRequest
	*/
	GetArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetArtistImageRequest

	// GetArtistImageExecute executes the request
	//  @return *os.File
	GetArtistImageExecute(r ApiGetArtistImageRequest) (*os.File, *http.Response, error)

	/*
	GetGenreImage Get genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Genre name.
	@param imageType Image type.
	@return ApiGetGenreImageRequest
	*/
	GetGenreImage(ctx context.Context, name string, imageType ImageType) ApiGetGenreImageRequest

	// GetGenreImageExecute executes the request
	//  @return *os.File
	GetGenreImageExecute(r ApiGetGenreImageRequest) (*os.File, *http.Response, error)

	/*
	GetGenreImageByIndex Get genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Genre name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiGetGenreImageByIndexRequest
	*/
	GetGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetGenreImageByIndexRequest

	// GetGenreImageByIndexExecute executes the request
	//  @return *os.File
	GetGenreImageByIndexExecute(r ApiGetGenreImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	GetItemImage Gets the item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@return ApiGetItemImageRequest
	*/
	GetItemImage(ctx context.Context, itemId string, imageType ImageType) ApiGetItemImageRequest

	// GetItemImageExecute executes the request
	//  @return *os.File
	GetItemImageExecute(r ApiGetItemImageRequest) (*os.File, *http.Response, error)

	/*
	GetItemImage2 Gets the item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@param maxWidth The maximum image width to return.
	@param maxHeight The maximum image height to return.
	@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	@param format Determines the output format of the image - original,gif,jpg,png.
	@param percentPlayed Optional. Percent to render for the percent played overlay.
	@param unplayedCount Optional. Unplayed count overlay to render.
	@param imageIndex Image index.
	@return ApiGetItemImage2Request
	*/
	GetItemImage2(ctx context.Context, itemId string, imageType ImageType, maxWidth int32, maxHeight int32, tag string, format ImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32) ApiGetItemImage2Request

	// GetItemImage2Execute executes the request
	//  @return *os.File
	GetItemImage2Execute(r ApiGetItemImage2Request) (*os.File, *http.Response, error)

	/*
	GetItemImageByIndex Gets the item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiGetItemImageByIndexRequest
	*/
	GetItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiGetItemImageByIndexRequest

	// GetItemImageByIndexExecute executes the request
	//  @return *os.File
	GetItemImageByIndexExecute(r ApiGetItemImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	GetItemImageInfos Get item image infos.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@return ApiGetItemImageInfosRequest
	*/
	GetItemImageInfos(ctx context.Context, itemId string) ApiGetItemImageInfosRequest

	// GetItemImageInfosExecute executes the request
	//  @return []ImageInfo
	GetItemImageInfosExecute(r ApiGetItemImageInfosRequest) ([]ImageInfo, *http.Response, error)

	/*
	GetMusicGenreImage Get music genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Music genre name.
	@param imageType Image type.
	@return ApiGetMusicGenreImageRequest
	*/
	GetMusicGenreImage(ctx context.Context, name string, imageType ImageType) ApiGetMusicGenreImageRequest

	// GetMusicGenreImageExecute executes the request
	//  @return *os.File
	GetMusicGenreImageExecute(r ApiGetMusicGenreImageRequest) (*os.File, *http.Response, error)

	/*
	GetMusicGenreImageByIndex Get music genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Music genre name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiGetMusicGenreImageByIndexRequest
	*/
	GetMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetMusicGenreImageByIndexRequest

	// GetMusicGenreImageByIndexExecute executes the request
	//  @return *os.File
	GetMusicGenreImageByIndexExecute(r ApiGetMusicGenreImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	GetPersonImage Get person image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Person name.
	@param imageType Image type.
	@return ApiGetPersonImageRequest
	*/
	GetPersonImage(ctx context.Context, name string, imageType ImageType) ApiGetPersonImageRequest

	// GetPersonImageExecute executes the request
	//  @return *os.File
	GetPersonImageExecute(r ApiGetPersonImageRequest) (*os.File, *http.Response, error)

	/*
	GetPersonImageByIndex Get person image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Person name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiGetPersonImageByIndexRequest
	*/
	GetPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetPersonImageByIndexRequest

	// GetPersonImageByIndexExecute executes the request
	//  @return *os.File
	GetPersonImageByIndexExecute(r ApiGetPersonImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	GetSplashscreen Generates or gets the splashscreen.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSplashscreenRequest
	*/
	GetSplashscreen(ctx context.Context) ApiGetSplashscreenRequest

	// GetSplashscreenExecute executes the request
	//  @return *os.File
	GetSplashscreenExecute(r ApiGetSplashscreenRequest) (*os.File, *http.Response, error)

	/*
	GetStudioImage Get studio image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Studio name.
	@param imageType Image type.
	@return ApiGetStudioImageRequest
	*/
	GetStudioImage(ctx context.Context, name string, imageType ImageType) ApiGetStudioImageRequest

	// GetStudioImageExecute executes the request
	//  @return *os.File
	GetStudioImageExecute(r ApiGetStudioImageRequest) (*os.File, *http.Response, error)

	/*
	GetStudioImageByIndex Get studio image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Studio name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiGetStudioImageByIndexRequest
	*/
	GetStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetStudioImageByIndexRequest

	// GetStudioImageByIndexExecute executes the request
	//  @return *os.File
	GetStudioImageByIndexExecute(r ApiGetStudioImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	GetUserImage Get user profile image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetUserImageRequest
	*/
	GetUserImage(ctx context.Context) ApiGetUserImageRequest

	// GetUserImageExecute executes the request
	//  @return *os.File
	GetUserImageExecute(r ApiGetUserImageRequest) (*os.File, *http.Response, error)

	/*
	HeadArtistImage Get artist image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Artist name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiHeadArtistImageRequest
	*/
	HeadArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadArtistImageRequest

	// HeadArtistImageExecute executes the request
	//  @return *os.File
	HeadArtistImageExecute(r ApiHeadArtistImageRequest) (*os.File, *http.Response, error)

	/*
	HeadGenreImage Get genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Genre name.
	@param imageType Image type.
	@return ApiHeadGenreImageRequest
	*/
	HeadGenreImage(ctx context.Context, name string, imageType ImageType) ApiHeadGenreImageRequest

	// HeadGenreImageExecute executes the request
	//  @return *os.File
	HeadGenreImageExecute(r ApiHeadGenreImageRequest) (*os.File, *http.Response, error)

	/*
	HeadGenreImageByIndex Get genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Genre name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiHeadGenreImageByIndexRequest
	*/
	HeadGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadGenreImageByIndexRequest

	// HeadGenreImageByIndexExecute executes the request
	//  @return *os.File
	HeadGenreImageByIndexExecute(r ApiHeadGenreImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	HeadItemImage Gets the item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@return ApiHeadItemImageRequest
	*/
	HeadItemImage(ctx context.Context, itemId string, imageType ImageType) ApiHeadItemImageRequest

	// HeadItemImageExecute executes the request
	//  @return *os.File
	HeadItemImageExecute(r ApiHeadItemImageRequest) (*os.File, *http.Response, error)

	/*
	HeadItemImage2 Gets the item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@param maxWidth The maximum image width to return.
	@param maxHeight The maximum image height to return.
	@param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
	@param format Determines the output format of the image - original,gif,jpg,png.
	@param percentPlayed Optional. Percent to render for the percent played overlay.
	@param unplayedCount Optional. Unplayed count overlay to render.
	@param imageIndex Image index.
	@return ApiHeadItemImage2Request
	*/
	HeadItemImage2(ctx context.Context, itemId string, imageType ImageType, maxWidth int32, maxHeight int32, tag string, format ImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32) ApiHeadItemImage2Request

	// HeadItemImage2Execute executes the request
	//  @return *os.File
	HeadItemImage2Execute(r ApiHeadItemImage2Request) (*os.File, *http.Response, error)

	/*
	HeadItemImageByIndex Gets the item's image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiHeadItemImageByIndexRequest
	*/
	HeadItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiHeadItemImageByIndexRequest

	// HeadItemImageByIndexExecute executes the request
	//  @return *os.File
	HeadItemImageByIndexExecute(r ApiHeadItemImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	HeadMusicGenreImage Get music genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Music genre name.
	@param imageType Image type.
	@return ApiHeadMusicGenreImageRequest
	*/
	HeadMusicGenreImage(ctx context.Context, name string, imageType ImageType) ApiHeadMusicGenreImageRequest

	// HeadMusicGenreImageExecute executes the request
	//  @return *os.File
	HeadMusicGenreImageExecute(r ApiHeadMusicGenreImageRequest) (*os.File, *http.Response, error)

	/*
	HeadMusicGenreImageByIndex Get music genre image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Music genre name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiHeadMusicGenreImageByIndexRequest
	*/
	HeadMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadMusicGenreImageByIndexRequest

	// HeadMusicGenreImageByIndexExecute executes the request
	//  @return *os.File
	HeadMusicGenreImageByIndexExecute(r ApiHeadMusicGenreImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	HeadPersonImage Get person image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Person name.
	@param imageType Image type.
	@return ApiHeadPersonImageRequest
	*/
	HeadPersonImage(ctx context.Context, name string, imageType ImageType) ApiHeadPersonImageRequest

	// HeadPersonImageExecute executes the request
	//  @return *os.File
	HeadPersonImageExecute(r ApiHeadPersonImageRequest) (*os.File, *http.Response, error)

	/*
	HeadPersonImageByIndex Get person image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Person name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiHeadPersonImageByIndexRequest
	*/
	HeadPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadPersonImageByIndexRequest

	// HeadPersonImageByIndexExecute executes the request
	//  @return *os.File
	HeadPersonImageByIndexExecute(r ApiHeadPersonImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	HeadStudioImage Get studio image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Studio name.
	@param imageType Image type.
	@return ApiHeadStudioImageRequest
	*/
	HeadStudioImage(ctx context.Context, name string, imageType ImageType) ApiHeadStudioImageRequest

	// HeadStudioImageExecute executes the request
	//  @return *os.File
	HeadStudioImageExecute(r ApiHeadStudioImageRequest) (*os.File, *http.Response, error)

	/*
	HeadStudioImageByIndex Get studio image by name.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param name Studio name.
	@param imageType Image type.
	@param imageIndex Image index.
	@return ApiHeadStudioImageByIndexRequest
	*/
	HeadStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadStudioImageByIndexRequest

	// HeadStudioImageByIndexExecute executes the request
	//  @return *os.File
	HeadStudioImageByIndexExecute(r ApiHeadStudioImageByIndexRequest) (*os.File, *http.Response, error)

	/*
	HeadUserImage Get user profile image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiHeadUserImageRequest
	*/
	HeadUserImage(ctx context.Context) ApiHeadUserImageRequest

	// HeadUserImageExecute executes the request
	//  @return *os.File
	HeadUserImageExecute(r ApiHeadUserImageRequest) (*os.File, *http.Response, error)

	/*
	PostUserImage Sets the user image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiPostUserImageRequest
	*/
	PostUserImage(ctx context.Context) ApiPostUserImageRequest

	// PostUserImageExecute executes the request
	PostUserImageExecute(r ApiPostUserImageRequest) (*http.Response, error)

	/*
	SetItemImage Set item image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@return ApiSetItemImageRequest
	*/
	SetItemImage(ctx context.Context, itemId string, imageType ImageType) ApiSetItemImageRequest

	// SetItemImageExecute executes the request
	SetItemImageExecute(r ApiSetItemImageRequest) (*http.Response, error)

	/*
	SetItemImageByIndex Set item image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@param imageIndex (Unused) Image index.
	@return ApiSetItemImageByIndexRequest
	*/
	SetItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiSetItemImageByIndexRequest

	// SetItemImageByIndexExecute executes the request
	SetItemImageByIndexExecute(r ApiSetItemImageByIndexRequest) (*http.Response, error)

	/*
	UpdateItemImageIndex Updates the index for an item image.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@param imageType Image type.
	@param imageIndex Old image index.
	@return ApiUpdateItemImageIndexRequest
	*/
	UpdateItemImageIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiUpdateItemImageIndexRequest

	// UpdateItemImageIndexExecute executes the request
	UpdateItemImageIndexExecute(r ApiUpdateItemImageIndexRequest) (*http.Response, error)

	/*
	UploadCustomSplashscreen Uploads a custom splashscreen.  The body is expected to the image contents base64 encoded.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiUploadCustomSplashscreenRequest
	*/
	UploadCustomSplashscreen(ctx context.Context) ApiUploadCustomSplashscreenRequest

	// UploadCustomSplashscreenExecute executes the request
	UploadCustomSplashscreenExecute(r ApiUploadCustomSplashscreenRequest) (*http.Response, error)
}

// ImageAPIService ImageAPI service
type ImageAPIService service

type ApiDeleteCustomSplashscreenRequest struct {
	ctx context.Context
	ApiService ImageAPI
}

func (r ApiDeleteCustomSplashscreenRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteCustomSplashscreenExecute(r)
}

/*
DeleteCustomSplashscreen Delete a custom splashscreen.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteCustomSplashscreenRequest
*/
func (a *ImageAPIService) DeleteCustomSplashscreen(ctx context.Context) ApiDeleteCustomSplashscreenRequest {
	return ApiDeleteCustomSplashscreenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteCustomSplashscreenExecute(r ApiDeleteCustomSplashscreenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteCustomSplashscreen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Branding/Splashscreen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteItemImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	imageIndex *int32
}

// The image index.
func (r ApiDeleteItemImageRequest) ImageIndex(imageIndex int32) ApiDeleteItemImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiDeleteItemImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemImageExecute(r)
}

/*
DeleteItemImage Delete an item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ApiDeleteItemImageRequest
*/
func (a *ImageAPIService) DeleteItemImage(ctx context.Context, itemId string, imageType ImageType) ApiDeleteItemImageRequest {
	return ApiDeleteItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteItemImageExecute(r ApiDeleteItemImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteItemImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteItemImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	imageIndex int32
}

func (r ApiDeleteItemImageByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteItemImageByIndexExecute(r)
}

/*
DeleteItemImageByIndex Delete an item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex The image index.
 @return ApiDeleteItemImageByIndexRequest
*/
func (a *ImageAPIService) DeleteItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiDeleteItemImageByIndexRequest {
	return ApiDeleteItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteItemImageByIndexExecute(r ApiDeleteItemImageByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteItemImageByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteUserImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	userId *string
}

// User Id.
func (r ApiDeleteUserImageRequest) UserId(userId string) ApiDeleteUserImageRequest {
	r.userId = &userId
	return r
}

func (r ApiDeleteUserImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteUserImageExecute(r)
}

/*
DeleteUserImage Delete the user's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteUserImageRequest
*/
func (a *ImageAPIService) DeleteUserImage(ctx context.Context) ApiDeleteUserImageRequest {
	return ApiDeleteUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) DeleteUserImageExecute(r ApiDeleteUserImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.DeleteUserImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetArtistImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetArtistImageRequest) Tag(tag string) ApiGetArtistImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetArtistImageRequest) Format(format ImageFormat) ApiGetArtistImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetArtistImageRequest) MaxWidth(maxWidth int32) ApiGetArtistImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetArtistImageRequest) MaxHeight(maxHeight int32) ApiGetArtistImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetArtistImageRequest) PercentPlayed(percentPlayed float64) ApiGetArtistImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetArtistImageRequest) UnplayedCount(unplayedCount int32) ApiGetArtistImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetArtistImageRequest) Width(width int32) ApiGetArtistImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetArtistImageRequest) Height(height int32) ApiGetArtistImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetArtistImageRequest) Quality(quality int32) ApiGetArtistImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetArtistImageRequest) FillWidth(fillWidth int32) ApiGetArtistImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetArtistImageRequest) FillHeight(fillHeight int32) ApiGetArtistImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetArtistImageRequest) Blur(blur int32) ApiGetArtistImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetArtistImageRequest) BackgroundColor(backgroundColor string) ApiGetArtistImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetArtistImageRequest) ForegroundLayer(foregroundLayer string) ApiGetArtistImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiGetArtistImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetArtistImageExecute(r)
}

/*
GetArtistImage Get artist image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Artist name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiGetArtistImageRequest
*/
func (a *ImageAPIService) GetArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetArtistImageRequest {
	return ApiGetArtistImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetArtistImageExecute(r ApiGetArtistImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetArtistImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGenreImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetGenreImageRequest) Tag(tag string) ApiGetGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetGenreImageRequest) Format(format ImageFormat) ApiGetGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetGenreImageRequest) MaxWidth(maxWidth int32) ApiGetGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetGenreImageRequest) MaxHeight(maxHeight int32) ApiGetGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetGenreImageRequest) PercentPlayed(percentPlayed float64) ApiGetGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetGenreImageRequest) UnplayedCount(unplayedCount int32) ApiGetGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetGenreImageRequest) Width(width int32) ApiGetGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetGenreImageRequest) Height(height int32) ApiGetGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetGenreImageRequest) Quality(quality int32) ApiGetGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetGenreImageRequest) FillWidth(fillWidth int32) ApiGetGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetGenreImageRequest) FillHeight(fillHeight int32) ApiGetGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetGenreImageRequest) Blur(blur int32) ApiGetGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetGenreImageRequest) BackgroundColor(backgroundColor string) ApiGetGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetGenreImageRequest) ForegroundLayer(foregroundLayer string) ApiGetGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiGetGenreImageRequest) ImageIndex(imageIndex int32) ApiGetGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiGetGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetGenreImageExecute(r)
}

/*
GetGenreImage Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @return ApiGetGenreImageRequest
*/
func (a *ImageAPIService) GetGenreImage(ctx context.Context, name string, imageType ImageType) ApiGetGenreImageRequest {
	return ApiGetGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetGenreImageExecute(r ApiGetGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetGenreImageByIndexRequest) Tag(tag string) ApiGetGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetGenreImageByIndexRequest) Format(format ImageFormat) ApiGetGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetGenreImageByIndexRequest) MaxWidth(maxWidth int32) ApiGetGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetGenreImageByIndexRequest) MaxHeight(maxHeight int32) ApiGetGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiGetGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiGetGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetGenreImageByIndexRequest) Width(width int32) ApiGetGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetGenreImageByIndexRequest) Height(height int32) ApiGetGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetGenreImageByIndexRequest) Quality(quality int32) ApiGetGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetGenreImageByIndexRequest) FillWidth(fillWidth int32) ApiGetGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetGenreImageByIndexRequest) FillHeight(fillHeight int32) ApiGetGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetGenreImageByIndexRequest) Blur(blur int32) ApiGetGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ApiGetGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiGetGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiGetGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetGenreImageByIndexExecute(r)
}

/*
GetGenreImageByIndex Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiGetGenreImageByIndexRequest
*/
func (a *ImageAPIService) GetGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetGenreImageByIndexRequest {
	return ApiGetGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetGenreImageByIndexExecute(r ApiGetGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *ImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// The maximum image width to return.
func (r ApiGetItemImageRequest) MaxWidth(maxWidth int32) ApiGetItemImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetItemImageRequest) MaxHeight(maxHeight int32) ApiGetItemImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ApiGetItemImageRequest) Width(width int32) ApiGetItemImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetItemImageRequest) Height(height int32) ApiGetItemImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetItemImageRequest) Quality(quality int32) ApiGetItemImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetItemImageRequest) FillWidth(fillWidth int32) ApiGetItemImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetItemImageRequest) FillHeight(fillHeight int32) ApiGetItemImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetItemImageRequest) Tag(tag string) ApiGetItemImageRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ApiGetItemImageRequest) Format(format ImageFormat) ApiGetItemImageRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetItemImageRequest) PercentPlayed(percentPlayed float64) ApiGetItemImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetItemImageRequest) UnplayedCount(unplayedCount int32) ApiGetItemImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ApiGetItemImageRequest) Blur(blur int32) ApiGetItemImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetItemImageRequest) BackgroundColor(backgroundColor string) ApiGetItemImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetItemImageRequest) ForegroundLayer(foregroundLayer string) ApiGetItemImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiGetItemImageRequest) ImageIndex(imageIndex int32) ApiGetItemImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiGetItemImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetItemImageExecute(r)
}

/*
GetItemImage Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ApiGetItemImageRequest
*/
func (a *ImageAPIService) GetItemImage(ctx context.Context, itemId string, imageType ImageType) ApiGetItemImageRequest {
	return ApiGetItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetItemImageExecute(r ApiGetItemImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemImage2Request struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	maxWidth int32
	maxHeight int32
	tag string
	format ImageFormat
	percentPlayed float64
	unplayedCount int32
	imageIndex int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The fixed image width to return.
func (r ApiGetItemImage2Request) Width(width int32) ApiGetItemImage2Request {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetItemImage2Request) Height(height int32) ApiGetItemImage2Request {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetItemImage2Request) Quality(quality int32) ApiGetItemImage2Request {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetItemImage2Request) FillWidth(fillWidth int32) ApiGetItemImage2Request {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetItemImage2Request) FillHeight(fillHeight int32) ApiGetItemImage2Request {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetItemImage2Request) Blur(blur int32) ApiGetItemImage2Request {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetItemImage2Request) BackgroundColor(backgroundColor string) ApiGetItemImage2Request {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetItemImage2Request) ForegroundLayer(foregroundLayer string) ApiGetItemImage2Request {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiGetItemImage2Request) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetItemImage2Execute(r)
}

/*
GetItemImage2 Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param maxWidth The maximum image width to return.
 @param maxHeight The maximum image height to return.
 @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 @param format Determines the output format of the image - original,gif,jpg,png.
 @param percentPlayed Optional. Percent to render for the percent played overlay.
 @param unplayedCount Optional. Unplayed count overlay to render.
 @param imageIndex Image index.
 @return ApiGetItemImage2Request
*/
func (a *ImageAPIService) GetItemImage2(ctx context.Context, itemId string, imageType ImageType, maxWidth int32, maxHeight int32, tag string, format ImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32) ApiGetItemImage2Request {
	return ApiGetItemImage2Request{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		maxWidth: maxWidth,
		maxHeight: maxHeight,
		tag: tag,
		format: format,
		percentPlayed: percentPlayed,
		unplayedCount: unplayedCount,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetItemImage2Execute(r ApiGetItemImage2Request) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImage2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxWidth"+"}", url.PathEscape(parameterValueToString(r.maxWidth, "maxWidth")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxHeight"+"}", url.PathEscape(parameterValueToString(r.maxHeight, "maxHeight")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", url.PathEscape(parameterValueToString(r.tag, "tag")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"percentPlayed"+"}", url.PathEscape(parameterValueToString(r.percentPlayed, "percentPlayed")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unplayedCount"+"}", url.PathEscape(parameterValueToString(r.unplayedCount, "unplayedCount")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	imageIndex int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *ImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The maximum image width to return.
func (r ApiGetItemImageByIndexRequest) MaxWidth(maxWidth int32) ApiGetItemImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetItemImageByIndexRequest) MaxHeight(maxHeight int32) ApiGetItemImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ApiGetItemImageByIndexRequest) Width(width int32) ApiGetItemImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetItemImageByIndexRequest) Height(height int32) ApiGetItemImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetItemImageByIndexRequest) Quality(quality int32) ApiGetItemImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetItemImageByIndexRequest) FillWidth(fillWidth int32) ApiGetItemImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetItemImageByIndexRequest) FillHeight(fillHeight int32) ApiGetItemImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetItemImageByIndexRequest) Tag(tag string) ApiGetItemImageByIndexRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ApiGetItemImageByIndexRequest) Format(format ImageFormat) ApiGetItemImageByIndexRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetItemImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiGetItemImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetItemImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiGetItemImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ApiGetItemImageByIndexRequest) Blur(blur int32) ApiGetItemImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetItemImageByIndexRequest) BackgroundColor(backgroundColor string) ApiGetItemImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetItemImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiGetItemImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiGetItemImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetItemImageByIndexExecute(r)
}

/*
GetItemImageByIndex Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiGetItemImageByIndexRequest
*/
func (a *ImageAPIService) GetItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiGetItemImageByIndexRequest {
	return ApiGetItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetItemImageByIndexExecute(r ApiGetItemImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetItemImageInfosRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
}

func (r ApiGetItemImageInfosRequest) Execute() ([]ImageInfo, *http.Response, error) {
	return r.ApiService.GetItemImageInfosExecute(r)
}

/*
GetItemImageInfos Get item image infos.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @return ApiGetItemImageInfosRequest
*/
func (a *ImageAPIService) GetItemImageInfos(ctx context.Context, itemId string) ApiGetItemImageInfosRequest {
	return ApiGetItemImageInfosRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return []ImageInfo
func (a *ImageAPIService) GetItemImageInfosExecute(r ApiGetItemImageInfosRequest) ([]ImageInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ImageInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetItemImageInfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMusicGenreImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetMusicGenreImageRequest) Tag(tag string) ApiGetMusicGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetMusicGenreImageRequest) Format(format ImageFormat) ApiGetMusicGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetMusicGenreImageRequest) MaxWidth(maxWidth int32) ApiGetMusicGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetMusicGenreImageRequest) MaxHeight(maxHeight int32) ApiGetMusicGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetMusicGenreImageRequest) PercentPlayed(percentPlayed float64) ApiGetMusicGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetMusicGenreImageRequest) UnplayedCount(unplayedCount int32) ApiGetMusicGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetMusicGenreImageRequest) Width(width int32) ApiGetMusicGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetMusicGenreImageRequest) Height(height int32) ApiGetMusicGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetMusicGenreImageRequest) Quality(quality int32) ApiGetMusicGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetMusicGenreImageRequest) FillWidth(fillWidth int32) ApiGetMusicGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetMusicGenreImageRequest) FillHeight(fillHeight int32) ApiGetMusicGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetMusicGenreImageRequest) Blur(blur int32) ApiGetMusicGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetMusicGenreImageRequest) BackgroundColor(backgroundColor string) ApiGetMusicGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetMusicGenreImageRequest) ForegroundLayer(foregroundLayer string) ApiGetMusicGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiGetMusicGenreImageRequest) ImageIndex(imageIndex int32) ApiGetMusicGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiGetMusicGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMusicGenreImageExecute(r)
}

/*
GetMusicGenreImage Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @return ApiGetMusicGenreImageRequest
*/
func (a *ImageAPIService) GetMusicGenreImage(ctx context.Context, name string, imageType ImageType) ApiGetMusicGenreImageRequest {
	return ApiGetMusicGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetMusicGenreImageExecute(r ApiGetMusicGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetMusicGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMusicGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetMusicGenreImageByIndexRequest) Tag(tag string) ApiGetMusicGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetMusicGenreImageByIndexRequest) Format(format ImageFormat) ApiGetMusicGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetMusicGenreImageByIndexRequest) MaxWidth(maxWidth int32) ApiGetMusicGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetMusicGenreImageByIndexRequest) MaxHeight(maxHeight int32) ApiGetMusicGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetMusicGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiGetMusicGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetMusicGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiGetMusicGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetMusicGenreImageByIndexRequest) Width(width int32) ApiGetMusicGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetMusicGenreImageByIndexRequest) Height(height int32) ApiGetMusicGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetMusicGenreImageByIndexRequest) Quality(quality int32) ApiGetMusicGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetMusicGenreImageByIndexRequest) FillWidth(fillWidth int32) ApiGetMusicGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetMusicGenreImageByIndexRequest) FillHeight(fillHeight int32) ApiGetMusicGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetMusicGenreImageByIndexRequest) Blur(blur int32) ApiGetMusicGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetMusicGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ApiGetMusicGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetMusicGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiGetMusicGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiGetMusicGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetMusicGenreImageByIndexExecute(r)
}

/*
GetMusicGenreImageByIndex Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiGetMusicGenreImageByIndexRequest
*/
func (a *ImageAPIService) GetMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetMusicGenreImageByIndexRequest {
	return ApiGetMusicGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetMusicGenreImageByIndexExecute(r ApiGetMusicGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetMusicGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersonImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetPersonImageRequest) Tag(tag string) ApiGetPersonImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetPersonImageRequest) Format(format ImageFormat) ApiGetPersonImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetPersonImageRequest) MaxWidth(maxWidth int32) ApiGetPersonImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetPersonImageRequest) MaxHeight(maxHeight int32) ApiGetPersonImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetPersonImageRequest) PercentPlayed(percentPlayed float64) ApiGetPersonImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetPersonImageRequest) UnplayedCount(unplayedCount int32) ApiGetPersonImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetPersonImageRequest) Width(width int32) ApiGetPersonImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetPersonImageRequest) Height(height int32) ApiGetPersonImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetPersonImageRequest) Quality(quality int32) ApiGetPersonImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetPersonImageRequest) FillWidth(fillWidth int32) ApiGetPersonImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetPersonImageRequest) FillHeight(fillHeight int32) ApiGetPersonImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetPersonImageRequest) Blur(blur int32) ApiGetPersonImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetPersonImageRequest) BackgroundColor(backgroundColor string) ApiGetPersonImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetPersonImageRequest) ForegroundLayer(foregroundLayer string) ApiGetPersonImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiGetPersonImageRequest) ImageIndex(imageIndex int32) ApiGetPersonImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiGetPersonImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPersonImageExecute(r)
}

/*
GetPersonImage Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @return ApiGetPersonImageRequest
*/
func (a *ImageAPIService) GetPersonImage(ctx context.Context, name string, imageType ImageType) ApiGetPersonImageRequest {
	return ApiGetPersonImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetPersonImageExecute(r ApiGetPersonImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetPersonImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersonImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetPersonImageByIndexRequest) Tag(tag string) ApiGetPersonImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetPersonImageByIndexRequest) Format(format ImageFormat) ApiGetPersonImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetPersonImageByIndexRequest) MaxWidth(maxWidth int32) ApiGetPersonImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetPersonImageByIndexRequest) MaxHeight(maxHeight int32) ApiGetPersonImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetPersonImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiGetPersonImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetPersonImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiGetPersonImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetPersonImageByIndexRequest) Width(width int32) ApiGetPersonImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetPersonImageByIndexRequest) Height(height int32) ApiGetPersonImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetPersonImageByIndexRequest) Quality(quality int32) ApiGetPersonImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetPersonImageByIndexRequest) FillWidth(fillWidth int32) ApiGetPersonImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetPersonImageByIndexRequest) FillHeight(fillHeight int32) ApiGetPersonImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetPersonImageByIndexRequest) Blur(blur int32) ApiGetPersonImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetPersonImageByIndexRequest) BackgroundColor(backgroundColor string) ApiGetPersonImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetPersonImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiGetPersonImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiGetPersonImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetPersonImageByIndexExecute(r)
}

/*
GetPersonImageByIndex Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiGetPersonImageByIndexRequest
*/
func (a *ImageAPIService) GetPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetPersonImageByIndexRequest {
	return ApiGetPersonImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetPersonImageByIndexExecute(r ApiGetPersonImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetPersonImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSplashscreenRequest struct {
	ctx context.Context
	ApiService ImageAPI
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	quality *int32
}

// Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetSplashscreenRequest) Tag(tag string) ApiGetSplashscreenRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetSplashscreenRequest) Format(format ImageFormat) ApiGetSplashscreenRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetSplashscreenRequest) MaxWidth(maxWidth int32) ApiGetSplashscreenRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetSplashscreenRequest) MaxHeight(maxHeight int32) ApiGetSplashscreenRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ApiGetSplashscreenRequest) Width(width int32) ApiGetSplashscreenRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetSplashscreenRequest) Height(height int32) ApiGetSplashscreenRequest {
	r.height = &height
	return r
}

// Width of box to fill.
func (r ApiGetSplashscreenRequest) FillWidth(fillWidth int32) ApiGetSplashscreenRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetSplashscreenRequest) FillHeight(fillHeight int32) ApiGetSplashscreenRequest {
	r.fillHeight = &fillHeight
	return r
}

// Blur image.
func (r ApiGetSplashscreenRequest) Blur(blur int32) ApiGetSplashscreenRequest {
	r.blur = &blur
	return r
}

// Apply a background color for transparent images.
func (r ApiGetSplashscreenRequest) BackgroundColor(backgroundColor string) ApiGetSplashscreenRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Apply a foreground layer on top of the image.
func (r ApiGetSplashscreenRequest) ForegroundLayer(foregroundLayer string) ApiGetSplashscreenRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Quality setting, from 0-100.
func (r ApiGetSplashscreenRequest) Quality(quality int32) ApiGetSplashscreenRequest {
	r.quality = &quality
	return r
}

func (r ApiGetSplashscreenRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetSplashscreenExecute(r)
}

/*
GetSplashscreen Generates or gets the splashscreen.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSplashscreenRequest
*/
func (a *ImageAPIService) GetSplashscreen(ctx context.Context) ApiGetSplashscreenRequest {
	return ApiGetSplashscreenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetSplashscreenExecute(r ApiGetSplashscreenRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetSplashscreen")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Branding/Splashscreen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	} else {
		var defaultValue int32 = 90
		r.quality = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStudioImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetStudioImageRequest) Tag(tag string) ApiGetStudioImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetStudioImageRequest) Format(format ImageFormat) ApiGetStudioImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetStudioImageRequest) MaxWidth(maxWidth int32) ApiGetStudioImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetStudioImageRequest) MaxHeight(maxHeight int32) ApiGetStudioImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetStudioImageRequest) PercentPlayed(percentPlayed float64) ApiGetStudioImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetStudioImageRequest) UnplayedCount(unplayedCount int32) ApiGetStudioImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetStudioImageRequest) Width(width int32) ApiGetStudioImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetStudioImageRequest) Height(height int32) ApiGetStudioImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetStudioImageRequest) Quality(quality int32) ApiGetStudioImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetStudioImageRequest) FillWidth(fillWidth int32) ApiGetStudioImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetStudioImageRequest) FillHeight(fillHeight int32) ApiGetStudioImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetStudioImageRequest) Blur(blur int32) ApiGetStudioImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetStudioImageRequest) BackgroundColor(backgroundColor string) ApiGetStudioImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetStudioImageRequest) ForegroundLayer(foregroundLayer string) ApiGetStudioImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiGetStudioImageRequest) ImageIndex(imageIndex int32) ApiGetStudioImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiGetStudioImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetStudioImageExecute(r)
}

/*
GetStudioImage Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @return ApiGetStudioImageRequest
*/
func (a *ImageAPIService) GetStudioImage(ctx context.Context, name string, imageType ImageType) ApiGetStudioImageRequest {
	return ApiGetStudioImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetStudioImageExecute(r ApiGetStudioImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetStudioImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetStudioImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetStudioImageByIndexRequest) Tag(tag string) ApiGetStudioImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetStudioImageByIndexRequest) Format(format ImageFormat) ApiGetStudioImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetStudioImageByIndexRequest) MaxWidth(maxWidth int32) ApiGetStudioImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetStudioImageByIndexRequest) MaxHeight(maxHeight int32) ApiGetStudioImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetStudioImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiGetStudioImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetStudioImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiGetStudioImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetStudioImageByIndexRequest) Width(width int32) ApiGetStudioImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetStudioImageByIndexRequest) Height(height int32) ApiGetStudioImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetStudioImageByIndexRequest) Quality(quality int32) ApiGetStudioImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetStudioImageByIndexRequest) FillWidth(fillWidth int32) ApiGetStudioImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetStudioImageByIndexRequest) FillHeight(fillHeight int32) ApiGetStudioImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetStudioImageByIndexRequest) Blur(blur int32) ApiGetStudioImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetStudioImageByIndexRequest) BackgroundColor(backgroundColor string) ApiGetStudioImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetStudioImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiGetStudioImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiGetStudioImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetStudioImageByIndexExecute(r)
}

/*
GetStudioImageByIndex Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiGetStudioImageByIndexRequest
*/
func (a *ImageAPIService) GetStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiGetStudioImageByIndexRequest {
	return ApiGetStudioImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetStudioImageByIndexExecute(r ApiGetStudioImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetStudioImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	userId *string
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// User id.
func (r ApiGetUserImageRequest) UserId(userId string) ApiGetUserImageRequest {
	r.userId = &userId
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiGetUserImageRequest) Tag(tag string) ApiGetUserImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiGetUserImageRequest) Format(format ImageFormat) ApiGetUserImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiGetUserImageRequest) MaxWidth(maxWidth int32) ApiGetUserImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiGetUserImageRequest) MaxHeight(maxHeight int32) ApiGetUserImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiGetUserImageRequest) PercentPlayed(percentPlayed float64) ApiGetUserImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiGetUserImageRequest) UnplayedCount(unplayedCount int32) ApiGetUserImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiGetUserImageRequest) Width(width int32) ApiGetUserImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiGetUserImageRequest) Height(height int32) ApiGetUserImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiGetUserImageRequest) Quality(quality int32) ApiGetUserImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiGetUserImageRequest) FillWidth(fillWidth int32) ApiGetUserImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiGetUserImageRequest) FillHeight(fillHeight int32) ApiGetUserImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiGetUserImageRequest) Blur(blur int32) ApiGetUserImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiGetUserImageRequest) BackgroundColor(backgroundColor string) ApiGetUserImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiGetUserImageRequest) ForegroundLayer(foregroundLayer string) ApiGetUserImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiGetUserImageRequest) ImageIndex(imageIndex int32) ApiGetUserImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiGetUserImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetUserImageExecute(r)
}

/*
GetUserImage Get user profile image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserImageRequest
*/
func (a *ImageAPIService) GetUserImage(ctx context.Context) ApiGetUserImageRequest {
	return ApiGetUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) GetUserImageExecute(r ApiGetUserImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.GetUserImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadArtistImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadArtistImageRequest) Tag(tag string) ApiHeadArtistImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadArtistImageRequest) Format(format ImageFormat) ApiHeadArtistImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadArtistImageRequest) MaxWidth(maxWidth int32) ApiHeadArtistImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadArtistImageRequest) MaxHeight(maxHeight int32) ApiHeadArtistImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadArtistImageRequest) PercentPlayed(percentPlayed float64) ApiHeadArtistImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadArtistImageRequest) UnplayedCount(unplayedCount int32) ApiHeadArtistImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadArtistImageRequest) Width(width int32) ApiHeadArtistImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadArtistImageRequest) Height(height int32) ApiHeadArtistImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadArtistImageRequest) Quality(quality int32) ApiHeadArtistImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadArtistImageRequest) FillWidth(fillWidth int32) ApiHeadArtistImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadArtistImageRequest) FillHeight(fillHeight int32) ApiHeadArtistImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadArtistImageRequest) Blur(blur int32) ApiHeadArtistImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadArtistImageRequest) BackgroundColor(backgroundColor string) ApiHeadArtistImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadArtistImageRequest) ForegroundLayer(foregroundLayer string) ApiHeadArtistImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiHeadArtistImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadArtistImageExecute(r)
}

/*
HeadArtistImage Get artist image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Artist name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiHeadArtistImageRequest
*/
func (a *ImageAPIService) HeadArtistImage(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadArtistImageRequest {
	return ApiHeadArtistImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadArtistImageExecute(r ApiHeadArtistImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadArtistImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Artists/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadGenreImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadGenreImageRequest) Tag(tag string) ApiHeadGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadGenreImageRequest) Format(format ImageFormat) ApiHeadGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadGenreImageRequest) MaxWidth(maxWidth int32) ApiHeadGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadGenreImageRequest) MaxHeight(maxHeight int32) ApiHeadGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadGenreImageRequest) PercentPlayed(percentPlayed float64) ApiHeadGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadGenreImageRequest) UnplayedCount(unplayedCount int32) ApiHeadGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadGenreImageRequest) Width(width int32) ApiHeadGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadGenreImageRequest) Height(height int32) ApiHeadGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadGenreImageRequest) Quality(quality int32) ApiHeadGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadGenreImageRequest) FillWidth(fillWidth int32) ApiHeadGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadGenreImageRequest) FillHeight(fillHeight int32) ApiHeadGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadGenreImageRequest) Blur(blur int32) ApiHeadGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadGenreImageRequest) BackgroundColor(backgroundColor string) ApiHeadGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadGenreImageRequest) ForegroundLayer(foregroundLayer string) ApiHeadGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiHeadGenreImageRequest) ImageIndex(imageIndex int32) ApiHeadGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiHeadGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadGenreImageExecute(r)
}

/*
HeadGenreImage Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @return ApiHeadGenreImageRequest
*/
func (a *ImageAPIService) HeadGenreImage(ctx context.Context, name string, imageType ImageType) ApiHeadGenreImageRequest {
	return ApiHeadGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadGenreImageExecute(r ApiHeadGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadGenreImageByIndexRequest) Tag(tag string) ApiHeadGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadGenreImageByIndexRequest) Format(format ImageFormat) ApiHeadGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadGenreImageByIndexRequest) MaxWidth(maxWidth int32) ApiHeadGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadGenreImageByIndexRequest) MaxHeight(maxHeight int32) ApiHeadGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiHeadGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiHeadGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadGenreImageByIndexRequest) Width(width int32) ApiHeadGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadGenreImageByIndexRequest) Height(height int32) ApiHeadGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadGenreImageByIndexRequest) Quality(quality int32) ApiHeadGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadGenreImageByIndexRequest) FillWidth(fillWidth int32) ApiHeadGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadGenreImageByIndexRequest) FillHeight(fillHeight int32) ApiHeadGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadGenreImageByIndexRequest) Blur(blur int32) ApiHeadGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ApiHeadGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiHeadGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiHeadGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadGenreImageByIndexExecute(r)
}

/*
HeadGenreImageByIndex Get genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiHeadGenreImageByIndexRequest
*/
func (a *ImageAPIService) HeadGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadGenreImageByIndexRequest {
	return ApiHeadGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadGenreImageByIndexExecute(r ApiHeadGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Genres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadItemImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *ImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// The maximum image width to return.
func (r ApiHeadItemImageRequest) MaxWidth(maxWidth int32) ApiHeadItemImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadItemImageRequest) MaxHeight(maxHeight int32) ApiHeadItemImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ApiHeadItemImageRequest) Width(width int32) ApiHeadItemImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadItemImageRequest) Height(height int32) ApiHeadItemImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadItemImageRequest) Quality(quality int32) ApiHeadItemImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadItemImageRequest) FillWidth(fillWidth int32) ApiHeadItemImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadItemImageRequest) FillHeight(fillHeight int32) ApiHeadItemImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadItemImageRequest) Tag(tag string) ApiHeadItemImageRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ApiHeadItemImageRequest) Format(format ImageFormat) ApiHeadItemImageRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadItemImageRequest) PercentPlayed(percentPlayed float64) ApiHeadItemImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadItemImageRequest) UnplayedCount(unplayedCount int32) ApiHeadItemImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ApiHeadItemImageRequest) Blur(blur int32) ApiHeadItemImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadItemImageRequest) BackgroundColor(backgroundColor string) ApiHeadItemImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadItemImageRequest) ForegroundLayer(foregroundLayer string) ApiHeadItemImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiHeadItemImageRequest) ImageIndex(imageIndex int32) ApiHeadItemImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiHeadItemImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadItemImageExecute(r)
}

/*
HeadItemImage Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ApiHeadItemImageRequest
*/
func (a *ImageAPIService) HeadItemImage(ctx context.Context, itemId string, imageType ImageType) ApiHeadItemImageRequest {
	return ApiHeadItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadItemImageExecute(r ApiHeadItemImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadItemImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadItemImage2Request struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	maxWidth int32
	maxHeight int32
	tag string
	format ImageFormat
	percentPlayed float64
	unplayedCount int32
	imageIndex int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The fixed image width to return.
func (r ApiHeadItemImage2Request) Width(width int32) ApiHeadItemImage2Request {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadItemImage2Request) Height(height int32) ApiHeadItemImage2Request {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadItemImage2Request) Quality(quality int32) ApiHeadItemImage2Request {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadItemImage2Request) FillWidth(fillWidth int32) ApiHeadItemImage2Request {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadItemImage2Request) FillHeight(fillHeight int32) ApiHeadItemImage2Request {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadItemImage2Request) Blur(blur int32) ApiHeadItemImage2Request {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadItemImage2Request) BackgroundColor(backgroundColor string) ApiHeadItemImage2Request {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadItemImage2Request) ForegroundLayer(foregroundLayer string) ApiHeadItemImage2Request {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiHeadItemImage2Request) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadItemImage2Execute(r)
}

/*
HeadItemImage2 Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param maxWidth The maximum image width to return.
 @param maxHeight The maximum image height to return.
 @param tag Optional. Supply the cache tag from the item object to receive strong caching headers.
 @param format Determines the output format of the image - original,gif,jpg,png.
 @param percentPlayed Optional. Percent to render for the percent played overlay.
 @param unplayedCount Optional. Unplayed count overlay to render.
 @param imageIndex Image index.
 @return ApiHeadItemImage2Request
*/
func (a *ImageAPIService) HeadItemImage2(ctx context.Context, itemId string, imageType ImageType, maxWidth int32, maxHeight int32, tag string, format ImageFormat, percentPlayed float64, unplayedCount int32, imageIndex int32) ApiHeadItemImage2Request {
	return ApiHeadItemImage2Request{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		maxWidth: maxWidth,
		maxHeight: maxHeight,
		tag: tag,
		format: format,
		percentPlayed: percentPlayed,
		unplayedCount: unplayedCount,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadItemImage2Execute(r ApiHeadItemImage2Request) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadItemImage2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/{tag}/{format}/{maxWidth}/{maxHeight}/{percentPlayed}/{unplayedCount}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxWidth"+"}", url.PathEscape(parameterValueToString(r.maxWidth, "maxWidth")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"maxHeight"+"}", url.PathEscape(parameterValueToString(r.maxHeight, "maxHeight")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"tag"+"}", url.PathEscape(parameterValueToString(r.tag, "tag")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"percentPlayed"+"}", url.PathEscape(parameterValueToString(r.percentPlayed, "percentPlayed")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"unplayedCount"+"}", url.PathEscape(parameterValueToString(r.unplayedCount, "unplayedCount")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadItemImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	imageIndex int32
	maxWidth *int32
	maxHeight *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	tag *string
	format *ImageFormat
	percentPlayed *float64
	unplayedCount *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// The maximum image width to return.
func (r ApiHeadItemImageByIndexRequest) MaxWidth(maxWidth int32) ApiHeadItemImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadItemImageByIndexRequest) MaxHeight(maxHeight int32) ApiHeadItemImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// The fixed image width to return.
func (r ApiHeadItemImageByIndexRequest) Width(width int32) ApiHeadItemImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadItemImageByIndexRequest) Height(height int32) ApiHeadItemImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadItemImageByIndexRequest) Quality(quality int32) ApiHeadItemImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadItemImageByIndexRequest) FillWidth(fillWidth int32) ApiHeadItemImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadItemImageByIndexRequest) FillHeight(fillHeight int32) ApiHeadItemImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadItemImageByIndexRequest) Tag(tag string) ApiHeadItemImageByIndexRequest {
	r.tag = &tag
	return r
}

// Optional. The MediaBrowser.Model.Drawing.ImageFormat of the returned image.
func (r ApiHeadItemImageByIndexRequest) Format(format ImageFormat) ApiHeadItemImageByIndexRequest {
	r.format = &format
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadItemImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiHeadItemImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadItemImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiHeadItemImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// Optional. Blur image.
func (r ApiHeadItemImageByIndexRequest) Blur(blur int32) ApiHeadItemImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadItemImageByIndexRequest) BackgroundColor(backgroundColor string) ApiHeadItemImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadItemImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiHeadItemImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiHeadItemImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadItemImageByIndexExecute(r)
}

/*
HeadItemImageByIndex Gets the item's image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiHeadItemImageByIndexRequest
*/
func (a *ImageAPIService) HeadItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiHeadItemImageByIndexRequest {
	return ApiHeadItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadItemImageByIndexExecute(r ApiHeadItemImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadItemImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadMusicGenreImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadMusicGenreImageRequest) Tag(tag string) ApiHeadMusicGenreImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadMusicGenreImageRequest) Format(format ImageFormat) ApiHeadMusicGenreImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadMusicGenreImageRequest) MaxWidth(maxWidth int32) ApiHeadMusicGenreImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadMusicGenreImageRequest) MaxHeight(maxHeight int32) ApiHeadMusicGenreImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadMusicGenreImageRequest) PercentPlayed(percentPlayed float64) ApiHeadMusicGenreImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadMusicGenreImageRequest) UnplayedCount(unplayedCount int32) ApiHeadMusicGenreImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadMusicGenreImageRequest) Width(width int32) ApiHeadMusicGenreImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadMusicGenreImageRequest) Height(height int32) ApiHeadMusicGenreImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadMusicGenreImageRequest) Quality(quality int32) ApiHeadMusicGenreImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadMusicGenreImageRequest) FillWidth(fillWidth int32) ApiHeadMusicGenreImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadMusicGenreImageRequest) FillHeight(fillHeight int32) ApiHeadMusicGenreImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadMusicGenreImageRequest) Blur(blur int32) ApiHeadMusicGenreImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadMusicGenreImageRequest) BackgroundColor(backgroundColor string) ApiHeadMusicGenreImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadMusicGenreImageRequest) ForegroundLayer(foregroundLayer string) ApiHeadMusicGenreImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiHeadMusicGenreImageRequest) ImageIndex(imageIndex int32) ApiHeadMusicGenreImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiHeadMusicGenreImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMusicGenreImageExecute(r)
}

/*
HeadMusicGenreImage Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @return ApiHeadMusicGenreImageRequest
*/
func (a *ImageAPIService) HeadMusicGenreImage(ctx context.Context, name string, imageType ImageType) ApiHeadMusicGenreImageRequest {
	return ApiHeadMusicGenreImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadMusicGenreImageExecute(r ApiHeadMusicGenreImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadMusicGenreImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadMusicGenreImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadMusicGenreImageByIndexRequest) Tag(tag string) ApiHeadMusicGenreImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadMusicGenreImageByIndexRequest) Format(format ImageFormat) ApiHeadMusicGenreImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadMusicGenreImageByIndexRequest) MaxWidth(maxWidth int32) ApiHeadMusicGenreImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadMusicGenreImageByIndexRequest) MaxHeight(maxHeight int32) ApiHeadMusicGenreImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadMusicGenreImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiHeadMusicGenreImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadMusicGenreImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiHeadMusicGenreImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadMusicGenreImageByIndexRequest) Width(width int32) ApiHeadMusicGenreImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadMusicGenreImageByIndexRequest) Height(height int32) ApiHeadMusicGenreImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadMusicGenreImageByIndexRequest) Quality(quality int32) ApiHeadMusicGenreImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadMusicGenreImageByIndexRequest) FillWidth(fillWidth int32) ApiHeadMusicGenreImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadMusicGenreImageByIndexRequest) FillHeight(fillHeight int32) ApiHeadMusicGenreImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadMusicGenreImageByIndexRequest) Blur(blur int32) ApiHeadMusicGenreImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadMusicGenreImageByIndexRequest) BackgroundColor(backgroundColor string) ApiHeadMusicGenreImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadMusicGenreImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiHeadMusicGenreImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiHeadMusicGenreImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadMusicGenreImageByIndexExecute(r)
}

/*
HeadMusicGenreImageByIndex Get music genre image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Music genre name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiHeadMusicGenreImageByIndexRequest
*/
func (a *ImageAPIService) HeadMusicGenreImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadMusicGenreImageByIndexRequest {
	return ApiHeadMusicGenreImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadMusicGenreImageByIndexExecute(r ApiHeadMusicGenreImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadMusicGenreImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/MusicGenres/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadPersonImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadPersonImageRequest) Tag(tag string) ApiHeadPersonImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadPersonImageRequest) Format(format ImageFormat) ApiHeadPersonImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadPersonImageRequest) MaxWidth(maxWidth int32) ApiHeadPersonImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadPersonImageRequest) MaxHeight(maxHeight int32) ApiHeadPersonImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadPersonImageRequest) PercentPlayed(percentPlayed float64) ApiHeadPersonImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadPersonImageRequest) UnplayedCount(unplayedCount int32) ApiHeadPersonImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadPersonImageRequest) Width(width int32) ApiHeadPersonImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadPersonImageRequest) Height(height int32) ApiHeadPersonImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadPersonImageRequest) Quality(quality int32) ApiHeadPersonImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadPersonImageRequest) FillWidth(fillWidth int32) ApiHeadPersonImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadPersonImageRequest) FillHeight(fillHeight int32) ApiHeadPersonImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadPersonImageRequest) Blur(blur int32) ApiHeadPersonImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadPersonImageRequest) BackgroundColor(backgroundColor string) ApiHeadPersonImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadPersonImageRequest) ForegroundLayer(foregroundLayer string) ApiHeadPersonImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiHeadPersonImageRequest) ImageIndex(imageIndex int32) ApiHeadPersonImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiHeadPersonImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadPersonImageExecute(r)
}

/*
HeadPersonImage Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @return ApiHeadPersonImageRequest
*/
func (a *ImageAPIService) HeadPersonImage(ctx context.Context, name string, imageType ImageType) ApiHeadPersonImageRequest {
	return ApiHeadPersonImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadPersonImageExecute(r ApiHeadPersonImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadPersonImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadPersonImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadPersonImageByIndexRequest) Tag(tag string) ApiHeadPersonImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadPersonImageByIndexRequest) Format(format ImageFormat) ApiHeadPersonImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadPersonImageByIndexRequest) MaxWidth(maxWidth int32) ApiHeadPersonImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadPersonImageByIndexRequest) MaxHeight(maxHeight int32) ApiHeadPersonImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadPersonImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiHeadPersonImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadPersonImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiHeadPersonImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadPersonImageByIndexRequest) Width(width int32) ApiHeadPersonImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadPersonImageByIndexRequest) Height(height int32) ApiHeadPersonImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadPersonImageByIndexRequest) Quality(quality int32) ApiHeadPersonImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadPersonImageByIndexRequest) FillWidth(fillWidth int32) ApiHeadPersonImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadPersonImageByIndexRequest) FillHeight(fillHeight int32) ApiHeadPersonImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadPersonImageByIndexRequest) Blur(blur int32) ApiHeadPersonImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadPersonImageByIndexRequest) BackgroundColor(backgroundColor string) ApiHeadPersonImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadPersonImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiHeadPersonImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiHeadPersonImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadPersonImageByIndexExecute(r)
}

/*
HeadPersonImageByIndex Get person image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Person name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiHeadPersonImageByIndexRequest
*/
func (a *ImageAPIService) HeadPersonImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadPersonImageByIndexRequest {
	return ApiHeadPersonImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadPersonImageByIndexExecute(r ApiHeadPersonImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadPersonImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Persons/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadStudioImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadStudioImageRequest) Tag(tag string) ApiHeadStudioImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadStudioImageRequest) Format(format ImageFormat) ApiHeadStudioImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadStudioImageRequest) MaxWidth(maxWidth int32) ApiHeadStudioImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadStudioImageRequest) MaxHeight(maxHeight int32) ApiHeadStudioImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadStudioImageRequest) PercentPlayed(percentPlayed float64) ApiHeadStudioImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadStudioImageRequest) UnplayedCount(unplayedCount int32) ApiHeadStudioImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadStudioImageRequest) Width(width int32) ApiHeadStudioImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadStudioImageRequest) Height(height int32) ApiHeadStudioImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadStudioImageRequest) Quality(quality int32) ApiHeadStudioImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadStudioImageRequest) FillWidth(fillWidth int32) ApiHeadStudioImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadStudioImageRequest) FillHeight(fillHeight int32) ApiHeadStudioImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadStudioImageRequest) Blur(blur int32) ApiHeadStudioImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadStudioImageRequest) BackgroundColor(backgroundColor string) ApiHeadStudioImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadStudioImageRequest) ForegroundLayer(foregroundLayer string) ApiHeadStudioImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiHeadStudioImageRequest) ImageIndex(imageIndex int32) ApiHeadStudioImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiHeadStudioImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadStudioImageExecute(r)
}

/*
HeadStudioImage Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @return ApiHeadStudioImageRequest
*/
func (a *ImageAPIService) HeadStudioImage(ctx context.Context, name string, imageType ImageType) ApiHeadStudioImageRequest {
	return ApiHeadStudioImageRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadStudioImageExecute(r ApiHeadStudioImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadStudioImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadStudioImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	name string
	imageType ImageType
	imageIndex int32
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadStudioImageByIndexRequest) Tag(tag string) ApiHeadStudioImageByIndexRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadStudioImageByIndexRequest) Format(format ImageFormat) ApiHeadStudioImageByIndexRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadStudioImageByIndexRequest) MaxWidth(maxWidth int32) ApiHeadStudioImageByIndexRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadStudioImageByIndexRequest) MaxHeight(maxHeight int32) ApiHeadStudioImageByIndexRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadStudioImageByIndexRequest) PercentPlayed(percentPlayed float64) ApiHeadStudioImageByIndexRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadStudioImageByIndexRequest) UnplayedCount(unplayedCount int32) ApiHeadStudioImageByIndexRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadStudioImageByIndexRequest) Width(width int32) ApiHeadStudioImageByIndexRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadStudioImageByIndexRequest) Height(height int32) ApiHeadStudioImageByIndexRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadStudioImageByIndexRequest) Quality(quality int32) ApiHeadStudioImageByIndexRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadStudioImageByIndexRequest) FillWidth(fillWidth int32) ApiHeadStudioImageByIndexRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadStudioImageByIndexRequest) FillHeight(fillHeight int32) ApiHeadStudioImageByIndexRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadStudioImageByIndexRequest) Blur(blur int32) ApiHeadStudioImageByIndexRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadStudioImageByIndexRequest) BackgroundColor(backgroundColor string) ApiHeadStudioImageByIndexRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadStudioImageByIndexRequest) ForegroundLayer(foregroundLayer string) ApiHeadStudioImageByIndexRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

func (r ApiHeadStudioImageByIndexRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadStudioImageByIndexExecute(r)
}

/*
HeadStudioImageByIndex Get studio image by name.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name Studio name.
 @param imageType Image type.
 @param imageIndex Image index.
 @return ApiHeadStudioImageByIndexRequest
*/
func (a *ImageAPIService) HeadStudioImageByIndex(ctx context.Context, name string, imageType ImageType, imageIndex int32) ApiHeadStudioImageByIndexRequest {
	return ApiHeadStudioImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadStudioImageByIndexExecute(r ApiHeadStudioImageByIndexRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadStudioImageByIndex")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Studios/{name}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiHeadUserImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	userId *string
	tag *string
	format *ImageFormat
	maxWidth *int32
	maxHeight *int32
	percentPlayed *float64
	unplayedCount *int32
	width *int32
	height *int32
	quality *int32
	fillWidth *int32
	fillHeight *int32
	blur *int32
	backgroundColor *string
	foregroundLayer *string
	imageIndex *int32
}

// User id.
func (r ApiHeadUserImageRequest) UserId(userId string) ApiHeadUserImageRequest {
	r.userId = &userId
	return r
}

// Optional. Supply the cache tag from the item object to receive strong caching headers.
func (r ApiHeadUserImageRequest) Tag(tag string) ApiHeadUserImageRequest {
	r.tag = &tag
	return r
}

// Determines the output format of the image - original,gif,jpg,png.
func (r ApiHeadUserImageRequest) Format(format ImageFormat) ApiHeadUserImageRequest {
	r.format = &format
	return r
}

// The maximum image width to return.
func (r ApiHeadUserImageRequest) MaxWidth(maxWidth int32) ApiHeadUserImageRequest {
	r.maxWidth = &maxWidth
	return r
}

// The maximum image height to return.
func (r ApiHeadUserImageRequest) MaxHeight(maxHeight int32) ApiHeadUserImageRequest {
	r.maxHeight = &maxHeight
	return r
}

// Optional. Percent to render for the percent played overlay.
func (r ApiHeadUserImageRequest) PercentPlayed(percentPlayed float64) ApiHeadUserImageRequest {
	r.percentPlayed = &percentPlayed
	return r
}

// Optional. Unplayed count overlay to render.
func (r ApiHeadUserImageRequest) UnplayedCount(unplayedCount int32) ApiHeadUserImageRequest {
	r.unplayedCount = &unplayedCount
	return r
}

// The fixed image width to return.
func (r ApiHeadUserImageRequest) Width(width int32) ApiHeadUserImageRequest {
	r.width = &width
	return r
}

// The fixed image height to return.
func (r ApiHeadUserImageRequest) Height(height int32) ApiHeadUserImageRequest {
	r.height = &height
	return r
}

// Optional. Quality setting, from 0-100. Defaults to 90 and should suffice in most cases.
func (r ApiHeadUserImageRequest) Quality(quality int32) ApiHeadUserImageRequest {
	r.quality = &quality
	return r
}

// Width of box to fill.
func (r ApiHeadUserImageRequest) FillWidth(fillWidth int32) ApiHeadUserImageRequest {
	r.fillWidth = &fillWidth
	return r
}

// Height of box to fill.
func (r ApiHeadUserImageRequest) FillHeight(fillHeight int32) ApiHeadUserImageRequest {
	r.fillHeight = &fillHeight
	return r
}

// Optional. Blur image.
func (r ApiHeadUserImageRequest) Blur(blur int32) ApiHeadUserImageRequest {
	r.blur = &blur
	return r
}

// Optional. Apply a background color for transparent images.
func (r ApiHeadUserImageRequest) BackgroundColor(backgroundColor string) ApiHeadUserImageRequest {
	r.backgroundColor = &backgroundColor
	return r
}

// Optional. Apply a foreground layer on top of the image.
func (r ApiHeadUserImageRequest) ForegroundLayer(foregroundLayer string) ApiHeadUserImageRequest {
	r.foregroundLayer = &foregroundLayer
	return r
}

// Image index.
func (r ApiHeadUserImageRequest) ImageIndex(imageIndex int32) ApiHeadUserImageRequest {
	r.imageIndex = &imageIndex
	return r
}

func (r ApiHeadUserImageRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.HeadUserImageExecute(r)
}

/*
HeadUserImage Get user profile image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiHeadUserImageRequest
*/
func (a *ImageAPIService) HeadUserImage(ctx context.Context) ApiHeadUserImageRequest {
	return ApiHeadUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ImageAPIService) HeadUserImageExecute(r ApiHeadUserImageRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodHead
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.HeadUserImage")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.tag != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tag", r.tag, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.maxWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxWidth", r.maxWidth, "form", "")
	}
	if r.maxHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxHeight", r.maxHeight, "form", "")
	}
	if r.percentPlayed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "percentPlayed", r.percentPlayed, "form", "")
	}
	if r.unplayedCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "unplayedCount", r.unplayedCount, "form", "")
	}
	if r.width != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "width", r.width, "form", "")
	}
	if r.height != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "height", r.height, "form", "")
	}
	if r.quality != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quality", r.quality, "form", "")
	}
	if r.fillWidth != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillWidth", r.fillWidth, "form", "")
	}
	if r.fillHeight != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fillHeight", r.fillHeight, "form", "")
	}
	if r.blur != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "blur", r.blur, "form", "")
	}
	if r.backgroundColor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "backgroundColor", r.backgroundColor, "form", "")
	}
	if r.foregroundLayer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "foregroundLayer", r.foregroundLayer, "form", "")
	}
	if r.imageIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageIndex", r.imageIndex, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPostUserImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	userId *string
	body *os.File
}

// User Id.
func (r ApiPostUserImageRequest) UserId(userId string) ApiPostUserImageRequest {
	r.userId = &userId
	return r
}

func (r ApiPostUserImageRequest) Body(body *os.File) ApiPostUserImageRequest {
	r.body = body
	return r
}

func (r ApiPostUserImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.PostUserImageExecute(r)
}

/*
PostUserImage Sets the user image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPostUserImageRequest
*/
func (a *ImageAPIService) PostUserImage(ctx context.Context) ApiPostUserImageRequest {
	return ApiPostUserImageRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) PostUserImageExecute(r ApiPostUserImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.PostUserImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/UserImage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetItemImageRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	body *os.File
}

func (r ApiSetItemImageRequest) Body(body *os.File) ApiSetItemImageRequest {
	r.body = body
	return r
}

func (r ApiSetItemImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetItemImageExecute(r)
}

/*
SetItemImage Set item image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @return ApiSetItemImageRequest
*/
func (a *ImageAPIService) SetItemImage(ctx context.Context, itemId string, imageType ImageType) ApiSetItemImageRequest {
	return ApiSetItemImageRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
	}
}

// Execute executes the request
func (a *ImageAPIService) SetItemImageExecute(r ApiSetItemImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.SetItemImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetItemImageByIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	imageIndex int32
	body *os.File
}

func (r ApiSetItemImageByIndexRequest) Body(body *os.File) ApiSetItemImageByIndexRequest {
	r.body = body
	return r
}

func (r ApiSetItemImageByIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.SetItemImageByIndexExecute(r)
}

/*
SetItemImageByIndex Set item image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex (Unused) Image index.
 @return ApiSetItemImageByIndexRequest
*/
func (a *ImageAPIService) SetItemImageByIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiSetItemImageByIndexRequest {
	return ApiSetItemImageByIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
func (a *ImageAPIService) SetItemImageByIndexExecute(r ApiSetItemImageByIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.SetItemImageByIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateItemImageIndexRequest struct {
	ctx context.Context
	ApiService ImageAPI
	itemId string
	imageType ImageType
	imageIndex int32
	newIndex *int32
}

// New image index.
func (r ApiUpdateItemImageIndexRequest) NewIndex(newIndex int32) ApiUpdateItemImageIndexRequest {
	r.newIndex = &newIndex
	return r
}

func (r ApiUpdateItemImageIndexRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateItemImageIndexExecute(r)
}

/*
UpdateItemImageIndex Updates the index for an item image.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @param imageType Image type.
 @param imageIndex Old image index.
 @return ApiUpdateItemImageIndexRequest
*/
func (a *ImageAPIService) UpdateItemImageIndex(ctx context.Context, itemId string, imageType ImageType, imageIndex int32) ApiUpdateItemImageIndexRequest {
	return ApiUpdateItemImageIndexRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
		imageType: imageType,
		imageIndex: imageIndex,
	}
}

// Execute executes the request
func (a *ImageAPIService) UpdateItemImageIndexExecute(r ApiUpdateItemImageIndexRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.UpdateItemImageIndex")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/Images/{imageType}/{imageIndex}/Index"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageType"+"}", url.PathEscape(parameterValueToString(r.imageType, "imageType")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"imageIndex"+"}", url.PathEscape(parameterValueToString(r.imageIndex, "imageIndex")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newIndex == nil {
		return nil, reportError("newIndex is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "newIndex", r.newIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUploadCustomSplashscreenRequest struct {
	ctx context.Context
	ApiService ImageAPI
	body *os.File
}

func (r ApiUploadCustomSplashscreenRequest) Body(body *os.File) ApiUploadCustomSplashscreenRequest {
	r.body = body
	return r
}

func (r ApiUploadCustomSplashscreenRequest) Execute() (*http.Response, error) {
	return r.ApiService.UploadCustomSplashscreenExecute(r)
}

/*
UploadCustomSplashscreen Uploads a custom splashscreen.  The body is expected to the image contents base64 encoded.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUploadCustomSplashscreenRequest
*/
func (a *ImageAPIService) UploadCustomSplashscreen(ctx context.Context) ApiUploadCustomSplashscreenRequest {
	return ApiUploadCustomSplashscreenRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *ImageAPIService) UploadCustomSplashscreenExecute(r ApiUploadCustomSplashscreenRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ImageAPIService.UploadCustomSplashscreen")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Branding/Splashscreen"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"image/*"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

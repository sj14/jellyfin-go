/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


type SyncPlayAPI interface {

	/*
	SyncPlayBuffering Notify SyncPlay group that member is buffering.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayBufferingRequest
	*/
	SyncPlayBuffering(ctx context.Context) ApiSyncPlayBufferingRequest

	// SyncPlayBufferingExecute executes the request
	SyncPlayBufferingExecute(r ApiSyncPlayBufferingRequest) (*http.Response, error)

	/*
	SyncPlayCreateGroup Create a new SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayCreateGroupRequest
	*/
	SyncPlayCreateGroup(ctx context.Context) ApiSyncPlayCreateGroupRequest

	// SyncPlayCreateGroupExecute executes the request
	SyncPlayCreateGroupExecute(r ApiSyncPlayCreateGroupRequest) (*http.Response, error)

	/*
	SyncPlayGetGroups Gets all SyncPlay groups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayGetGroupsRequest
	*/
	SyncPlayGetGroups(ctx context.Context) ApiSyncPlayGetGroupsRequest

	// SyncPlayGetGroupsExecute executes the request
	//  @return []GroupInfoDto
	SyncPlayGetGroupsExecute(r ApiSyncPlayGetGroupsRequest) ([]GroupInfoDto, *http.Response, error)

	/*
	SyncPlayJoinGroup Join an existing SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayJoinGroupRequest
	*/
	SyncPlayJoinGroup(ctx context.Context) ApiSyncPlayJoinGroupRequest

	// SyncPlayJoinGroupExecute executes the request
	SyncPlayJoinGroupExecute(r ApiSyncPlayJoinGroupRequest) (*http.Response, error)

	/*
	SyncPlayLeaveGroup Leave the joined SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayLeaveGroupRequest
	*/
	SyncPlayLeaveGroup(ctx context.Context) ApiSyncPlayLeaveGroupRequest

	// SyncPlayLeaveGroupExecute executes the request
	SyncPlayLeaveGroupExecute(r ApiSyncPlayLeaveGroupRequest) (*http.Response, error)

	/*
	SyncPlayMovePlaylistItem Request to move an item in the playlist in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayMovePlaylistItemRequest
	*/
	SyncPlayMovePlaylistItem(ctx context.Context) ApiSyncPlayMovePlaylistItemRequest

	// SyncPlayMovePlaylistItemExecute executes the request
	SyncPlayMovePlaylistItemExecute(r ApiSyncPlayMovePlaylistItemRequest) (*http.Response, error)

	/*
	SyncPlayNextItem Request next item in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayNextItemRequest
	*/
	SyncPlayNextItem(ctx context.Context) ApiSyncPlayNextItemRequest

	// SyncPlayNextItemExecute executes the request
	SyncPlayNextItemExecute(r ApiSyncPlayNextItemRequest) (*http.Response, error)

	/*
	SyncPlayPause Request pause in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayPauseRequest
	*/
	SyncPlayPause(ctx context.Context) ApiSyncPlayPauseRequest

	// SyncPlayPauseExecute executes the request
	SyncPlayPauseExecute(r ApiSyncPlayPauseRequest) (*http.Response, error)

	/*
	SyncPlayPing Update session ping.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayPingRequest
	*/
	SyncPlayPing(ctx context.Context) ApiSyncPlayPingRequest

	// SyncPlayPingExecute executes the request
	SyncPlayPingExecute(r ApiSyncPlayPingRequest) (*http.Response, error)

	/*
	SyncPlayPreviousItem Request previous item in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayPreviousItemRequest
	*/
	SyncPlayPreviousItem(ctx context.Context) ApiSyncPlayPreviousItemRequest

	// SyncPlayPreviousItemExecute executes the request
	SyncPlayPreviousItemExecute(r ApiSyncPlayPreviousItemRequest) (*http.Response, error)

	/*
	SyncPlayQueue Request to queue items to the playlist of a SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayQueueRequest
	*/
	SyncPlayQueue(ctx context.Context) ApiSyncPlayQueueRequest

	// SyncPlayQueueExecute executes the request
	SyncPlayQueueExecute(r ApiSyncPlayQueueRequest) (*http.Response, error)

	/*
	SyncPlayReady Notify SyncPlay group that member is ready for playback.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayReadyRequest
	*/
	SyncPlayReady(ctx context.Context) ApiSyncPlayReadyRequest

	// SyncPlayReadyExecute executes the request
	SyncPlayReadyExecute(r ApiSyncPlayReadyRequest) (*http.Response, error)

	/*
	SyncPlayRemoveFromPlaylist Request to remove items from the playlist in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayRemoveFromPlaylistRequest
	*/
	SyncPlayRemoveFromPlaylist(ctx context.Context) ApiSyncPlayRemoveFromPlaylistRequest

	// SyncPlayRemoveFromPlaylistExecute executes the request
	SyncPlayRemoveFromPlaylistExecute(r ApiSyncPlayRemoveFromPlaylistRequest) (*http.Response, error)

	/*
	SyncPlaySeek Request seek in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlaySeekRequest
	*/
	SyncPlaySeek(ctx context.Context) ApiSyncPlaySeekRequest

	// SyncPlaySeekExecute executes the request
	SyncPlaySeekExecute(r ApiSyncPlaySeekRequest) (*http.Response, error)

	/*
	SyncPlaySetIgnoreWait Request SyncPlay group to ignore member during group-wait.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlaySetIgnoreWaitRequest
	*/
	SyncPlaySetIgnoreWait(ctx context.Context) ApiSyncPlaySetIgnoreWaitRequest

	// SyncPlaySetIgnoreWaitExecute executes the request
	SyncPlaySetIgnoreWaitExecute(r ApiSyncPlaySetIgnoreWaitRequest) (*http.Response, error)

	/*
	SyncPlaySetNewQueue Request to set new playlist in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlaySetNewQueueRequest
	*/
	SyncPlaySetNewQueue(ctx context.Context) ApiSyncPlaySetNewQueueRequest

	// SyncPlaySetNewQueueExecute executes the request
	SyncPlaySetNewQueueExecute(r ApiSyncPlaySetNewQueueRequest) (*http.Response, error)

	/*
	SyncPlaySetPlaylistItem Request to change playlist item in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlaySetPlaylistItemRequest
	*/
	SyncPlaySetPlaylistItem(ctx context.Context) ApiSyncPlaySetPlaylistItemRequest

	// SyncPlaySetPlaylistItemExecute executes the request
	SyncPlaySetPlaylistItemExecute(r ApiSyncPlaySetPlaylistItemRequest) (*http.Response, error)

	/*
	SyncPlaySetRepeatMode Request to set repeat mode in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlaySetRepeatModeRequest
	*/
	SyncPlaySetRepeatMode(ctx context.Context) ApiSyncPlaySetRepeatModeRequest

	// SyncPlaySetRepeatModeExecute executes the request
	SyncPlaySetRepeatModeExecute(r ApiSyncPlaySetRepeatModeRequest) (*http.Response, error)

	/*
	SyncPlaySetShuffleMode Request to set shuffle mode in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlaySetShuffleModeRequest
	*/
	SyncPlaySetShuffleMode(ctx context.Context) ApiSyncPlaySetShuffleModeRequest

	// SyncPlaySetShuffleModeExecute executes the request
	SyncPlaySetShuffleModeExecute(r ApiSyncPlaySetShuffleModeRequest) (*http.Response, error)

	/*
	SyncPlayStop Request stop in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayStopRequest
	*/
	SyncPlayStop(ctx context.Context) ApiSyncPlayStopRequest

	// SyncPlayStopExecute executes the request
	SyncPlayStopExecute(r ApiSyncPlayStopRequest) (*http.Response, error)

	/*
	SyncPlayUnpause Request unpause in SyncPlay group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSyncPlayUnpauseRequest
	*/
	SyncPlayUnpause(ctx context.Context) ApiSyncPlayUnpauseRequest

	// SyncPlayUnpauseExecute executes the request
	SyncPlayUnpauseExecute(r ApiSyncPlayUnpauseRequest) (*http.Response, error)
}

// SyncPlayAPIService SyncPlayAPI service
type SyncPlayAPIService service

type ApiSyncPlayBufferingRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	bufferRequestDto *BufferRequestDto
}

// The player status.
func (r ApiSyncPlayBufferingRequest) BufferRequestDto(bufferRequestDto BufferRequestDto) ApiSyncPlayBufferingRequest {
	r.bufferRequestDto = &bufferRequestDto
	return r
}

func (r ApiSyncPlayBufferingRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayBufferingExecute(r)
}

/*
SyncPlayBuffering Notify SyncPlay group that member is buffering.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayBufferingRequest
*/
func (a *SyncPlayAPIService) SyncPlayBuffering(ctx context.Context) ApiSyncPlayBufferingRequest {
	return ApiSyncPlayBufferingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayBufferingExecute(r ApiSyncPlayBufferingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayBuffering")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Buffering"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bufferRequestDto == nil {
		return nil, reportError("bufferRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bufferRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayCreateGroupRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	newGroupRequestDto *NewGroupRequestDto
}

// The settings of the new group.
func (r ApiSyncPlayCreateGroupRequest) NewGroupRequestDto(newGroupRequestDto NewGroupRequestDto) ApiSyncPlayCreateGroupRequest {
	r.newGroupRequestDto = &newGroupRequestDto
	return r
}

func (r ApiSyncPlayCreateGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayCreateGroupExecute(r)
}

/*
SyncPlayCreateGroup Create a new SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayCreateGroupRequest
*/
func (a *SyncPlayAPIService) SyncPlayCreateGroup(ctx context.Context) ApiSyncPlayCreateGroupRequest {
	return ApiSyncPlayCreateGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayCreateGroupExecute(r ApiSyncPlayCreateGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayCreateGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/New"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.newGroupRequestDto == nil {
		return nil, reportError("newGroupRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.newGroupRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayGetGroupsRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
}

func (r ApiSyncPlayGetGroupsRequest) Execute() ([]GroupInfoDto, *http.Response, error) {
	return r.ApiService.SyncPlayGetGroupsExecute(r)
}

/*
SyncPlayGetGroups Gets all SyncPlay groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayGetGroupsRequest
*/
func (a *SyncPlayAPIService) SyncPlayGetGroups(ctx context.Context) ApiSyncPlayGetGroupsRequest {
	return ApiSyncPlayGetGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []GroupInfoDto
func (a *SyncPlayAPIService) SyncPlayGetGroupsExecute(r ApiSyncPlayGetGroupsRequest) ([]GroupInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []GroupInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayGetGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/List"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSyncPlayJoinGroupRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	joinGroupRequestDto *JoinGroupRequestDto
}

// The group to join.
func (r ApiSyncPlayJoinGroupRequest) JoinGroupRequestDto(joinGroupRequestDto JoinGroupRequestDto) ApiSyncPlayJoinGroupRequest {
	r.joinGroupRequestDto = &joinGroupRequestDto
	return r
}

func (r ApiSyncPlayJoinGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayJoinGroupExecute(r)
}

/*
SyncPlayJoinGroup Join an existing SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayJoinGroupRequest
*/
func (a *SyncPlayAPIService) SyncPlayJoinGroup(ctx context.Context) ApiSyncPlayJoinGroupRequest {
	return ApiSyncPlayJoinGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayJoinGroupExecute(r ApiSyncPlayJoinGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayJoinGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Join"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.joinGroupRequestDto == nil {
		return nil, reportError("joinGroupRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.joinGroupRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayLeaveGroupRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
}

func (r ApiSyncPlayLeaveGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayLeaveGroupExecute(r)
}

/*
SyncPlayLeaveGroup Leave the joined SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayLeaveGroupRequest
*/
func (a *SyncPlayAPIService) SyncPlayLeaveGroup(ctx context.Context) ApiSyncPlayLeaveGroupRequest {
	return ApiSyncPlayLeaveGroupRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayLeaveGroupExecute(r ApiSyncPlayLeaveGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayLeaveGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Leave"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayMovePlaylistItemRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	movePlaylistItemRequestDto *MovePlaylistItemRequestDto
}

// The new position for the item.
func (r ApiSyncPlayMovePlaylistItemRequest) MovePlaylistItemRequestDto(movePlaylistItemRequestDto MovePlaylistItemRequestDto) ApiSyncPlayMovePlaylistItemRequest {
	r.movePlaylistItemRequestDto = &movePlaylistItemRequestDto
	return r
}

func (r ApiSyncPlayMovePlaylistItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayMovePlaylistItemExecute(r)
}

/*
SyncPlayMovePlaylistItem Request to move an item in the playlist in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayMovePlaylistItemRequest
*/
func (a *SyncPlayAPIService) SyncPlayMovePlaylistItem(ctx context.Context) ApiSyncPlayMovePlaylistItemRequest {
	return ApiSyncPlayMovePlaylistItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayMovePlaylistItemExecute(r ApiSyncPlayMovePlaylistItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayMovePlaylistItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/MovePlaylistItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.movePlaylistItemRequestDto == nil {
		return nil, reportError("movePlaylistItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.movePlaylistItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayNextItemRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	nextItemRequestDto *NextItemRequestDto
}

// The current item information.
func (r ApiSyncPlayNextItemRequest) NextItemRequestDto(nextItemRequestDto NextItemRequestDto) ApiSyncPlayNextItemRequest {
	r.nextItemRequestDto = &nextItemRequestDto
	return r
}

func (r ApiSyncPlayNextItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayNextItemExecute(r)
}

/*
SyncPlayNextItem Request next item in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayNextItemRequest
*/
func (a *SyncPlayAPIService) SyncPlayNextItem(ctx context.Context) ApiSyncPlayNextItemRequest {
	return ApiSyncPlayNextItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayNextItemExecute(r ApiSyncPlayNextItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayNextItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/NextItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.nextItemRequestDto == nil {
		return nil, reportError("nextItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.nextItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayPauseRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
}

func (r ApiSyncPlayPauseRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayPauseExecute(r)
}

/*
SyncPlayPause Request pause in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayPauseRequest
*/
func (a *SyncPlayAPIService) SyncPlayPause(ctx context.Context) ApiSyncPlayPauseRequest {
	return ApiSyncPlayPauseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayPauseExecute(r ApiSyncPlayPauseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayPause")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Pause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayPingRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	pingRequestDto *PingRequestDto
}

// The new ping.
func (r ApiSyncPlayPingRequest) PingRequestDto(pingRequestDto PingRequestDto) ApiSyncPlayPingRequest {
	r.pingRequestDto = &pingRequestDto
	return r
}

func (r ApiSyncPlayPingRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayPingExecute(r)
}

/*
SyncPlayPing Update session ping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayPingRequest
*/
func (a *SyncPlayAPIService) SyncPlayPing(ctx context.Context) ApiSyncPlayPingRequest {
	return ApiSyncPlayPingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayPingExecute(r ApiSyncPlayPingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayPing")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Ping"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pingRequestDto == nil {
		return nil, reportError("pingRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.pingRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayPreviousItemRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	previousItemRequestDto *PreviousItemRequestDto
}

// The current item information.
func (r ApiSyncPlayPreviousItemRequest) PreviousItemRequestDto(previousItemRequestDto PreviousItemRequestDto) ApiSyncPlayPreviousItemRequest {
	r.previousItemRequestDto = &previousItemRequestDto
	return r
}

func (r ApiSyncPlayPreviousItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayPreviousItemExecute(r)
}

/*
SyncPlayPreviousItem Request previous item in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayPreviousItemRequest
*/
func (a *SyncPlayAPIService) SyncPlayPreviousItem(ctx context.Context) ApiSyncPlayPreviousItemRequest {
	return ApiSyncPlayPreviousItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayPreviousItemExecute(r ApiSyncPlayPreviousItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayPreviousItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/PreviousItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.previousItemRequestDto == nil {
		return nil, reportError("previousItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.previousItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayQueueRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	queueRequestDto *QueueRequestDto
}

// The items to add.
func (r ApiSyncPlayQueueRequest) QueueRequestDto(queueRequestDto QueueRequestDto) ApiSyncPlayQueueRequest {
	r.queueRequestDto = &queueRequestDto
	return r
}

func (r ApiSyncPlayQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayQueueExecute(r)
}

/*
SyncPlayQueue Request to queue items to the playlist of a SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayQueueRequest
*/
func (a *SyncPlayAPIService) SyncPlayQueue(ctx context.Context) ApiSyncPlayQueueRequest {
	return ApiSyncPlayQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayQueueExecute(r ApiSyncPlayQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Queue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queueRequestDto == nil {
		return nil, reportError("queueRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queueRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayReadyRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	readyRequestDto *ReadyRequestDto
}

// The player status.
func (r ApiSyncPlayReadyRequest) ReadyRequestDto(readyRequestDto ReadyRequestDto) ApiSyncPlayReadyRequest {
	r.readyRequestDto = &readyRequestDto
	return r
}

func (r ApiSyncPlayReadyRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayReadyExecute(r)
}

/*
SyncPlayReady Notify SyncPlay group that member is ready for playback.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayReadyRequest
*/
func (a *SyncPlayAPIService) SyncPlayReady(ctx context.Context) ApiSyncPlayReadyRequest {
	return ApiSyncPlayReadyRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayReadyExecute(r ApiSyncPlayReadyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayReady")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Ready"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.readyRequestDto == nil {
		return nil, reportError("readyRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.readyRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayRemoveFromPlaylistRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	removeFromPlaylistRequestDto *RemoveFromPlaylistRequestDto
}

// The items to remove.
func (r ApiSyncPlayRemoveFromPlaylistRequest) RemoveFromPlaylistRequestDto(removeFromPlaylistRequestDto RemoveFromPlaylistRequestDto) ApiSyncPlayRemoveFromPlaylistRequest {
	r.removeFromPlaylistRequestDto = &removeFromPlaylistRequestDto
	return r
}

func (r ApiSyncPlayRemoveFromPlaylistRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayRemoveFromPlaylistExecute(r)
}

/*
SyncPlayRemoveFromPlaylist Request to remove items from the playlist in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayRemoveFromPlaylistRequest
*/
func (a *SyncPlayAPIService) SyncPlayRemoveFromPlaylist(ctx context.Context) ApiSyncPlayRemoveFromPlaylistRequest {
	return ApiSyncPlayRemoveFromPlaylistRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayRemoveFromPlaylistExecute(r ApiSyncPlayRemoveFromPlaylistRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayRemoveFromPlaylist")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/RemoveFromPlaylist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.removeFromPlaylistRequestDto == nil {
		return nil, reportError("removeFromPlaylistRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.removeFromPlaylistRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlaySeekRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	seekRequestDto *SeekRequestDto
}

// The new playback position.
func (r ApiSyncPlaySeekRequest) SeekRequestDto(seekRequestDto SeekRequestDto) ApiSyncPlaySeekRequest {
	r.seekRequestDto = &seekRequestDto
	return r
}

func (r ApiSyncPlaySeekRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySeekExecute(r)
}

/*
SyncPlaySeek Request seek in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlaySeekRequest
*/
func (a *SyncPlayAPIService) SyncPlaySeek(ctx context.Context) ApiSyncPlaySeekRequest {
	return ApiSyncPlaySeekRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySeekExecute(r ApiSyncPlaySeekRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySeek")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Seek"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.seekRequestDto == nil {
		return nil, reportError("seekRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.seekRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlaySetIgnoreWaitRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	ignoreWaitRequestDto *IgnoreWaitRequestDto
}

// The settings to set.
func (r ApiSyncPlaySetIgnoreWaitRequest) IgnoreWaitRequestDto(ignoreWaitRequestDto IgnoreWaitRequestDto) ApiSyncPlaySetIgnoreWaitRequest {
	r.ignoreWaitRequestDto = &ignoreWaitRequestDto
	return r
}

func (r ApiSyncPlaySetIgnoreWaitRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetIgnoreWaitExecute(r)
}

/*
SyncPlaySetIgnoreWait Request SyncPlay group to ignore member during group-wait.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlaySetIgnoreWaitRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetIgnoreWait(ctx context.Context) ApiSyncPlaySetIgnoreWaitRequest {
	return ApiSyncPlaySetIgnoreWaitRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetIgnoreWaitExecute(r ApiSyncPlaySetIgnoreWaitRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetIgnoreWait")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetIgnoreWait"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.ignoreWaitRequestDto == nil {
		return nil, reportError("ignoreWaitRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ignoreWaitRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlaySetNewQueueRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	playRequestDto *PlayRequestDto
}

// The new playlist to play in the group.
func (r ApiSyncPlaySetNewQueueRequest) PlayRequestDto(playRequestDto PlayRequestDto) ApiSyncPlaySetNewQueueRequest {
	r.playRequestDto = &playRequestDto
	return r
}

func (r ApiSyncPlaySetNewQueueRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetNewQueueExecute(r)
}

/*
SyncPlaySetNewQueue Request to set new playlist in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlaySetNewQueueRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetNewQueue(ctx context.Context) ApiSyncPlaySetNewQueueRequest {
	return ApiSyncPlaySetNewQueueRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetNewQueueExecute(r ApiSyncPlaySetNewQueueRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetNewQueue")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetNewQueue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.playRequestDto == nil {
		return nil, reportError("playRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.playRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlaySetPlaylistItemRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	setPlaylistItemRequestDto *SetPlaylistItemRequestDto
}

// The new item to play.
func (r ApiSyncPlaySetPlaylistItemRequest) SetPlaylistItemRequestDto(setPlaylistItemRequestDto SetPlaylistItemRequestDto) ApiSyncPlaySetPlaylistItemRequest {
	r.setPlaylistItemRequestDto = &setPlaylistItemRequestDto
	return r
}

func (r ApiSyncPlaySetPlaylistItemRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetPlaylistItemExecute(r)
}

/*
SyncPlaySetPlaylistItem Request to change playlist item in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlaySetPlaylistItemRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetPlaylistItem(ctx context.Context) ApiSyncPlaySetPlaylistItemRequest {
	return ApiSyncPlaySetPlaylistItemRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetPlaylistItemExecute(r ApiSyncPlaySetPlaylistItemRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetPlaylistItem")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetPlaylistItem"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setPlaylistItemRequestDto == nil {
		return nil, reportError("setPlaylistItemRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setPlaylistItemRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlaySetRepeatModeRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	setRepeatModeRequestDto *SetRepeatModeRequestDto
}

// The new repeat mode.
func (r ApiSyncPlaySetRepeatModeRequest) SetRepeatModeRequestDto(setRepeatModeRequestDto SetRepeatModeRequestDto) ApiSyncPlaySetRepeatModeRequest {
	r.setRepeatModeRequestDto = &setRepeatModeRequestDto
	return r
}

func (r ApiSyncPlaySetRepeatModeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetRepeatModeExecute(r)
}

/*
SyncPlaySetRepeatMode Request to set repeat mode in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlaySetRepeatModeRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetRepeatMode(ctx context.Context) ApiSyncPlaySetRepeatModeRequest {
	return ApiSyncPlaySetRepeatModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetRepeatModeExecute(r ApiSyncPlaySetRepeatModeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetRepeatMode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetRepeatMode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setRepeatModeRequestDto == nil {
		return nil, reportError("setRepeatModeRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setRepeatModeRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlaySetShuffleModeRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
	setShuffleModeRequestDto *SetShuffleModeRequestDto
}

// The new shuffle mode.
func (r ApiSyncPlaySetShuffleModeRequest) SetShuffleModeRequestDto(setShuffleModeRequestDto SetShuffleModeRequestDto) ApiSyncPlaySetShuffleModeRequest {
	r.setShuffleModeRequestDto = &setShuffleModeRequestDto
	return r
}

func (r ApiSyncPlaySetShuffleModeRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlaySetShuffleModeExecute(r)
}

/*
SyncPlaySetShuffleMode Request to set shuffle mode in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlaySetShuffleModeRequest
*/
func (a *SyncPlayAPIService) SyncPlaySetShuffleMode(ctx context.Context) ApiSyncPlaySetShuffleModeRequest {
	return ApiSyncPlaySetShuffleModeRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlaySetShuffleModeExecute(r ApiSyncPlaySetShuffleModeRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlaySetShuffleMode")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/SetShuffleMode"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setShuffleModeRequestDto == nil {
		return nil, reportError("setShuffleModeRequestDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setShuffleModeRequestDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayStopRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
}

func (r ApiSyncPlayStopRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayStopExecute(r)
}

/*
SyncPlayStop Request stop in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayStopRequest
*/
func (a *SyncPlayAPIService) SyncPlayStop(ctx context.Context) ApiSyncPlayStopRequest {
	return ApiSyncPlayStopRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayStopExecute(r ApiSyncPlayStopRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayStop")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSyncPlayUnpauseRequest struct {
	ctx context.Context
	ApiService SyncPlayAPI
}

func (r ApiSyncPlayUnpauseRequest) Execute() (*http.Response, error) {
	return r.ApiService.SyncPlayUnpauseExecute(r)
}

/*
SyncPlayUnpause Request unpause in SyncPlay group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSyncPlayUnpauseRequest
*/
func (a *SyncPlayAPIService) SyncPlayUnpause(ctx context.Context) ApiSyncPlayUnpauseRequest {
	return ApiSyncPlayUnpauseRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *SyncPlayAPIService) SyncPlayUnpauseExecute(r ApiSyncPlayUnpauseRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SyncPlayAPIService.SyncPlayUnpause")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/SyncPlay/Unpause"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.11.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type ItemLookupAPI interface {

	/*
	ApplySearchCriteria Applies search criteria to an item and refreshes metadata.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@return ApiApplySearchCriteriaRequest
	*/
	ApplySearchCriteria(ctx context.Context, itemId string) ApiApplySearchCriteriaRequest

	// ApplySearchCriteriaExecute executes the request
	ApplySearchCriteriaExecute(r ApiApplySearchCriteriaRequest) (*http.Response, error)

	/*
	GetBookRemoteSearchResults Get book remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBookRemoteSearchResultsRequest
	*/
	GetBookRemoteSearchResults(ctx context.Context) ApiGetBookRemoteSearchResultsRequest

	// GetBookRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetBookRemoteSearchResultsExecute(r ApiGetBookRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetBoxSetRemoteSearchResults Get box set remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetBoxSetRemoteSearchResultsRequest
	*/
	GetBoxSetRemoteSearchResults(ctx context.Context) ApiGetBoxSetRemoteSearchResultsRequest

	// GetBoxSetRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetBoxSetRemoteSearchResultsExecute(r ApiGetBoxSetRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetExternalIdInfos Get the item's external id info.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param itemId Item id.
	@return ApiGetExternalIdInfosRequest
	*/
	GetExternalIdInfos(ctx context.Context, itemId string) ApiGetExternalIdInfosRequest

	// GetExternalIdInfosExecute executes the request
	//  @return []ExternalIdInfo
	GetExternalIdInfosExecute(r ApiGetExternalIdInfosRequest) ([]ExternalIdInfo, *http.Response, error)

	/*
	GetMovieRemoteSearchResults Get movie remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMovieRemoteSearchResultsRequest
	*/
	GetMovieRemoteSearchResults(ctx context.Context) ApiGetMovieRemoteSearchResultsRequest

	// GetMovieRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetMovieRemoteSearchResultsExecute(r ApiGetMovieRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetMusicAlbumRemoteSearchResults Get music album remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMusicAlbumRemoteSearchResultsRequest
	*/
	GetMusicAlbumRemoteSearchResults(ctx context.Context) ApiGetMusicAlbumRemoteSearchResultsRequest

	// GetMusicAlbumRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetMusicAlbumRemoteSearchResultsExecute(r ApiGetMusicAlbumRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetMusicArtistRemoteSearchResults Get music artist remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMusicArtistRemoteSearchResultsRequest
	*/
	GetMusicArtistRemoteSearchResults(ctx context.Context) ApiGetMusicArtistRemoteSearchResultsRequest

	// GetMusicArtistRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetMusicArtistRemoteSearchResultsExecute(r ApiGetMusicArtistRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetMusicVideoRemoteSearchResults Get music video remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetMusicVideoRemoteSearchResultsRequest
	*/
	GetMusicVideoRemoteSearchResults(ctx context.Context) ApiGetMusicVideoRemoteSearchResultsRequest

	// GetMusicVideoRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetMusicVideoRemoteSearchResultsExecute(r ApiGetMusicVideoRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetPersonRemoteSearchResults Get person remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetPersonRemoteSearchResultsRequest
	*/
	GetPersonRemoteSearchResults(ctx context.Context) ApiGetPersonRemoteSearchResultsRequest

	// GetPersonRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetPersonRemoteSearchResultsExecute(r ApiGetPersonRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetSeriesRemoteSearchResults Get series remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSeriesRemoteSearchResultsRequest
	*/
	GetSeriesRemoteSearchResults(ctx context.Context) ApiGetSeriesRemoteSearchResultsRequest

	// GetSeriesRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetSeriesRemoteSearchResultsExecute(r ApiGetSeriesRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)

	/*
	GetTrailerRemoteSearchResults Get trailer remote search.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTrailerRemoteSearchResultsRequest
	*/
	GetTrailerRemoteSearchResults(ctx context.Context) ApiGetTrailerRemoteSearchResultsRequest

	// GetTrailerRemoteSearchResultsExecute executes the request
	//  @return []RemoteSearchResult
	GetTrailerRemoteSearchResultsExecute(r ApiGetTrailerRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error)
}

// ItemLookupAPIService ItemLookupAPI service
type ItemLookupAPIService service

type ApiApplySearchCriteriaRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	itemId string
	remoteSearchResult *RemoteSearchResult
	replaceAllImages *bool
}

// The remote search result.
func (r ApiApplySearchCriteriaRequest) RemoteSearchResult(remoteSearchResult RemoteSearchResult) ApiApplySearchCriteriaRequest {
	r.remoteSearchResult = &remoteSearchResult
	return r
}

// Optional. Whether or not to replace all images. Default: True.
func (r ApiApplySearchCriteriaRequest) ReplaceAllImages(replaceAllImages bool) ApiApplySearchCriteriaRequest {
	r.replaceAllImages = &replaceAllImages
	return r
}

func (r ApiApplySearchCriteriaRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApplySearchCriteriaExecute(r)
}

/*
ApplySearchCriteria Applies search criteria to an item and refreshes metadata.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @return ApiApplySearchCriteriaRequest
*/
func (a *ItemLookupAPIService) ApplySearchCriteria(ctx context.Context, itemId string) ApiApplySearchCriteriaRequest {
	return ApiApplySearchCriteriaRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
func (a *ItemLookupAPIService) ApplySearchCriteriaExecute(r ApiApplySearchCriteriaRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.ApplySearchCriteria")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Apply/{itemId}"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.remoteSearchResult == nil {
		return nil, reportError("remoteSearchResult is required and must be specified")
	}

	if r.replaceAllImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "replaceAllImages", r.replaceAllImages, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "replaceAllImages", defaultValue, "form", "")
        r.replaceAllImages = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.remoteSearchResult
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetBookRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	bookInfoRemoteSearchQuery *BookInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetBookRemoteSearchResultsRequest) BookInfoRemoteSearchQuery(bookInfoRemoteSearchQuery BookInfoRemoteSearchQuery) ApiGetBookRemoteSearchResultsRequest {
	r.bookInfoRemoteSearchQuery = &bookInfoRemoteSearchQuery
	return r
}

func (r ApiGetBookRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetBookRemoteSearchResultsExecute(r)
}

/*
GetBookRemoteSearchResults Get book remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBookRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetBookRemoteSearchResults(ctx context.Context) ApiGetBookRemoteSearchResultsRequest {
	return ApiGetBookRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetBookRemoteSearchResultsExecute(r ApiGetBookRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetBookRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Book"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.bookInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("bookInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.bookInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetBoxSetRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	boxSetInfoRemoteSearchQuery *BoxSetInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetBoxSetRemoteSearchResultsRequest) BoxSetInfoRemoteSearchQuery(boxSetInfoRemoteSearchQuery BoxSetInfoRemoteSearchQuery) ApiGetBoxSetRemoteSearchResultsRequest {
	r.boxSetInfoRemoteSearchQuery = &boxSetInfoRemoteSearchQuery
	return r
}

func (r ApiGetBoxSetRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetBoxSetRemoteSearchResultsExecute(r)
}

/*
GetBoxSetRemoteSearchResults Get box set remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetBoxSetRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetBoxSetRemoteSearchResults(ctx context.Context) ApiGetBoxSetRemoteSearchResultsRequest {
	return ApiGetBoxSetRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetBoxSetRemoteSearchResultsExecute(r ApiGetBoxSetRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetBoxSetRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/BoxSet"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.boxSetInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("boxSetInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.boxSetInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetExternalIdInfosRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	itemId string
}

func (r ApiGetExternalIdInfosRequest) Execute() ([]ExternalIdInfo, *http.Response, error) {
	return r.ApiService.GetExternalIdInfosExecute(r)
}

/*
GetExternalIdInfos Get the item's external id info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param itemId Item id.
 @return ApiGetExternalIdInfosRequest
*/
func (a *ItemLookupAPIService) GetExternalIdInfos(ctx context.Context, itemId string) ApiGetExternalIdInfosRequest {
	return ApiGetExternalIdInfosRequest{
		ApiService: a,
		ctx: ctx,
		itemId: itemId,
	}
}

// Execute executes the request
//  @return []ExternalIdInfo
func (a *ItemLookupAPIService) GetExternalIdInfosExecute(r ApiGetExternalIdInfosRequest) ([]ExternalIdInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ExternalIdInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetExternalIdInfos")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/{itemId}/ExternalIdInfos"
	localVarPath = strings.Replace(localVarPath, "{"+"itemId"+"}", url.PathEscape(parameterValueToString(r.itemId, "itemId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMovieRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	movieInfoRemoteSearchQuery *MovieInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetMovieRemoteSearchResultsRequest) MovieInfoRemoteSearchQuery(movieInfoRemoteSearchQuery MovieInfoRemoteSearchQuery) ApiGetMovieRemoteSearchResultsRequest {
	r.movieInfoRemoteSearchQuery = &movieInfoRemoteSearchQuery
	return r
}

func (r ApiGetMovieRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetMovieRemoteSearchResultsExecute(r)
}

/*
GetMovieRemoteSearchResults Get movie remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMovieRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetMovieRemoteSearchResults(ctx context.Context) ApiGetMovieRemoteSearchResultsRequest {
	return ApiGetMovieRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetMovieRemoteSearchResultsExecute(r ApiGetMovieRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetMovieRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Movie"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.movieInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("movieInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.movieInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMusicAlbumRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	albumInfoRemoteSearchQuery *AlbumInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetMusicAlbumRemoteSearchResultsRequest) AlbumInfoRemoteSearchQuery(albumInfoRemoteSearchQuery AlbumInfoRemoteSearchQuery) ApiGetMusicAlbumRemoteSearchResultsRequest {
	r.albumInfoRemoteSearchQuery = &albumInfoRemoteSearchQuery
	return r
}

func (r ApiGetMusicAlbumRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetMusicAlbumRemoteSearchResultsExecute(r)
}

/*
GetMusicAlbumRemoteSearchResults Get music album remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMusicAlbumRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetMusicAlbumRemoteSearchResults(ctx context.Context) ApiGetMusicAlbumRemoteSearchResultsRequest {
	return ApiGetMusicAlbumRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetMusicAlbumRemoteSearchResultsExecute(r ApiGetMusicAlbumRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetMusicAlbumRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/MusicAlbum"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.albumInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("albumInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.albumInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMusicArtistRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	artistInfoRemoteSearchQuery *ArtistInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetMusicArtistRemoteSearchResultsRequest) ArtistInfoRemoteSearchQuery(artistInfoRemoteSearchQuery ArtistInfoRemoteSearchQuery) ApiGetMusicArtistRemoteSearchResultsRequest {
	r.artistInfoRemoteSearchQuery = &artistInfoRemoteSearchQuery
	return r
}

func (r ApiGetMusicArtistRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetMusicArtistRemoteSearchResultsExecute(r)
}

/*
GetMusicArtistRemoteSearchResults Get music artist remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMusicArtistRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetMusicArtistRemoteSearchResults(ctx context.Context) ApiGetMusicArtistRemoteSearchResultsRequest {
	return ApiGetMusicArtistRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetMusicArtistRemoteSearchResultsExecute(r ApiGetMusicArtistRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetMusicArtistRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/MusicArtist"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.artistInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("artistInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.artistInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMusicVideoRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	musicVideoInfoRemoteSearchQuery *MusicVideoInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetMusicVideoRemoteSearchResultsRequest) MusicVideoInfoRemoteSearchQuery(musicVideoInfoRemoteSearchQuery MusicVideoInfoRemoteSearchQuery) ApiGetMusicVideoRemoteSearchResultsRequest {
	r.musicVideoInfoRemoteSearchQuery = &musicVideoInfoRemoteSearchQuery
	return r
}

func (r ApiGetMusicVideoRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetMusicVideoRemoteSearchResultsExecute(r)
}

/*
GetMusicVideoRemoteSearchResults Get music video remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMusicVideoRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetMusicVideoRemoteSearchResults(ctx context.Context) ApiGetMusicVideoRemoteSearchResultsRequest {
	return ApiGetMusicVideoRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetMusicVideoRemoteSearchResultsExecute(r ApiGetMusicVideoRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetMusicVideoRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/MusicVideo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.musicVideoInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("musicVideoInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.musicVideoInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPersonRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	personLookupInfoRemoteSearchQuery *PersonLookupInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetPersonRemoteSearchResultsRequest) PersonLookupInfoRemoteSearchQuery(personLookupInfoRemoteSearchQuery PersonLookupInfoRemoteSearchQuery) ApiGetPersonRemoteSearchResultsRequest {
	r.personLookupInfoRemoteSearchQuery = &personLookupInfoRemoteSearchQuery
	return r
}

func (r ApiGetPersonRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetPersonRemoteSearchResultsExecute(r)
}

/*
GetPersonRemoteSearchResults Get person remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPersonRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetPersonRemoteSearchResults(ctx context.Context) ApiGetPersonRemoteSearchResultsRequest {
	return ApiGetPersonRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetPersonRemoteSearchResultsExecute(r ApiGetPersonRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetPersonRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Person"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.personLookupInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("personLookupInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.personLookupInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	seriesInfoRemoteSearchQuery *SeriesInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetSeriesRemoteSearchResultsRequest) SeriesInfoRemoteSearchQuery(seriesInfoRemoteSearchQuery SeriesInfoRemoteSearchQuery) ApiGetSeriesRemoteSearchResultsRequest {
	r.seriesInfoRemoteSearchQuery = &seriesInfoRemoteSearchQuery
	return r
}

func (r ApiGetSeriesRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetSeriesRemoteSearchResultsExecute(r)
}

/*
GetSeriesRemoteSearchResults Get series remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSeriesRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetSeriesRemoteSearchResults(ctx context.Context) ApiGetSeriesRemoteSearchResultsRequest {
	return ApiGetSeriesRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetSeriesRemoteSearchResultsExecute(r ApiGetSeriesRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetSeriesRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Series"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.seriesInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("seriesInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.seriesInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTrailerRemoteSearchResultsRequest struct {
	ctx context.Context
	ApiService ItemLookupAPI
	trailerInfoRemoteSearchQuery *TrailerInfoRemoteSearchQuery
}

// Remote search query.
func (r ApiGetTrailerRemoteSearchResultsRequest) TrailerInfoRemoteSearchQuery(trailerInfoRemoteSearchQuery TrailerInfoRemoteSearchQuery) ApiGetTrailerRemoteSearchResultsRequest {
	r.trailerInfoRemoteSearchQuery = &trailerInfoRemoteSearchQuery
	return r
}

func (r ApiGetTrailerRemoteSearchResultsRequest) Execute() ([]RemoteSearchResult, *http.Response, error) {
	return r.ApiService.GetTrailerRemoteSearchResultsExecute(r)
}

/*
GetTrailerRemoteSearchResults Get trailer remote search.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTrailerRemoteSearchResultsRequest
*/
func (a *ItemLookupAPIService) GetTrailerRemoteSearchResults(ctx context.Context) ApiGetTrailerRemoteSearchResultsRequest {
	return ApiGetTrailerRemoteSearchResultsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []RemoteSearchResult
func (a *ItemLookupAPIService) GetTrailerRemoteSearchResultsExecute(r ApiGetTrailerRemoteSearchResultsRequest) ([]RemoteSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []RemoteSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ItemLookupAPIService.GetTrailerRemoteSearchResults")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/Items/RemoteSearch/Trailer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.trailerInfoRemoteSearchQuery == nil {
		return localVarReturnValue, nil, reportError("trailerInfoRemoteSearchQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase", "text/html"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.trailerInfoRemoteSearchQuery
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
Jellyfin API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 10.10.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
	"reflect"
	"time"
)


type LiveTvAPI interface {

	/*
	AddListingProvider Adds a listings provider.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddListingProviderRequest
	*/
	AddListingProvider(ctx context.Context) ApiAddListingProviderRequest

	// AddListingProviderExecute executes the request
	//  @return ListingsProviderInfo
	AddListingProviderExecute(r ApiAddListingProviderRequest) (*ListingsProviderInfo, *http.Response, error)

	/*
	AddTunerHost Adds a tuner host.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiAddTunerHostRequest
	*/
	AddTunerHost(ctx context.Context) ApiAddTunerHostRequest

	// AddTunerHostExecute executes the request
	//  @return TunerHostInfo
	AddTunerHostExecute(r ApiAddTunerHostRequest) (*TunerHostInfo, *http.Response, error)

	/*
	CancelSeriesTimer Cancels a live tv series timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param timerId Timer id.
	@return ApiCancelSeriesTimerRequest
	*/
	CancelSeriesTimer(ctx context.Context, timerId string) ApiCancelSeriesTimerRequest

	// CancelSeriesTimerExecute executes the request
	CancelSeriesTimerExecute(r ApiCancelSeriesTimerRequest) (*http.Response, error)

	/*
	CancelTimer Cancels a live tv timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param timerId Timer id.
	@return ApiCancelTimerRequest
	*/
	CancelTimer(ctx context.Context, timerId string) ApiCancelTimerRequest

	// CancelTimerExecute executes the request
	CancelTimerExecute(r ApiCancelTimerRequest) (*http.Response, error)

	/*
	CreateSeriesTimer Creates a live tv series timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateSeriesTimerRequest
	*/
	CreateSeriesTimer(ctx context.Context) ApiCreateSeriesTimerRequest

	// CreateSeriesTimerExecute executes the request
	CreateSeriesTimerExecute(r ApiCreateSeriesTimerRequest) (*http.Response, error)

	/*
	CreateTimer Creates a live tv timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiCreateTimerRequest
	*/
	CreateTimer(ctx context.Context) ApiCreateTimerRequest

	// CreateTimerExecute executes the request
	CreateTimerExecute(r ApiCreateTimerRequest) (*http.Response, error)

	/*
	DeleteListingProvider Delete listing provider.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteListingProviderRequest
	*/
	DeleteListingProvider(ctx context.Context) ApiDeleteListingProviderRequest

	// DeleteListingProviderExecute executes the request
	DeleteListingProviderExecute(r ApiDeleteListingProviderRequest) (*http.Response, error)

	/*
	DeleteRecording Deletes a live tv recording.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordingId Recording id.
	@return ApiDeleteRecordingRequest
	*/
	DeleteRecording(ctx context.Context, recordingId string) ApiDeleteRecordingRequest

	// DeleteRecordingExecute executes the request
	DeleteRecordingExecute(r ApiDeleteRecordingRequest) (*http.Response, error)

	/*
	DeleteTunerHost Deletes a tuner host.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDeleteTunerHostRequest
	*/
	DeleteTunerHost(ctx context.Context) ApiDeleteTunerHostRequest

	// DeleteTunerHostExecute executes the request
	DeleteTunerHostExecute(r ApiDeleteTunerHostRequest) (*http.Response, error)

	/*
	DiscoverTuners Discover tuners.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDiscoverTunersRequest
	*/
	DiscoverTuners(ctx context.Context) ApiDiscoverTunersRequest

	// DiscoverTunersExecute executes the request
	//  @return []TunerHostInfo
	DiscoverTunersExecute(r ApiDiscoverTunersRequest) ([]TunerHostInfo, *http.Response, error)

	/*
	DiscvoverTuners Discover tuners.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiDiscvoverTunersRequest
	*/
	DiscvoverTuners(ctx context.Context) ApiDiscvoverTunersRequest

	// DiscvoverTunersExecute executes the request
	//  @return []TunerHostInfo
	DiscvoverTunersExecute(r ApiDiscvoverTunersRequest) ([]TunerHostInfo, *http.Response, error)

	/*
	GetChannel Gets a live tv channel.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param channelId Channel id.
	@return ApiGetChannelRequest
	*/
	GetChannel(ctx context.Context, channelId string) ApiGetChannelRequest

	// GetChannelExecute executes the request
	//  @return BaseItemDto
	GetChannelExecute(r ApiGetChannelRequest) (*BaseItemDto, *http.Response, error)

	/*
	GetChannelMappingOptions Get channel mapping options.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetChannelMappingOptionsRequest
	*/
	GetChannelMappingOptions(ctx context.Context) ApiGetChannelMappingOptionsRequest

	// GetChannelMappingOptionsExecute executes the request
	//  @return ChannelMappingOptionsDto
	GetChannelMappingOptionsExecute(r ApiGetChannelMappingOptionsRequest) (*ChannelMappingOptionsDto, *http.Response, error)

	/*
	GetDefaultListingProvider Gets default listings provider info.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDefaultListingProviderRequest
	*/
	GetDefaultListingProvider(ctx context.Context) ApiGetDefaultListingProviderRequest

	// GetDefaultListingProviderExecute executes the request
	//  @return ListingsProviderInfo
	GetDefaultListingProviderExecute(r ApiGetDefaultListingProviderRequest) (*ListingsProviderInfo, *http.Response, error)

	/*
	GetDefaultTimer Gets the default values for a new timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetDefaultTimerRequest
	*/
	GetDefaultTimer(ctx context.Context) ApiGetDefaultTimerRequest

	// GetDefaultTimerExecute executes the request
	//  @return SeriesTimerInfoDto
	GetDefaultTimerExecute(r ApiGetDefaultTimerRequest) (*SeriesTimerInfoDto, *http.Response, error)

	/*
	GetGuideInfo Get guid info.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetGuideInfoRequest
	*/
	GetGuideInfo(ctx context.Context) ApiGetGuideInfoRequest

	// GetGuideInfoExecute executes the request
	//  @return GuideInfo
	GetGuideInfoExecute(r ApiGetGuideInfoRequest) (*GuideInfo, *http.Response, error)

	/*
	GetLineups Gets available lineups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLineupsRequest
	*/
	GetLineups(ctx context.Context) ApiGetLineupsRequest

	// GetLineupsExecute executes the request
	//  @return []NameIdPair
	GetLineupsExecute(r ApiGetLineupsRequest) ([]NameIdPair, *http.Response, error)

	/*
	GetLiveRecordingFile Gets a live tv recording stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordingId Recording id.
	@return ApiGetLiveRecordingFileRequest
	*/
	GetLiveRecordingFile(ctx context.Context, recordingId string) ApiGetLiveRecordingFileRequest

	// GetLiveRecordingFileExecute executes the request
	//  @return *os.File
	GetLiveRecordingFileExecute(r ApiGetLiveRecordingFileRequest) (*os.File, *http.Response, error)

	/*
	GetLiveStreamFile Gets a live tv channel stream.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param streamId Stream id.
	@param container Container type.
	@return ApiGetLiveStreamFileRequest
	*/
	GetLiveStreamFile(ctx context.Context, streamId string, container string) ApiGetLiveStreamFileRequest

	// GetLiveStreamFileExecute executes the request
	//  @return *os.File
	GetLiveStreamFileExecute(r ApiGetLiveStreamFileRequest) (*os.File, *http.Response, error)

	/*
	GetLiveTvChannels Gets available live tv channels.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLiveTvChannelsRequest
	*/
	GetLiveTvChannels(ctx context.Context) ApiGetLiveTvChannelsRequest

	// GetLiveTvChannelsExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetLiveTvChannelsExecute(r ApiGetLiveTvChannelsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetLiveTvInfo Gets available live tv services.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLiveTvInfoRequest
	*/
	GetLiveTvInfo(ctx context.Context) ApiGetLiveTvInfoRequest

	// GetLiveTvInfoExecute executes the request
	//  @return LiveTvInfo
	GetLiveTvInfoExecute(r ApiGetLiveTvInfoRequest) (*LiveTvInfo, *http.Response, error)

	/*
	GetLiveTvPrograms Gets available live tv epgs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetLiveTvProgramsRequest
	*/
	GetLiveTvPrograms(ctx context.Context) ApiGetLiveTvProgramsRequest

	// GetLiveTvProgramsExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetLiveTvProgramsExecute(r ApiGetLiveTvProgramsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetProgram Gets a live tv program.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param programId Program id.
	@return ApiGetProgramRequest
	*/
	GetProgram(ctx context.Context, programId string) ApiGetProgramRequest

	// GetProgramExecute executes the request
	//  @return BaseItemDto
	GetProgramExecute(r ApiGetProgramRequest) (*BaseItemDto, *http.Response, error)

	/*
	GetPrograms Gets available live tv epgs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetProgramsRequest
	*/
	GetPrograms(ctx context.Context) ApiGetProgramsRequest

	// GetProgramsExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetProgramsExecute(r ApiGetProgramsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetRecommendedPrograms Gets recommended live tv epgs.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRecommendedProgramsRequest
	*/
	GetRecommendedPrograms(ctx context.Context) ApiGetRecommendedProgramsRequest

	// GetRecommendedProgramsExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetRecommendedProgramsExecute(r ApiGetRecommendedProgramsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetRecording Gets a live tv recording.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param recordingId Recording id.
	@return ApiGetRecordingRequest
	*/
	GetRecording(ctx context.Context, recordingId string) ApiGetRecordingRequest

	// GetRecordingExecute executes the request
	//  @return BaseItemDto
	GetRecordingExecute(r ApiGetRecordingRequest) (*BaseItemDto, *http.Response, error)

	/*
	GetRecordingFolders Gets recording folders.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRecordingFoldersRequest
	*/
	GetRecordingFolders(ctx context.Context) ApiGetRecordingFoldersRequest

	// GetRecordingFoldersExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetRecordingFoldersExecute(r ApiGetRecordingFoldersRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetRecordingGroup Get recording group.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param groupId Group id.
	@return ApiGetRecordingGroupRequest

	Deprecated
	*/
	GetRecordingGroup(ctx context.Context, groupId string) ApiGetRecordingGroupRequest

	// GetRecordingGroupExecute executes the request
	// Deprecated
	GetRecordingGroupExecute(r ApiGetRecordingGroupRequest) (*http.Response, error)

	/*
	GetRecordingGroups Gets live tv recording groups.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRecordingGroupsRequest

	Deprecated
	*/
	GetRecordingGroups(ctx context.Context) ApiGetRecordingGroupsRequest

	// GetRecordingGroupsExecute executes the request
	//  @return BaseItemDtoQueryResult
	// Deprecated
	GetRecordingGroupsExecute(r ApiGetRecordingGroupsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetRecordings Gets live tv recordings.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRecordingsRequest
	*/
	GetRecordings(ctx context.Context) ApiGetRecordingsRequest

	// GetRecordingsExecute executes the request
	//  @return BaseItemDtoQueryResult
	GetRecordingsExecute(r ApiGetRecordingsRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetRecordingsSeries Gets live tv recording series.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetRecordingsSeriesRequest

	Deprecated
	*/
	GetRecordingsSeries(ctx context.Context) ApiGetRecordingsSeriesRequest

	// GetRecordingsSeriesExecute executes the request
	//  @return BaseItemDtoQueryResult
	// Deprecated
	GetRecordingsSeriesExecute(r ApiGetRecordingsSeriesRequest) (*BaseItemDtoQueryResult, *http.Response, error)

	/*
	GetSchedulesDirectCountries Gets available countries.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSchedulesDirectCountriesRequest
	*/
	GetSchedulesDirectCountries(ctx context.Context) ApiGetSchedulesDirectCountriesRequest

	// GetSchedulesDirectCountriesExecute executes the request
	//  @return *os.File
	GetSchedulesDirectCountriesExecute(r ApiGetSchedulesDirectCountriesRequest) (*os.File, *http.Response, error)

	/*
	GetSeriesTimer Gets a live tv series timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param timerId Timer id.
	@return ApiGetSeriesTimerRequest
	*/
	GetSeriesTimer(ctx context.Context, timerId string) ApiGetSeriesTimerRequest

	// GetSeriesTimerExecute executes the request
	//  @return SeriesTimerInfoDto
	GetSeriesTimerExecute(r ApiGetSeriesTimerRequest) (*SeriesTimerInfoDto, *http.Response, error)

	/*
	GetSeriesTimers Gets live tv series timers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSeriesTimersRequest
	*/
	GetSeriesTimers(ctx context.Context) ApiGetSeriesTimersRequest

	// GetSeriesTimersExecute executes the request
	//  @return SeriesTimerInfoDtoQueryResult
	GetSeriesTimersExecute(r ApiGetSeriesTimersRequest) (*SeriesTimerInfoDtoQueryResult, *http.Response, error)

	/*
	GetTimer Gets a timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param timerId Timer id.
	@return ApiGetTimerRequest
	*/
	GetTimer(ctx context.Context, timerId string) ApiGetTimerRequest

	// GetTimerExecute executes the request
	//  @return TimerInfoDto
	GetTimerExecute(r ApiGetTimerRequest) (*TimerInfoDto, *http.Response, error)

	/*
	GetTimers Gets the live tv timers.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTimersRequest
	*/
	GetTimers(ctx context.Context) ApiGetTimersRequest

	// GetTimersExecute executes the request
	//  @return TimerInfoDtoQueryResult
	GetTimersExecute(r ApiGetTimersRequest) (*TimerInfoDtoQueryResult, *http.Response, error)

	/*
	GetTunerHostTypes Get tuner host types.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetTunerHostTypesRequest
	*/
	GetTunerHostTypes(ctx context.Context) ApiGetTunerHostTypesRequest

	// GetTunerHostTypesExecute executes the request
	//  @return []NameIdPair
	GetTunerHostTypesExecute(r ApiGetTunerHostTypesRequest) ([]NameIdPair, *http.Response, error)

	/*
	ResetTuner Resets a tv tuner.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param tunerId Tuner id.
	@return ApiResetTunerRequest
	*/
	ResetTuner(ctx context.Context, tunerId string) ApiResetTunerRequest

	// ResetTunerExecute executes the request
	ResetTunerExecute(r ApiResetTunerRequest) (*http.Response, error)

	/*
	SetChannelMapping Set channel mappings.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiSetChannelMappingRequest
	*/
	SetChannelMapping(ctx context.Context) ApiSetChannelMappingRequest

	// SetChannelMappingExecute executes the request
	//  @return TunerChannelMapping
	SetChannelMappingExecute(r ApiSetChannelMappingRequest) (*TunerChannelMapping, *http.Response, error)

	/*
	UpdateSeriesTimer Updates a live tv series timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param timerId Timer id.
	@return ApiUpdateSeriesTimerRequest
	*/
	UpdateSeriesTimer(ctx context.Context, timerId string) ApiUpdateSeriesTimerRequest

	// UpdateSeriesTimerExecute executes the request
	UpdateSeriesTimerExecute(r ApiUpdateSeriesTimerRequest) (*http.Response, error)

	/*
	UpdateTimer Updates a live tv timer.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param timerId Timer id.
	@return ApiUpdateTimerRequest
	*/
	UpdateTimer(ctx context.Context, timerId string) ApiUpdateTimerRequest

	// UpdateTimerExecute executes the request
	UpdateTimerExecute(r ApiUpdateTimerRequest) (*http.Response, error)
}

// LiveTvAPIService LiveTvAPI service
type LiveTvAPIService service

type ApiAddListingProviderRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	pw *string
	validateListings *bool
	validateLogin *bool
	listingsProviderInfo *ListingsProviderInfo
}

// Password.
func (r ApiAddListingProviderRequest) Pw(pw string) ApiAddListingProviderRequest {
	r.pw = &pw
	return r
}

// Validate listings.
func (r ApiAddListingProviderRequest) ValidateListings(validateListings bool) ApiAddListingProviderRequest {
	r.validateListings = &validateListings
	return r
}

// Validate login.
func (r ApiAddListingProviderRequest) ValidateLogin(validateLogin bool) ApiAddListingProviderRequest {
	r.validateLogin = &validateLogin
	return r
}

// New listings info.
func (r ApiAddListingProviderRequest) ListingsProviderInfo(listingsProviderInfo ListingsProviderInfo) ApiAddListingProviderRequest {
	r.listingsProviderInfo = &listingsProviderInfo
	return r
}

func (r ApiAddListingProviderRequest) Execute() (*ListingsProviderInfo, *http.Response, error) {
	return r.ApiService.AddListingProviderExecute(r)
}

/*
AddListingProvider Adds a listings provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddListingProviderRequest
*/
func (a *LiveTvAPIService) AddListingProvider(ctx context.Context) ApiAddListingProviderRequest {
	return ApiAddListingProviderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListingsProviderInfo
func (a *LiveTvAPIService) AddListingProviderExecute(r ApiAddListingProviderRequest) (*ListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.AddListingProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.pw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "pw", r.pw, "form", "")
	}
	if r.validateListings != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateListings", r.validateListings, "form", "")
	} else {
		var defaultValue bool = false
		r.validateListings = &defaultValue
	}
	if r.validateLogin != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "validateLogin", r.validateLogin, "form", "")
	} else {
		var defaultValue bool = false
		r.validateLogin = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listingsProviderInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddTunerHostRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	tunerHostInfo *TunerHostInfo
}

// New tuner host.
func (r ApiAddTunerHostRequest) TunerHostInfo(tunerHostInfo TunerHostInfo) ApiAddTunerHostRequest {
	r.tunerHostInfo = &tunerHostInfo
	return r
}

func (r ApiAddTunerHostRequest) Execute() (*TunerHostInfo, *http.Response, error) {
	return r.ApiService.AddTunerHostExecute(r)
}

/*
AddTunerHost Adds a tuner host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddTunerHostRequest
*/
func (a *LiveTvAPIService) AddTunerHost(ctx context.Context) ApiAddTunerHostRequest {
	return ApiAddTunerHostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TunerHostInfo
func (a *LiveTvAPIService) AddTunerHostExecute(r ApiAddTunerHostRequest) (*TunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.AddTunerHost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.tunerHostInfo
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCancelSeriesTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	timerId string
}

func (r ApiCancelSeriesTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelSeriesTimerExecute(r)
}

/*
CancelSeriesTimer Cancels a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return ApiCancelSeriesTimerRequest
*/
func (a *LiveTvAPIService) CancelSeriesTimer(ctx context.Context, timerId string) ApiCancelSeriesTimerRequest {
	return ApiCancelSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CancelSeriesTimerExecute(r ApiCancelSeriesTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CancelSeriesTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCancelTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	timerId string
}

func (r ApiCancelTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CancelTimerExecute(r)
}

/*
CancelTimer Cancels a live tv timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return ApiCancelTimerRequest
*/
func (a *LiveTvAPIService) CancelTimer(ctx context.Context, timerId string) ApiCancelTimerRequest {
	return ApiCancelTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CancelTimerExecute(r ApiCancelTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CancelTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateSeriesTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	seriesTimerInfoDto *SeriesTimerInfoDto
}

// New series timer info.
func (r ApiCreateSeriesTimerRequest) SeriesTimerInfoDto(seriesTimerInfoDto SeriesTimerInfoDto) ApiCreateSeriesTimerRequest {
	r.seriesTimerInfoDto = &seriesTimerInfoDto
	return r
}

func (r ApiCreateSeriesTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateSeriesTimerExecute(r)
}

/*
CreateSeriesTimer Creates a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateSeriesTimerRequest
*/
func (a *LiveTvAPIService) CreateSeriesTimer(ctx context.Context) ApiCreateSeriesTimerRequest {
	return ApiCreateSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CreateSeriesTimerExecute(r ApiCreateSeriesTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CreateSeriesTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.seriesTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCreateTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	timerInfoDto *TimerInfoDto
}

// New timer info.
func (r ApiCreateTimerRequest) TimerInfoDto(timerInfoDto TimerInfoDto) ApiCreateTimerRequest {
	r.timerInfoDto = &timerInfoDto
	return r
}

func (r ApiCreateTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.CreateTimerExecute(r)
}

/*
CreateTimer Creates a live tv timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateTimerRequest
*/
func (a *LiveTvAPIService) CreateTimer(ctx context.Context) ApiCreateTimerRequest {
	return ApiCreateTimerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) CreateTimerExecute(r ApiCreateTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.CreateTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.timerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteListingProviderRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	id *string
}

// Listing provider id.
func (r ApiDeleteListingProviderRequest) Id(id string) ApiDeleteListingProviderRequest {
	r.id = &id
	return r
}

func (r ApiDeleteListingProviderRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteListingProviderExecute(r)
}

/*
DeleteListingProvider Delete listing provider.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteListingProviderRequest
*/
func (a *LiveTvAPIService) DeleteListingProvider(ctx context.Context) ApiDeleteListingProviderRequest {
	return ApiDeleteListingProviderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) DeleteListingProviderExecute(r ApiDeleteListingProviderRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DeleteListingProvider")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteRecordingRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	recordingId string
}

func (r ApiDeleteRecordingRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteRecordingExecute(r)
}

/*
DeleteRecording Deletes a live tv recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordingId Recording id.
 @return ApiDeleteRecordingRequest
*/
func (a *LiveTvAPIService) DeleteRecording(ctx context.Context, recordingId string) ApiDeleteRecordingRequest {
	return ApiDeleteRecordingRequest{
		ApiService: a,
		ctx: ctx,
		recordingId: recordingId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) DeleteRecordingExecute(r ApiDeleteRecordingRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DeleteRecording")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{recordingId}"
	localVarPath = strings.Replace(localVarPath, "{"+"recordingId"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteTunerHostRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	id *string
}

// Tuner host id.
func (r ApiDeleteTunerHostRequest) Id(id string) ApiDeleteTunerHostRequest {
	r.id = &id
	return r
}

func (r ApiDeleteTunerHostRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteTunerHostExecute(r)
}

/*
DeleteTunerHost Deletes a tuner host.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteTunerHostRequest
*/
func (a *LiveTvAPIService) DeleteTunerHost(ctx context.Context) ApiDeleteTunerHostRequest {
	return ApiDeleteTunerHostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) DeleteTunerHostExecute(r ApiDeleteTunerHostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DeleteTunerHost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDiscoverTunersRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	newDevicesOnly *bool
}

// Only discover new tuners.
func (r ApiDiscoverTunersRequest) NewDevicesOnly(newDevicesOnly bool) ApiDiscoverTunersRequest {
	r.newDevicesOnly = &newDevicesOnly
	return r
}

func (r ApiDiscoverTunersRequest) Execute() ([]TunerHostInfo, *http.Response, error) {
	return r.ApiService.DiscoverTunersExecute(r)
}

/*
DiscoverTuners Discover tuners.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDiscoverTunersRequest
*/
func (a *LiveTvAPIService) DiscoverTuners(ctx context.Context) ApiDiscoverTunersRequest {
	return ApiDiscoverTunersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TunerHostInfo
func (a *LiveTvAPIService) DiscoverTunersExecute(r ApiDiscoverTunersRequest) ([]TunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DiscoverTuners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/Discover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.newDevicesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newDevicesOnly", r.newDevicesOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.newDevicesOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDiscvoverTunersRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	newDevicesOnly *bool
}

// Only discover new tuners.
func (r ApiDiscvoverTunersRequest) NewDevicesOnly(newDevicesOnly bool) ApiDiscvoverTunersRequest {
	r.newDevicesOnly = &newDevicesOnly
	return r
}

func (r ApiDiscvoverTunersRequest) Execute() ([]TunerHostInfo, *http.Response, error) {
	return r.ApiService.DiscvoverTunersExecute(r)
}

/*
DiscvoverTuners Discover tuners.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDiscvoverTunersRequest
*/
func (a *LiveTvAPIService) DiscvoverTuners(ctx context.Context) ApiDiscvoverTunersRequest {
	return ApiDiscvoverTunersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []TunerHostInfo
func (a *LiveTvAPIService) DiscvoverTunersExecute(r ApiDiscvoverTunersRequest) ([]TunerHostInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []TunerHostInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.DiscvoverTuners")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/Discvover"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.newDevicesOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "newDevicesOnly", r.newDevicesOnly, "form", "")
	} else {
		var defaultValue bool = false
		r.newDevicesOnly = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	channelId string
	userId *string
}

// Optional. Attach user data.
func (r ApiGetChannelRequest) UserId(userId string) ApiGetChannelRequest {
	r.userId = &userId
	return r
}

func (r ApiGetChannelRequest) Execute() (*BaseItemDto, *http.Response, error) {
	return r.ApiService.GetChannelExecute(r)
}

/*
GetChannel Gets a live tv channel.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param channelId Channel id.
 @return ApiGetChannelRequest
*/
func (a *LiveTvAPIService) GetChannel(ctx context.Context, channelId string) ApiGetChannelRequest {
	return ApiGetChannelRequest{
		ApiService: a,
		ctx: ctx,
		channelId: channelId,
	}
}

// Execute executes the request
//  @return BaseItemDto
func (a *LiveTvAPIService) GetChannelExecute(r ApiGetChannelRequest) (*BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetChannel")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels/{channelId}"
	localVarPath = strings.Replace(localVarPath, "{"+"channelId"+"}", url.PathEscape(parameterValueToString(r.channelId, "channelId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChannelMappingOptionsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	providerId *string
}

// Provider id.
func (r ApiGetChannelMappingOptionsRequest) ProviderId(providerId string) ApiGetChannelMappingOptionsRequest {
	r.providerId = &providerId
	return r
}

func (r ApiGetChannelMappingOptionsRequest) Execute() (*ChannelMappingOptionsDto, *http.Response, error) {
	return r.ApiService.GetChannelMappingOptionsExecute(r)
}

/*
GetChannelMappingOptions Get channel mapping options.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChannelMappingOptionsRequest
*/
func (a *LiveTvAPIService) GetChannelMappingOptions(ctx context.Context) ApiGetChannelMappingOptionsRequest {
	return ApiGetChannelMappingOptionsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChannelMappingOptionsDto
func (a *LiveTvAPIService) GetChannelMappingOptionsExecute(r ApiGetChannelMappingOptionsRequest) (*ChannelMappingOptionsDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChannelMappingOptionsDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetChannelMappingOptions")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappingOptions"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.providerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "providerId", r.providerId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultListingProviderRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
}

func (r ApiGetDefaultListingProviderRequest) Execute() (*ListingsProviderInfo, *http.Response, error) {
	return r.ApiService.GetDefaultListingProviderExecute(r)
}

/*
GetDefaultListingProvider Gets default listings provider info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDefaultListingProviderRequest
*/
func (a *LiveTvAPIService) GetDefaultListingProvider(ctx context.Context) ApiGetDefaultListingProviderRequest {
	return ApiGetDefaultListingProviderRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListingsProviderInfo
func (a *LiveTvAPIService) GetDefaultListingProviderExecute(r ApiGetDefaultListingProviderRequest) (*ListingsProviderInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingsProviderInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetDefaultListingProvider")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Default"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetDefaultTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	programId *string
}

// Optional. To attach default values based on a program.
func (r ApiGetDefaultTimerRequest) ProgramId(programId string) ApiGetDefaultTimerRequest {
	r.programId = &programId
	return r
}

func (r ApiGetDefaultTimerRequest) Execute() (*SeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetDefaultTimerExecute(r)
}

/*
GetDefaultTimer Gets the default values for a new timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetDefaultTimerRequest
*/
func (a *LiveTvAPIService) GetDefaultTimer(ctx context.Context) ApiGetDefaultTimerRequest {
	return ApiGetDefaultTimerRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SeriesTimerInfoDto
func (a *LiveTvAPIService) GetDefaultTimerExecute(r ApiGetDefaultTimerRequest) (*SeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetDefaultTimer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/Defaults"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.programId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "programId", r.programId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetGuideInfoRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
}

func (r ApiGetGuideInfoRequest) Execute() (*GuideInfo, *http.Response, error) {
	return r.ApiService.GetGuideInfoExecute(r)
}

/*
GetGuideInfo Get guid info.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetGuideInfoRequest
*/
func (a *LiveTvAPIService) GetGuideInfo(ctx context.Context) ApiGetGuideInfoRequest {
	return ApiGetGuideInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return GuideInfo
func (a *LiveTvAPIService) GetGuideInfoExecute(r ApiGetGuideInfoRequest) (*GuideInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GuideInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetGuideInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/GuideInfo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLineupsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	id *string
	type_ *string
	location *string
	country *string
}

// Provider id.
func (r ApiGetLineupsRequest) Id(id string) ApiGetLineupsRequest {
	r.id = &id
	return r
}

// Provider type.
func (r ApiGetLineupsRequest) Type_(type_ string) ApiGetLineupsRequest {
	r.type_ = &type_
	return r
}

// Location.
func (r ApiGetLineupsRequest) Location(location string) ApiGetLineupsRequest {
	r.location = &location
	return r
}

// Country.
func (r ApiGetLineupsRequest) Country(country string) ApiGetLineupsRequest {
	r.country = &country
	return r
}

func (r ApiGetLineupsRequest) Execute() ([]NameIdPair, *http.Response, error) {
	return r.ApiService.GetLineupsExecute(r)
}

/*
GetLineups Gets available lineups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLineupsRequest
*/
func (a *LiveTvAPIService) GetLineups(ctx context.Context) ApiGetLineupsRequest {
	return ApiGetLineupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameIdPair
func (a *LiveTvAPIService) GetLineupsExecute(r ApiGetLineupsRequest) ([]NameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLineups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/Lineups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.location != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "location", r.location, "form", "")
	}
	if r.country != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "country", r.country, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveRecordingFileRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	recordingId string
}

func (r ApiGetLiveRecordingFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetLiveRecordingFileExecute(r)
}

/*
GetLiveRecordingFile Gets a live tv recording stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordingId Recording id.
 @return ApiGetLiveRecordingFileRequest
*/
func (a *LiveTvAPIService) GetLiveRecordingFile(ctx context.Context, recordingId string) ApiGetLiveRecordingFileRequest {
	return ApiGetLiveRecordingFileRequest{
		ApiService: a,
		ctx: ctx,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *LiveTvAPIService) GetLiveRecordingFileExecute(r ApiGetLiveRecordingFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveRecordingFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveRecordings/{recordingId}/stream"
	localVarPath = strings.Replace(localVarPath, "{"+"recordingId"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"video/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveStreamFileRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	streamId string
	container string
}

func (r ApiGetLiveStreamFileRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetLiveStreamFileExecute(r)
}

/*
GetLiveStreamFile Gets a live tv channel stream.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param streamId Stream id.
 @param container Container type.
 @return ApiGetLiveStreamFileRequest
*/
func (a *LiveTvAPIService) GetLiveStreamFile(ctx context.Context, streamId string, container string) ApiGetLiveStreamFileRequest {
	return ApiGetLiveStreamFileRequest{
		ApiService: a,
		ctx: ctx,
		streamId: streamId,
		container: container,
	}
}

// Execute executes the request
//  @return *os.File
func (a *LiveTvAPIService) GetLiveStreamFileExecute(r ApiGetLiveStreamFileRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveStreamFile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/LiveStreamFiles/{streamId}/stream.{container}"
	localVarPath = strings.Replace(localVarPath, "{"+"streamId"+"}", url.PathEscape(parameterValueToString(r.streamId, "streamId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"container"+"}", url.PathEscape(parameterValueToString(r.container, "container")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"video/*", "application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveTvChannelsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	type_ *ChannelType
	userId *string
	startIndex *int32
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	limit *int32
	isFavorite *bool
	isLiked *bool
	isDisliked *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]ImageType
	fields *[]ItemFields
	enableUserData *bool
	sortBy *[]ItemSortBy
	sortOrder *SortOrder
	enableFavoriteSorting *bool
	addCurrentProgram *bool
}

// Optional. Filter by channel type.
func (r ApiGetLiveTvChannelsRequest) Type_(type_ ChannelType) ApiGetLiveTvChannelsRequest {
	r.type_ = &type_
	return r
}

// Optional. Filter by user and attach user data.
func (r ApiGetLiveTvChannelsRequest) UserId(userId string) ApiGetLiveTvChannelsRequest {
	r.userId = &userId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetLiveTvChannelsRequest) StartIndex(startIndex int32) ApiGetLiveTvChannelsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. Filter for movies.
func (r ApiGetLiveTvChannelsRequest) IsMovie(isMovie bool) ApiGetLiveTvChannelsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for series.
func (r ApiGetLiveTvChannelsRequest) IsSeries(isSeries bool) ApiGetLiveTvChannelsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for news.
func (r ApiGetLiveTvChannelsRequest) IsNews(isNews bool) ApiGetLiveTvChannelsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for kids.
func (r ApiGetLiveTvChannelsRequest) IsKids(isKids bool) ApiGetLiveTvChannelsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r ApiGetLiveTvChannelsRequest) IsSports(isSports bool) ApiGetLiveTvChannelsRequest {
	r.isSports = &isSports
	return r
}

// Optional. The maximum number of records to return.
func (r ApiGetLiveTvChannelsRequest) Limit(limit int32) ApiGetLiveTvChannelsRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by channels that are favorites, or not.
func (r ApiGetLiveTvChannelsRequest) IsFavorite(isFavorite bool) ApiGetLiveTvChannelsRequest {
	r.isFavorite = &isFavorite
	return r
}

// Optional. Filter by channels that are liked, or not.
func (r ApiGetLiveTvChannelsRequest) IsLiked(isLiked bool) ApiGetLiveTvChannelsRequest {
	r.isLiked = &isLiked
	return r
}

// Optional. Filter by channels that are disliked, or not.
func (r ApiGetLiveTvChannelsRequest) IsDisliked(isDisliked bool) ApiGetLiveTvChannelsRequest {
	r.isDisliked = &isDisliked
	return r
}

// Optional. Include image information in output.
func (r ApiGetLiveTvChannelsRequest) EnableImages(enableImages bool) ApiGetLiveTvChannelsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r ApiGetLiveTvChannelsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetLiveTvChannelsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// \&quot;Optional. The image types to include in the output.
func (r ApiGetLiveTvChannelsRequest) EnableImageTypes(enableImageTypes []ImageType) ApiGetLiveTvChannelsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r ApiGetLiveTvChannelsRequest) Fields(fields []ItemFields) ApiGetLiveTvChannelsRequest {
	r.fields = &fields
	return r
}

// Optional. Include user data.
func (r ApiGetLiveTvChannelsRequest) EnableUserData(enableUserData bool) ApiGetLiveTvChannelsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Key to sort by.
func (r ApiGetLiveTvChannelsRequest) SortBy(sortBy []ItemSortBy) ApiGetLiveTvChannelsRequest {
	r.sortBy = &sortBy
	return r
}

// Optional. Sort order.
func (r ApiGetLiveTvChannelsRequest) SortOrder(sortOrder SortOrder) ApiGetLiveTvChannelsRequest {
	r.sortOrder = &sortOrder
	return r
}

// Optional. Incorporate favorite and like status into channel sorting.
func (r ApiGetLiveTvChannelsRequest) EnableFavoriteSorting(enableFavoriteSorting bool) ApiGetLiveTvChannelsRequest {
	r.enableFavoriteSorting = &enableFavoriteSorting
	return r
}

// Optional. Adds current program info to each channel.
func (r ApiGetLiveTvChannelsRequest) AddCurrentProgram(addCurrentProgram bool) ApiGetLiveTvChannelsRequest {
	r.addCurrentProgram = &addCurrentProgram
	return r
}

func (r ApiGetLiveTvChannelsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetLiveTvChannelsExecute(r)
}

/*
GetLiveTvChannels Gets available live tv channels.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiveTvChannelsRequest
*/
func (a *LiveTvAPIService) GetLiveTvChannels(ctx context.Context) ApiGetLiveTvChannelsRequest {
	return ApiGetLiveTvChannelsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *LiveTvAPIService) GetLiveTvChannelsExecute(r ApiGetLiveTvChannelsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveTvChannels")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Channels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.isFavorite != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isFavorite", r.isFavorite, "form", "")
	}
	if r.isLiked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLiked", r.isLiked, "form", "")
	}
	if r.isDisliked != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isDisliked", r.isDisliked, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	if r.enableFavoriteSorting != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableFavoriteSorting", r.enableFavoriteSorting, "form", "")
	} else {
		var defaultValue bool = false
		r.enableFavoriteSorting = &defaultValue
	}
	if r.addCurrentProgram != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "addCurrentProgram", r.addCurrentProgram, "form", "")
	} else {
		var defaultValue bool = true
		r.addCurrentProgram = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveTvInfoRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
}

func (r ApiGetLiveTvInfoRequest) Execute() (*LiveTvInfo, *http.Response, error) {
	return r.ApiService.GetLiveTvInfoExecute(r)
}

/*
GetLiveTvInfo Gets available live tv services.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiveTvInfoRequest
*/
func (a *LiveTvAPIService) GetLiveTvInfo(ctx context.Context) ApiGetLiveTvInfoRequest {
	return ApiGetLiveTvInfoRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return LiveTvInfo
func (a *LiveTvAPIService) GetLiveTvInfoExecute(r ApiGetLiveTvInfoRequest) (*LiveTvInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveTvInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveTvInfo")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Info"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLiveTvProgramsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	channelIds *[]string
	userId *string
	minStartDate *time.Time
	hasAired *bool
	isAiring *bool
	maxStartDate *time.Time
	minEndDate *time.Time
	maxEndDate *time.Time
	isMovie *bool
	isSeries *bool
	isNews *bool
	isKids *bool
	isSports *bool
	startIndex *int32
	limit *int32
	sortBy *[]ItemSortBy
	sortOrder *[]SortOrder
	genres *[]string
	genreIds *[]string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]ImageType
	enableUserData *bool
	seriesTimerId *string
	librarySeriesId *string
	fields *[]ItemFields
	enableTotalRecordCount *bool
}

// The channels to return guide information for.
func (r ApiGetLiveTvProgramsRequest) ChannelIds(channelIds []string) ApiGetLiveTvProgramsRequest {
	r.channelIds = &channelIds
	return r
}

// Optional. Filter by user id.
func (r ApiGetLiveTvProgramsRequest) UserId(userId string) ApiGetLiveTvProgramsRequest {
	r.userId = &userId
	return r
}

// Optional. The minimum premiere start date.
func (r ApiGetLiveTvProgramsRequest) MinStartDate(minStartDate time.Time) ApiGetLiveTvProgramsRequest {
	r.minStartDate = &minStartDate
	return r
}

// Optional. Filter by programs that have completed airing, or not.
func (r ApiGetLiveTvProgramsRequest) HasAired(hasAired bool) ApiGetLiveTvProgramsRequest {
	r.hasAired = &hasAired
	return r
}

// Optional. Filter by programs that are currently airing, or not.
func (r ApiGetLiveTvProgramsRequest) IsAiring(isAiring bool) ApiGetLiveTvProgramsRequest {
	r.isAiring = &isAiring
	return r
}

// Optional. The maximum premiere start date.
func (r ApiGetLiveTvProgramsRequest) MaxStartDate(maxStartDate time.Time) ApiGetLiveTvProgramsRequest {
	r.maxStartDate = &maxStartDate
	return r
}

// Optional. The minimum premiere end date.
func (r ApiGetLiveTvProgramsRequest) MinEndDate(minEndDate time.Time) ApiGetLiveTvProgramsRequest {
	r.minEndDate = &minEndDate
	return r
}

// Optional. The maximum premiere end date.
func (r ApiGetLiveTvProgramsRequest) MaxEndDate(maxEndDate time.Time) ApiGetLiveTvProgramsRequest {
	r.maxEndDate = &maxEndDate
	return r
}

// Optional. Filter for movies.
func (r ApiGetLiveTvProgramsRequest) IsMovie(isMovie bool) ApiGetLiveTvProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for series.
func (r ApiGetLiveTvProgramsRequest) IsSeries(isSeries bool) ApiGetLiveTvProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for news.
func (r ApiGetLiveTvProgramsRequest) IsNews(isNews bool) ApiGetLiveTvProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for kids.
func (r ApiGetLiveTvProgramsRequest) IsKids(isKids bool) ApiGetLiveTvProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r ApiGetLiveTvProgramsRequest) IsSports(isSports bool) ApiGetLiveTvProgramsRequest {
	r.isSports = &isSports
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetLiveTvProgramsRequest) StartIndex(startIndex int32) ApiGetLiveTvProgramsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return.
func (r ApiGetLiveTvProgramsRequest) Limit(limit int32) ApiGetLiveTvProgramsRequest {
	r.limit = &limit
	return r
}

// Optional. Specify one or more sort orders, comma delimited. Options: Name, StartDate.
func (r ApiGetLiveTvProgramsRequest) SortBy(sortBy []ItemSortBy) ApiGetLiveTvProgramsRequest {
	r.sortBy = &sortBy
	return r
}

// Sort Order - Ascending,Descending.
func (r ApiGetLiveTvProgramsRequest) SortOrder(sortOrder []SortOrder) ApiGetLiveTvProgramsRequest {
	r.sortOrder = &sortOrder
	return r
}

// The genres to return guide information for.
func (r ApiGetLiveTvProgramsRequest) Genres(genres []string) ApiGetLiveTvProgramsRequest {
	r.genres = &genres
	return r
}

// The genre ids to return guide information for.
func (r ApiGetLiveTvProgramsRequest) GenreIds(genreIds []string) ApiGetLiveTvProgramsRequest {
	r.genreIds = &genreIds
	return r
}

// Optional. Include image information in output.
func (r ApiGetLiveTvProgramsRequest) EnableImages(enableImages bool) ApiGetLiveTvProgramsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r ApiGetLiveTvProgramsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetLiveTvProgramsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetLiveTvProgramsRequest) EnableImageTypes(enableImageTypes []ImageType) ApiGetLiveTvProgramsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Include user data.
func (r ApiGetLiveTvProgramsRequest) EnableUserData(enableUserData bool) ApiGetLiveTvProgramsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Filter by series timer id.
func (r ApiGetLiveTvProgramsRequest) SeriesTimerId(seriesTimerId string) ApiGetLiveTvProgramsRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Filter by library series id.
func (r ApiGetLiveTvProgramsRequest) LibrarySeriesId(librarySeriesId string) ApiGetLiveTvProgramsRequest {
	r.librarySeriesId = &librarySeriesId
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r ApiGetLiveTvProgramsRequest) Fields(fields []ItemFields) ApiGetLiveTvProgramsRequest {
	r.fields = &fields
	return r
}

// Retrieve total record count.
func (r ApiGetLiveTvProgramsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) ApiGetLiveTvProgramsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r ApiGetLiveTvProgramsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetLiveTvProgramsExecute(r)
}

/*
GetLiveTvPrograms Gets available live tv epgs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLiveTvProgramsRequest
*/
func (a *LiveTvAPIService) GetLiveTvPrograms(ctx context.Context) ApiGetLiveTvProgramsRequest {
	return ApiGetLiveTvProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *LiveTvAPIService) GetLiveTvProgramsExecute(r ApiGetLiveTvProgramsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetLiveTvPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelIds != nil {
		t := *r.channelIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "channelIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "channelIds", t, "form", "multi")
		}
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.minStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minStartDate", r.minStartDate, "form", "")
	}
	if r.hasAired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAired", r.hasAired, "form", "")
	}
	if r.isAiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isAiring", r.isAiring, "form", "")
	}
	if r.maxStartDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxStartDate", r.maxStartDate, "form", "")
	}
	if r.minEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "minEndDate", r.minEndDate, "form", "")
	}
	if r.maxEndDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "maxEndDate", r.maxEndDate, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.sortBy != nil {
		t := *r.sortBy
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", t, "form", "multi")
		}
	}
	if r.sortOrder != nil {
		t := *r.sortOrder
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", t, "form", "multi")
		}
	}
	if r.genres != nil {
		t := *r.genres
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genres", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genres", t, "form", "multi")
		}
	}
	if r.genreIds != nil {
		t := *r.genreIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", t, "form", "multi")
		}
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.librarySeriesId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "librarySeriesId", r.librarySeriesId, "form", "")
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProgramRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	programId string
	userId *string
}

// Optional. Attach user data.
func (r ApiGetProgramRequest) UserId(userId string) ApiGetProgramRequest {
	r.userId = &userId
	return r
}

func (r ApiGetProgramRequest) Execute() (*BaseItemDto, *http.Response, error) {
	return r.ApiService.GetProgramExecute(r)
}

/*
GetProgram Gets a live tv program.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param programId Program id.
 @return ApiGetProgramRequest
*/
func (a *LiveTvAPIService) GetProgram(ctx context.Context, programId string) ApiGetProgramRequest {
	return ApiGetProgramRequest{
		ApiService: a,
		ctx: ctx,
		programId: programId,
	}
}

// Execute executes the request
//  @return BaseItemDto
func (a *LiveTvAPIService) GetProgramExecute(r ApiGetProgramRequest) (*BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetProgram")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs/{programId}"
	localVarPath = strings.Replace(localVarPath, "{"+"programId"+"}", url.PathEscape(parameterValueToString(r.programId, "programId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProgramsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	getProgramsDto *GetProgramsDto
}

// Request body.
func (r ApiGetProgramsRequest) GetProgramsDto(getProgramsDto GetProgramsDto) ApiGetProgramsRequest {
	r.getProgramsDto = &getProgramsDto
	return r
}

func (r ApiGetProgramsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetProgramsExecute(r)
}

/*
GetPrograms Gets available live tv epgs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetProgramsRequest
*/
func (a *LiveTvAPIService) GetPrograms(ctx context.Context) ApiGetProgramsRequest {
	return ApiGetProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *LiveTvAPIService) GetProgramsExecute(r ApiGetProgramsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.getProgramsDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecommendedProgramsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	userId *string
	limit *int32
	isAiring *bool
	hasAired *bool
	isSeries *bool
	isMovie *bool
	isNews *bool
	isKids *bool
	isSports *bool
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]ImageType
	genreIds *[]string
	fields *[]ItemFields
	enableUserData *bool
	enableTotalRecordCount *bool
}

// Optional. filter by user id.
func (r ApiGetRecommendedProgramsRequest) UserId(userId string) ApiGetRecommendedProgramsRequest {
	r.userId = &userId
	return r
}

// Optional. The maximum number of records to return.
func (r ApiGetRecommendedProgramsRequest) Limit(limit int32) ApiGetRecommendedProgramsRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by programs that are currently airing, or not.
func (r ApiGetRecommendedProgramsRequest) IsAiring(isAiring bool) ApiGetRecommendedProgramsRequest {
	r.isAiring = &isAiring
	return r
}

// Optional. Filter by programs that have completed airing, or not.
func (r ApiGetRecommendedProgramsRequest) HasAired(hasAired bool) ApiGetRecommendedProgramsRequest {
	r.hasAired = &hasAired
	return r
}

// Optional. Filter for series.
func (r ApiGetRecommendedProgramsRequest) IsSeries(isSeries bool) ApiGetRecommendedProgramsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for movies.
func (r ApiGetRecommendedProgramsRequest) IsMovie(isMovie bool) ApiGetRecommendedProgramsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for news.
func (r ApiGetRecommendedProgramsRequest) IsNews(isNews bool) ApiGetRecommendedProgramsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for kids.
func (r ApiGetRecommendedProgramsRequest) IsKids(isKids bool) ApiGetRecommendedProgramsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r ApiGetRecommendedProgramsRequest) IsSports(isSports bool) ApiGetRecommendedProgramsRequest {
	r.isSports = &isSports
	return r
}

// Optional. Include image information in output.
func (r ApiGetRecommendedProgramsRequest) EnableImages(enableImages bool) ApiGetRecommendedProgramsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r ApiGetRecommendedProgramsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetRecommendedProgramsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetRecommendedProgramsRequest) EnableImageTypes(enableImageTypes []ImageType) ApiGetRecommendedProgramsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// The genres to return guide information for.
func (r ApiGetRecommendedProgramsRequest) GenreIds(genreIds []string) ApiGetRecommendedProgramsRequest {
	r.genreIds = &genreIds
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r ApiGetRecommendedProgramsRequest) Fields(fields []ItemFields) ApiGetRecommendedProgramsRequest {
	r.fields = &fields
	return r
}

// Optional. include user data.
func (r ApiGetRecommendedProgramsRequest) EnableUserData(enableUserData bool) ApiGetRecommendedProgramsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Retrieve total record count.
func (r ApiGetRecommendedProgramsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) ApiGetRecommendedProgramsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r ApiGetRecommendedProgramsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecommendedProgramsExecute(r)
}

/*
GetRecommendedPrograms Gets recommended live tv epgs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecommendedProgramsRequest
*/
func (a *LiveTvAPIService) GetRecommendedPrograms(ctx context.Context) ApiGetRecommendedProgramsRequest {
	return ApiGetRecommendedProgramsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *LiveTvAPIService) GetRecommendedProgramsExecute(r ApiGetRecommendedProgramsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecommendedPrograms")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Programs/Recommended"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.isAiring != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isAiring", r.isAiring, "form", "")
	}
	if r.hasAired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hasAired", r.hasAired, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.genreIds != nil {
		t := *r.genreIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "genreIds", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecordingRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	recordingId string
	userId *string
}

// Optional. Attach user data.
func (r ApiGetRecordingRequest) UserId(userId string) ApiGetRecordingRequest {
	r.userId = &userId
	return r
}

func (r ApiGetRecordingRequest) Execute() (*BaseItemDto, *http.Response, error) {
	return r.ApiService.GetRecordingExecute(r)
}

/*
GetRecording Gets a live tv recording.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param recordingId Recording id.
 @return ApiGetRecordingRequest
*/
func (a *LiveTvAPIService) GetRecording(ctx context.Context, recordingId string) ApiGetRecordingRequest {
	return ApiGetRecordingRequest{
		ApiService: a,
		ctx: ctx,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return BaseItemDto
func (a *LiveTvAPIService) GetRecordingExecute(r ApiGetRecordingRequest) (*BaseItemDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecording")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/{recordingId}"
	localVarPath = strings.Replace(localVarPath, "{"+"recordingId"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecordingFoldersRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	userId *string
}

// Optional. Filter by user and attach user data.
func (r ApiGetRecordingFoldersRequest) UserId(userId string) ApiGetRecordingFoldersRequest {
	r.userId = &userId
	return r
}

func (r ApiGetRecordingFoldersRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingFoldersExecute(r)
}

/*
GetRecordingFolders Gets recording folders.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecordingFoldersRequest
*/
func (a *LiveTvAPIService) GetRecordingFolders(ctx context.Context) ApiGetRecordingFoldersRequest {
	return ApiGetRecordingFoldersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *LiveTvAPIService) GetRecordingFoldersExecute(r ApiGetRecordingFoldersRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingFolders")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Folders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecordingGroupRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	groupId string
}

func (r ApiGetRecordingGroupRequest) Execute() (*http.Response, error) {
	return r.ApiService.GetRecordingGroupExecute(r)
}

/*
GetRecordingGroup Get recording group.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param groupId Group id.
 @return ApiGetRecordingGroupRequest

Deprecated
*/
func (a *LiveTvAPIService) GetRecordingGroup(ctx context.Context, groupId string) ApiGetRecordingGroupRequest {
	return ApiGetRecordingGroupRequest{
		ApiService: a,
		ctx: ctx,
		groupId: groupId,
	}
}

// Execute executes the request
// Deprecated
func (a *LiveTvAPIService) GetRecordingGroupExecute(r ApiGetRecordingGroupRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingGroup")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Groups/{groupId}"
	localVarPath = strings.Replace(localVarPath, "{"+"groupId"+"}", url.PathEscape(parameterValueToString(r.groupId, "groupId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetRecordingGroupsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	userId *string
}

// Optional. Filter by user and attach user data.
func (r ApiGetRecordingGroupsRequest) UserId(userId string) ApiGetRecordingGroupsRequest {
	r.userId = &userId
	return r
}

func (r ApiGetRecordingGroupsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingGroupsExecute(r)
}

/*
GetRecordingGroups Gets live tv recording groups.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecordingGroupsRequest

Deprecated
*/
func (a *LiveTvAPIService) GetRecordingGroups(ctx context.Context) ApiGetRecordingGroupsRequest {
	return ApiGetRecordingGroupsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
// Deprecated
func (a *LiveTvAPIService) GetRecordingGroupsExecute(r ApiGetRecordingGroupsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingGroups")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Groups"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecordingsRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	channelId *string
	userId *string
	startIndex *int32
	limit *int32
	status *RecordingStatus
	isInProgress *bool
	seriesTimerId *string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]ImageType
	fields *[]ItemFields
	enableUserData *bool
	isMovie *bool
	isSeries *bool
	isKids *bool
	isSports *bool
	isNews *bool
	isLibraryItem *bool
	enableTotalRecordCount *bool
}

// Optional. Filter by channel id.
func (r ApiGetRecordingsRequest) ChannelId(channelId string) ApiGetRecordingsRequest {
	r.channelId = &channelId
	return r
}

// Optional. Filter by user and attach user data.
func (r ApiGetRecordingsRequest) UserId(userId string) ApiGetRecordingsRequest {
	r.userId = &userId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetRecordingsRequest) StartIndex(startIndex int32) ApiGetRecordingsRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return.
func (r ApiGetRecordingsRequest) Limit(limit int32) ApiGetRecordingsRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by recording status.
func (r ApiGetRecordingsRequest) Status(status RecordingStatus) ApiGetRecordingsRequest {
	r.status = &status
	return r
}

// Optional. Filter by recordings that are in progress, or not.
func (r ApiGetRecordingsRequest) IsInProgress(isInProgress bool) ApiGetRecordingsRequest {
	r.isInProgress = &isInProgress
	return r
}

// Optional. Filter by recordings belonging to a series timer.
func (r ApiGetRecordingsRequest) SeriesTimerId(seriesTimerId string) ApiGetRecordingsRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Include image information in output.
func (r ApiGetRecordingsRequest) EnableImages(enableImages bool) ApiGetRecordingsRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r ApiGetRecordingsRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetRecordingsRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetRecordingsRequest) EnableImageTypes(enableImageTypes []ImageType) ApiGetRecordingsRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r ApiGetRecordingsRequest) Fields(fields []ItemFields) ApiGetRecordingsRequest {
	r.fields = &fields
	return r
}

// Optional. Include user data.
func (r ApiGetRecordingsRequest) EnableUserData(enableUserData bool) ApiGetRecordingsRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Filter for movies.
func (r ApiGetRecordingsRequest) IsMovie(isMovie bool) ApiGetRecordingsRequest {
	r.isMovie = &isMovie
	return r
}

// Optional. Filter for series.
func (r ApiGetRecordingsRequest) IsSeries(isSeries bool) ApiGetRecordingsRequest {
	r.isSeries = &isSeries
	return r
}

// Optional. Filter for kids.
func (r ApiGetRecordingsRequest) IsKids(isKids bool) ApiGetRecordingsRequest {
	r.isKids = &isKids
	return r
}

// Optional. Filter for sports.
func (r ApiGetRecordingsRequest) IsSports(isSports bool) ApiGetRecordingsRequest {
	r.isSports = &isSports
	return r
}

// Optional. Filter for news.
func (r ApiGetRecordingsRequest) IsNews(isNews bool) ApiGetRecordingsRequest {
	r.isNews = &isNews
	return r
}

// Optional. Filter for is library item.
func (r ApiGetRecordingsRequest) IsLibraryItem(isLibraryItem bool) ApiGetRecordingsRequest {
	r.isLibraryItem = &isLibraryItem
	return r
}

// Optional. Return total record count.
func (r ApiGetRecordingsRequest) EnableTotalRecordCount(enableTotalRecordCount bool) ApiGetRecordingsRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r ApiGetRecordingsRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingsExecute(r)
}

/*
GetRecordings Gets live tv recordings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecordingsRequest
*/
func (a *LiveTvAPIService) GetRecordings(ctx context.Context) ApiGetRecordingsRequest {
	return ApiGetRecordingsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
func (a *LiveTvAPIService) GetRecordingsExecute(r ApiGetRecordingsRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordings")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", r.channelId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.isInProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isInProgress", r.isInProgress, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.isMovie != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isMovie", r.isMovie, "form", "")
	}
	if r.isSeries != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSeries", r.isSeries, "form", "")
	}
	if r.isKids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isKids", r.isKids, "form", "")
	}
	if r.isSports != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isSports", r.isSports, "form", "")
	}
	if r.isNews != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isNews", r.isNews, "form", "")
	}
	if r.isLibraryItem != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isLibraryItem", r.isLibraryItem, "form", "")
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetRecordingsSeriesRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	channelId *string
	userId *string
	groupId *string
	startIndex *int32
	limit *int32
	status *RecordingStatus
	isInProgress *bool
	seriesTimerId *string
	enableImages *bool
	imageTypeLimit *int32
	enableImageTypes *[]ImageType
	fields *[]ItemFields
	enableUserData *bool
	enableTotalRecordCount *bool
}

// Optional. Filter by channel id.
func (r ApiGetRecordingsSeriesRequest) ChannelId(channelId string) ApiGetRecordingsSeriesRequest {
	r.channelId = &channelId
	return r
}

// Optional. Filter by user and attach user data.
func (r ApiGetRecordingsSeriesRequest) UserId(userId string) ApiGetRecordingsSeriesRequest {
	r.userId = &userId
	return r
}

// Optional. Filter by recording group.
func (r ApiGetRecordingsSeriesRequest) GroupId(groupId string) ApiGetRecordingsSeriesRequest {
	r.groupId = &groupId
	return r
}

// Optional. The record index to start at. All items with a lower index will be dropped from the results.
func (r ApiGetRecordingsSeriesRequest) StartIndex(startIndex int32) ApiGetRecordingsSeriesRequest {
	r.startIndex = &startIndex
	return r
}

// Optional. The maximum number of records to return.
func (r ApiGetRecordingsSeriesRequest) Limit(limit int32) ApiGetRecordingsSeriesRequest {
	r.limit = &limit
	return r
}

// Optional. Filter by recording status.
func (r ApiGetRecordingsSeriesRequest) Status(status RecordingStatus) ApiGetRecordingsSeriesRequest {
	r.status = &status
	return r
}

// Optional. Filter by recordings that are in progress, or not.
func (r ApiGetRecordingsSeriesRequest) IsInProgress(isInProgress bool) ApiGetRecordingsSeriesRequest {
	r.isInProgress = &isInProgress
	return r
}

// Optional. Filter by recordings belonging to a series timer.
func (r ApiGetRecordingsSeriesRequest) SeriesTimerId(seriesTimerId string) ApiGetRecordingsSeriesRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Include image information in output.
func (r ApiGetRecordingsSeriesRequest) EnableImages(enableImages bool) ApiGetRecordingsSeriesRequest {
	r.enableImages = &enableImages
	return r
}

// Optional. The max number of images to return, per image type.
func (r ApiGetRecordingsSeriesRequest) ImageTypeLimit(imageTypeLimit int32) ApiGetRecordingsSeriesRequest {
	r.imageTypeLimit = &imageTypeLimit
	return r
}

// Optional. The image types to include in the output.
func (r ApiGetRecordingsSeriesRequest) EnableImageTypes(enableImageTypes []ImageType) ApiGetRecordingsSeriesRequest {
	r.enableImageTypes = &enableImageTypes
	return r
}

// Optional. Specify additional fields of information to return in the output.
func (r ApiGetRecordingsSeriesRequest) Fields(fields []ItemFields) ApiGetRecordingsSeriesRequest {
	r.fields = &fields
	return r
}

// Optional. Include user data.
func (r ApiGetRecordingsSeriesRequest) EnableUserData(enableUserData bool) ApiGetRecordingsSeriesRequest {
	r.enableUserData = &enableUserData
	return r
}

// Optional. Return total record count.
func (r ApiGetRecordingsSeriesRequest) EnableTotalRecordCount(enableTotalRecordCount bool) ApiGetRecordingsSeriesRequest {
	r.enableTotalRecordCount = &enableTotalRecordCount
	return r
}

func (r ApiGetRecordingsSeriesRequest) Execute() (*BaseItemDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetRecordingsSeriesExecute(r)
}

/*
GetRecordingsSeries Gets live tv recording series.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetRecordingsSeriesRequest

Deprecated
*/
func (a *LiveTvAPIService) GetRecordingsSeries(ctx context.Context) ApiGetRecordingsSeriesRequest {
	return ApiGetRecordingsSeriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return BaseItemDtoQueryResult
// Deprecated
func (a *LiveTvAPIService) GetRecordingsSeriesExecute(r ApiGetRecordingsSeriesRequest) (*BaseItemDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BaseItemDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetRecordingsSeries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Recordings/Series"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", r.channelId, "form", "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "form", "")
	}
	if r.groupId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "groupId", r.groupId, "form", "")
	}
	if r.startIndex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "startIndex", r.startIndex, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "form", "")
	}
	if r.isInProgress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isInProgress", r.isInProgress, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.enableImages != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableImages", r.enableImages, "form", "")
	}
	if r.imageTypeLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "imageTypeLimit", r.imageTypeLimit, "form", "")
	}
	if r.enableImageTypes != nil {
		t := *r.enableImageTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "enableImageTypes", t, "form", "multi")
		}
	}
	if r.fields != nil {
		t := *r.fields
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "fields", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "fields", t, "form", "multi")
		}
	}
	if r.enableUserData != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableUserData", r.enableUserData, "form", "")
	}
	if r.enableTotalRecordCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enableTotalRecordCount", r.enableTotalRecordCount, "form", "")
	} else {
		var defaultValue bool = true
		r.enableTotalRecordCount = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSchedulesDirectCountriesRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
}

func (r ApiGetSchedulesDirectCountriesRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.GetSchedulesDirectCountriesExecute(r)
}

/*
GetSchedulesDirectCountries Gets available countries.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSchedulesDirectCountriesRequest
*/
func (a *LiveTvAPIService) GetSchedulesDirectCountries(ctx context.Context) ApiGetSchedulesDirectCountriesRequest {
	return ApiGetSchedulesDirectCountriesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return *os.File
func (a *LiveTvAPIService) GetSchedulesDirectCountriesExecute(r ApiGetSchedulesDirectCountriesRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetSchedulesDirectCountries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ListingProviders/SchedulesDirect/Countries"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	timerId string
}

func (r ApiGetSeriesTimerRequest) Execute() (*SeriesTimerInfoDto, *http.Response, error) {
	return r.ApiService.GetSeriesTimerExecute(r)
}

/*
GetSeriesTimer Gets a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return ApiGetSeriesTimerRequest
*/
func (a *LiveTvAPIService) GetSeriesTimer(ctx context.Context, timerId string) ApiGetSeriesTimerRequest {
	return ApiGetSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
//  @return SeriesTimerInfoDto
func (a *LiveTvAPIService) GetSeriesTimerExecute(r ApiGetSeriesTimerRequest) (*SeriesTimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SeriesTimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetSeriesTimer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ProblemDetails
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSeriesTimersRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	sortBy *string
	sortOrder *SortOrder
}

// Optional. Sort by SortName or Priority.
func (r ApiGetSeriesTimersRequest) SortBy(sortBy string) ApiGetSeriesTimersRequest {
	r.sortBy = &sortBy
	return r
}

// Optional. Sort in Ascending or Descending order.
func (r ApiGetSeriesTimersRequest) SortOrder(sortOrder SortOrder) ApiGetSeriesTimersRequest {
	r.sortOrder = &sortOrder
	return r
}

func (r ApiGetSeriesTimersRequest) Execute() (*SeriesTimerInfoDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetSeriesTimersExecute(r)
}

/*
GetSeriesTimers Gets live tv series timers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetSeriesTimersRequest
*/
func (a *LiveTvAPIService) GetSeriesTimers(ctx context.Context) ApiGetSeriesTimersRequest {
	return ApiGetSeriesTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SeriesTimerInfoDtoQueryResult
func (a *LiveTvAPIService) GetSeriesTimersExecute(r ApiGetSeriesTimersRequest) (*SeriesTimerInfoDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SeriesTimerInfoDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetSeriesTimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.sortBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortBy", r.sortBy, "form", "")
	}
	if r.sortOrder != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortOrder", r.sortOrder, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	timerId string
}

func (r ApiGetTimerRequest) Execute() (*TimerInfoDto, *http.Response, error) {
	return r.ApiService.GetTimerExecute(r)
}

/*
GetTimer Gets a timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return ApiGetTimerRequest
*/
func (a *LiveTvAPIService) GetTimer(ctx context.Context, timerId string) ApiGetTimerRequest {
	return ApiGetTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
//  @return TimerInfoDto
func (a *LiveTvAPIService) GetTimerExecute(r ApiGetTimerRequest) (*TimerInfoDto, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimerInfoDto
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetTimer")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTimersRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	channelId *string
	seriesTimerId *string
	isActive *bool
	isScheduled *bool
}

// Optional. Filter by channel id.
func (r ApiGetTimersRequest) ChannelId(channelId string) ApiGetTimersRequest {
	r.channelId = &channelId
	return r
}

// Optional. Filter by timers belonging to a series timer.
func (r ApiGetTimersRequest) SeriesTimerId(seriesTimerId string) ApiGetTimersRequest {
	r.seriesTimerId = &seriesTimerId
	return r
}

// Optional. Filter by timers that are active.
func (r ApiGetTimersRequest) IsActive(isActive bool) ApiGetTimersRequest {
	r.isActive = &isActive
	return r
}

// Optional. Filter by timers that are scheduled.
func (r ApiGetTimersRequest) IsScheduled(isScheduled bool) ApiGetTimersRequest {
	r.isScheduled = &isScheduled
	return r
}

func (r ApiGetTimersRequest) Execute() (*TimerInfoDtoQueryResult, *http.Response, error) {
	return r.ApiService.GetTimersExecute(r)
}

/*
GetTimers Gets the live tv timers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTimersRequest
*/
func (a *LiveTvAPIService) GetTimers(ctx context.Context) ApiGetTimersRequest {
	return ApiGetTimersRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TimerInfoDtoQueryResult
func (a *LiveTvAPIService) GetTimersExecute(r ApiGetTimersRequest) (*TimerInfoDtoQueryResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TimerInfoDtoQueryResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetTimers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.channelId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "channelId", r.channelId, "form", "")
	}
	if r.seriesTimerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "seriesTimerId", r.seriesTimerId, "form", "")
	}
	if r.isActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isActive", r.isActive, "form", "")
	}
	if r.isScheduled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "isScheduled", r.isScheduled, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetTunerHostTypesRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
}

func (r ApiGetTunerHostTypesRequest) Execute() ([]NameIdPair, *http.Response, error) {
	return r.ApiService.GetTunerHostTypesExecute(r)
}

/*
GetTunerHostTypes Get tuner host types.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetTunerHostTypesRequest
*/
func (a *LiveTvAPIService) GetTunerHostTypes(ctx context.Context) ApiGetTunerHostTypesRequest {
	return ApiGetTunerHostTypesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []NameIdPair
func (a *LiveTvAPIService) GetTunerHostTypesExecute(r ApiGetTunerHostTypesRequest) ([]NameIdPair, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []NameIdPair
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.GetTunerHostTypes")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/TunerHosts/Types"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetTunerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	tunerId string
}

func (r ApiResetTunerRequest) Execute() (*http.Response, error) {
	return r.ApiService.ResetTunerExecute(r)
}

/*
ResetTuner Resets a tv tuner.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param tunerId Tuner id.
 @return ApiResetTunerRequest
*/
func (a *LiveTvAPIService) ResetTuner(ctx context.Context, tunerId string) ApiResetTunerRequest {
	return ApiResetTunerRequest{
		ApiService: a,
		ctx: ctx,
		tunerId: tunerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) ResetTunerExecute(r ApiResetTunerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.ResetTuner")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Tuners/{tunerId}/Reset"
	localVarPath = strings.Replace(localVarPath, "{"+"tunerId"+"}", url.PathEscape(parameterValueToString(r.tunerId, "tunerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSetChannelMappingRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	setChannelMappingDto *SetChannelMappingDto
}

// The set channel mapping dto.
func (r ApiSetChannelMappingRequest) SetChannelMappingDto(setChannelMappingDto SetChannelMappingDto) ApiSetChannelMappingRequest {
	r.setChannelMappingDto = &setChannelMappingDto
	return r
}

func (r ApiSetChannelMappingRequest) Execute() (*TunerChannelMapping, *http.Response, error) {
	return r.ApiService.SetChannelMappingExecute(r)
}

/*
SetChannelMapping Set channel mappings.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSetChannelMappingRequest
*/
func (a *LiveTvAPIService) SetChannelMapping(ctx context.Context) ApiSetChannelMappingRequest {
	return ApiSetChannelMappingRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TunerChannelMapping
func (a *LiveTvAPIService) SetChannelMappingExecute(r ApiSetChannelMappingRequest) (*TunerChannelMapping, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TunerChannelMapping
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.SetChannelMapping")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/ChannelMappings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.setChannelMappingDto == nil {
		return localVarReturnValue, nil, reportError("setChannelMappingDto is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/json; profile=CamelCase", "application/json; profile=PascalCase"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.setChannelMappingDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSeriesTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	timerId string
	seriesTimerInfoDto *SeriesTimerInfoDto
}

// New series timer info.
func (r ApiUpdateSeriesTimerRequest) SeriesTimerInfoDto(seriesTimerInfoDto SeriesTimerInfoDto) ApiUpdateSeriesTimerRequest {
	r.seriesTimerInfoDto = &seriesTimerInfoDto
	return r
}

func (r ApiUpdateSeriesTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateSeriesTimerExecute(r)
}

/*
UpdateSeriesTimer Updates a live tv series timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return ApiUpdateSeriesTimerRequest
*/
func (a *LiveTvAPIService) UpdateSeriesTimer(ctx context.Context, timerId string) ApiUpdateSeriesTimerRequest {
	return ApiUpdateSeriesTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) UpdateSeriesTimerExecute(r ApiUpdateSeriesTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.UpdateSeriesTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/SeriesTimers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.seriesTimerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiUpdateTimerRequest struct {
	ctx context.Context
	ApiService LiveTvAPI
	timerId string
	timerInfoDto *TimerInfoDto
}

// New timer info.
func (r ApiUpdateTimerRequest) TimerInfoDto(timerInfoDto TimerInfoDto) ApiUpdateTimerRequest {
	r.timerInfoDto = &timerInfoDto
	return r
}

func (r ApiUpdateTimerRequest) Execute() (*http.Response, error) {
	return r.ApiService.UpdateTimerExecute(r)
}

/*
UpdateTimer Updates a live tv timer.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param timerId Timer id.
 @return ApiUpdateTimerRequest
*/
func (a *LiveTvAPIService) UpdateTimer(ctx context.Context, timerId string) ApiUpdateTimerRequest {
	return ApiUpdateTimerRequest{
		ApiService: a,
		ctx: ctx,
		timerId: timerId,
	}
}

// Execute executes the request
func (a *LiveTvAPIService) UpdateTimerExecute(r ApiUpdateTimerRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveTvAPIService.UpdateTimer")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/LiveTv/Timers/{timerId}"
	localVarPath = strings.Replace(localVarPath, "{"+"timerId"+"}", url.PathEscape(parameterValueToString(r.timerId, "timerId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "text/json", "application/*+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.timerInfoDto
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["CustomAuthentication"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}
